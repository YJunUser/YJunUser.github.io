<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何在React中封装一个组件</title>
      <link href="2021/05/17/useState%E7%9A%84%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%87%BD%E6%95%B0/"/>
      <url>2021/05/17/useState%E7%9A%84%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天在做一个功能的时候，需要用到<code>useState</code>保存一个函数，并<code>setState</code>去改变这个函数的状态，初始代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import "./styles.css";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">export default function App() {</span><br><span class="line">  const [callback, setCallback] = React.useState(() =&gt; {</span><br><span class="line">    return "init";</span><br><span class="line">  });</span><br><span class="line">  console.log(callback);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick={() =&gt;</span><br><span class="line">          setCallback(() =&gt; {</span><br><span class="line">            return "update";</span><br><span class="line">          })</span><br><span class="line">        }</span><br><span class="line">      &gt;</span><br><span class="line">        改变函数</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>很快，页面崩溃了，控制台报错：</p><p><img src="images/artical-image/image-20210517143331706.png" alt="image-20210517143331706"></p><p>一开始<code>init</code>就输出了一次，点<code>button</code>后<code>update</code>输出，这是为啥呢？我只是想保存函数，并不想让他执行</p><h2 id="惰性初始State"><a href="#惰性初始State" class="headerlink" title="惰性初始State"></a>惰性初始State</h2><p>为了调查上述问题，当然是去看<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html">React官方文档</a>，在<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html">hooksAPI</a>，这一节中，我发现了问题所在，惰性初始State：</p><h4 id="惰性初始-state"><a href="#惰性初始-state" class="headerlink" title="惰性初始 state"></a>惰性初始 state</h4><p><code>initialState</code> 参数只会在组件的<strong>初始渲染中</strong>起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [state, setState] = useState(() =&gt; {</span><br><span class="line">  const initialState = someExpensiveComputation(props);</span><br><span class="line">  return initialState;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>也就是说，给<code>useState</code>传入一个函数并不会保存函数状态，而是立即执行这个函数，并且只在初始渲染时执行，我猜测应该是为了避免一些高开销的运算，因为官方文档给的代码中函数名就是<code>someExpensiveComputation</code>。</p><p>这就解释了之前的问题，一开始我是想用<code>useState</code>保存一个函数，但这个函数立即就执行了，并且输出了<code>init</code>。</p><p>而在我后面调用<code>setState</code>去更新函数状态的时候，实际上是<code>React</code>以为你要更新那个惰性初始的<code>state</code>，于是就执行了<code>setCallback</code>，并用返回的<code>update</code>更新了callback</p><h2 id="如何保存函数"><a href="#如何保存函数" class="headerlink" title="如何保存函数"></a>如何保存函数</h2><p>那<code>state</code>该如何保存函数呢</p><h3 id="方法1-额外加一个函数"><a href="#方法1-额外加一个函数" class="headerlink" title="方法1 额外加一个函数"></a>方法1 额外加一个函数</h3><p>既然<code>useState</code>中函数作为参数是惰性初始化的意思，那我们再返回一个函数不就好了吗？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import "./styles.css";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">export default function App() {</span><br><span class="line">  const [callback, setCallback] = React.useState(() =&gt; () =&gt; {</span><br><span class="line">    alert("init");</span><br><span class="line">  });</span><br><span class="line">  console.log(callback);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick={() =&gt;</span><br><span class="line">          setCallback(() =&gt; () =&gt; {</span><br><span class="line">            alert("update");</span><br><span class="line">          })</span><br><span class="line">        }</span><br><span class="line">      &gt;</span><br><span class="line">        改变函数</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; callback()}&gt;执行函数&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我们点击<em>执行函数</em>的时候，<code>alert</code>了一个<code>init</code>，当我们<em>改变函数</em>后再去<em>执行函数</em>，<code>alert</code>了一个<code>update</code>，实现了保存函数功能</p><h3 id="方法2-useRef"><a href="#方法2-useRef" class="headerlink" title="方法2 useRef"></a>方法2 useRef</h3><p>当我们想保存一个东西的时候，想到<code>useRef</code>准没错</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import "./styles.css";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">export default function App() {</span><br><span class="line">  const callback = React.useRef(() =&gt; {</span><br><span class="line">    console.log("init");</span><br><span class="line">  });</span><br><span class="line">  console.log(callback);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick={() =&gt; {</span><br><span class="line">          callback.current = () =&gt; {</span><br><span class="line">            console.log("update");</span><br><span class="line">          };</span><br><span class="line">        }}</span><br><span class="line">      &gt;</span><br><span class="line">        改变函数</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick={callback}&gt;执行函数&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>但又出现了新的问题，点击改变函数后，输出的还是<code>init</code>，这是因为<code>useRef</code>的改变并不会引起页面重新渲染。</p><p><code>callback</code>仍然是初次渲染被赋予的函数</p><p>将代码改为如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import "./styles.css";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">export default function App() {</span><br><span class="line">  const callback = React.useRef(() =&gt; {</span><br><span class="line">    console.log("init");</span><br><span class="line">  });</span><br><span class="line">  console.log(callback);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick={() =&gt; {</span><br><span class="line">          callback.current = () =&gt; {</span><br><span class="line">            console.log("update");</span><br><span class="line">          };</span><br><span class="line">        }}</span><br><span class="line">      &gt;</span><br><span class="line">        改变函数</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">          // 将callback换成callback.current()</span><br><span class="line">      &lt;button onClick={() =&gt; callback.current()}&gt;执行函数&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>功能正常，完毕</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>useMemo和useEffect</title>
      <link href="2021/05/15/useMemo%E5%92%8CuseEffect/"/>
      <url>2021/05/15/useMemo%E5%92%8CuseEffect/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, {Fragment} <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { useState, useMemo } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品名称列表</span></span><br><span class="line"><span class="keyword">const</span> nameList = [<span class="string">'apple'</span>, <span class="string">'peer'</span>, <span class="string">'banana'</span>, <span class="string">'lemon'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> example = <span class="function">(<span class="params">props</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 产品名称、价格</span></span><br><span class="line">    <span class="keyword">const</span> [price, setPrice] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">'apple'</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设有一个业务函数  获取产品的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getProductName</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getProductName触发'</span>)</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt;{name}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{price}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{getProductName()}&lt;/p&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setPrice(price+<span class="number">1</span>)}&gt;价钱+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setName(nameList[<span class="built_in">Math</span>.random() * nameList.length &lt;&lt; <span class="number">0</span>])}&gt;修改名字&lt;/button&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">}</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> example</span><br></pre></td></tr></tbody></table></figure><p>现在问几个问题：<br>发生下面几种情况会重新渲染界面吗（也就是<code>getProductName</code>函数会被触发）？</p><ol><li>点击价钱+1按钮？</li><li>点击修改名字按钮？</li></ol><p>很显然在进行<code>DOM</code>相关操作（如<code>setState</code>）后，都会触发<code>getProductName</code>函数，但是我们想知道这个产品的名字，产品的价格怎么变不是我们关心的，所以我们需要让这个函数只在产品名字改变的时候再触发，而不是每次重新渲染都触发。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect ?"></a>useEffect ?</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, {Fragment} <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { useState, useEffect, useCallback, useMemo } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { observer } <span class="keyword">from</span> <span class="string">'mobx-react'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nameList = [<span class="string">'apple'</span>, <span class="string">'peer'</span>, <span class="string">'banana'</span>, <span class="string">'lemon'</span>]</span><br><span class="line"><span class="keyword">const</span> Example = observer(<span class="function">(<span class="params">props</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> [price, setPrice] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">'apple'</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getProductName</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getProductName触发'</span>)</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 只对name响应</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name effect 触发'</span>)</span><br><span class="line">        getProductName()</span><br><span class="line">    }, [name])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只对price响应</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'price effect 触发'</span>)</span><br><span class="line">    }, [price])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt;{name}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{price}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{getProductName()}&lt;/p&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setPrice(price+<span class="number">1</span>)}&gt;价钱+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setName(nameList[<span class="built_in">Math</span>.random() * nameList.length &lt;&lt; <span class="number">0</span>])}&gt;修改名字&lt;/button&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">})</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example</span><br></pre></td></tr></tbody></table></figure><ol><li>先看看<code>useEffect</code>的工作顺序，若点击修改名字按钮会打印什么？</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; getProductName触发 </span><br><span class="line">&gt; name effect 触发</span><br><span class="line">&gt; getProductName触发 </span><br></pre></td></tr></tbody></table></figure><p>官方文档有说过 <a href="https://links.jianshu.com/go?to=https://zh-hans.reactjs.org/docs/hooks-overview.html">当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数</a></p><p>所以这个顺序很好理解</p><ul><li>因为修改了名字，然后<code>react</code>更改了<code>DOM</code>，触发了<code>getProductName</code></li><li>随后调用了<code>name</code>的<code>effect</code>（在<code>dom</code>更新之后触发，这也是为什么叫做副作用）</li><li><code>effect</code>中调用了<code>getProductName</code></li></ul><p>若点击价钱+1按钮会打印什么？</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; getProductName触发 </span><br><span class="line">&gt; price effect 触发</span><br></pre></td></tr></tbody></table></figure><p>我改变的是价格，还是触发了<code>getProductName</code></p><p>稍微分析：</p><ul><li>显然当我使用<code>setPrice</code>的时候，产生<code>DOM</code>操作，刷新页面<code>DOM</code>的同时也，触发了在<code>p</code>标签中的<code>getProductName</code>函数</li><li>然后调用副作用触发了<code>price</code>的<code>effect</code></li></ul><p>就如前面我所提出的问题，我们的目标是在<code>DOM</code>发生变化时，不相关的函数不需要触发（也就是这里的<code>getProductName</code>在我修改价格的时候不应该触发），而<code>useEffect</code>只能在<code>DOM</code>更新后再触发再去控制，所以这个马后炮并没有什么🐦用</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo?"></a>useMemo?</h2><p>使用<code>useMemo</code>可以解决这个问题<br> 为什么<code>useMemo</code>可以解决？官方文档说过<a href="https://links.jianshu.com/go?to=https://zh-hans.reactjs.org/docs/hooks-reference.html%23usememo">传入 useMemo 的函数会在渲染期间执行</a>，所以使用<code>useMemo</code>就能解决之前的问题，怎么在<code>DOM</code>改变的时候，控制某些函数不被触发。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, {Fragment} <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { useState, useEffect, useCallback, useMemo } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { observer } <span class="keyword">from</span> <span class="string">'mobx-react'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nameList = [<span class="string">'apple'</span>, <span class="string">'peer'</span>, <span class="string">'banana'</span>, <span class="string">'lemon'</span>]</span><br><span class="line"><span class="keyword">const</span> Example = observer(<span class="function">(<span class="params">props</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> [price, setPrice] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">'apple'</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getProductName</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getProductName触发'</span>)</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 只对name响应</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name effect 触发'</span>)</span><br><span class="line">        getProductName()</span><br><span class="line">    }, [name])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只对price响应</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'price effect 触发'</span>)</span><br><span class="line">    }, [price])</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// memo化的getProductName函数   🧬🧬🧬</span></span><br><span class="line">    <span class="keyword">const</span> memo_getProductName = useMemo(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name memo 触发'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> name  <span class="comment">// 返回一个函数</span></span><br><span class="line">    }, [name])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt;{name}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{price}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;普通的name：{getProductName()}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;memo化的：{memo_getProductName ()}&lt;/p&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setPrice(price+<span class="number">1</span>)}&gt;价钱+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setName(nameList[<span class="built_in">Math</span>.random() * nameList.length &lt;&lt; <span class="number">0</span>])}&gt;修改名字&lt;/button&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">})</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example</span><br></pre></td></tr></tbody></table></figure><p>同样两个问题</p><ol><li>点击价钱+1按钮会发生什么</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; getProductName触发</span><br><span class="line">&gt; price effect 触发</span><br></pre></td></tr></tbody></table></figure><ul><li>首先<code>DOM</code>改变，触发在<code>p</code>标签中的<code>getProductName</code>函数</li><li>然后调用<code>effect</code></li></ul><p>显然我们已经成功的控制了触发（修改了显示<code>price</code>的<code>dom</code>，但是没有触发<code>memo_getProductName</code>，没有输出’’name memo 触发’’），<br> 这也是官方为什么说不能在<code>useMemo</code>中操作<code>DOM</code>之类的副作用操作，<a href="https://links.jianshu.com/go?to=https://zh-hans.reactjs.org/docs/hooks-reference.html%23usememo">不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo</a>，你可以试一下，在<code>useMemo</code>中使用<code>setState</code>你会发现会产生死循环，并且会有警告，因为<code>useMemo</code>是在渲染中进行的，你在其中操作<code>DOM</code>后，又会导致<code>memo</code>触发</p><ol><li>点击修改名字按钮会发生什么</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; name memo 触发</span><br><span class="line">&gt; getProductName触发</span><br><span class="line">&gt; name effect 触发</span><br><span class="line">&gt; getProductName触发</span><br></pre></td></tr></tbody></table></figure><ul><li>首先<code>DOM</code>变化，触发<code>name</code>的<code>memo</code>，</li><li>然后触发<code>p</code>标签内的<code>getProductName</code>函数</li><li><code>DOM</code>操作结束后触发<code>name</code>的<code>effect</code></li><li>在<code>name</code>的<code>effect</code>中触发<code>getProductName</code></li></ul><p>从这里也可以看出，<code>useMemo</code>是在**<code>DOM</code>更新前触**发的，<code>useEffect</code>是在<code>DOM</code><strong>更新后</strong>触发的就像官方所说的</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在React中封装一个组件</title>
      <link href="2021/05/15/%E5%A6%82%E4%BD%95%E5%9C%A8React%E4%B8%AD%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/"/>
      <url>2021/05/15/%E5%A6%82%E4%BD%95%E5%9C%A8React%E4%B8%AD%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="在React中封装一个组件"><a href="#在React中封装一个组件" class="headerlink" title="在React中封装一个组件"></a>在React中封装一个组件</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在学习<code>React</code>，看了许多教学视频，今天学到了一个封装组件较完善的方法，特此记录下来。</p><p>我们知道<code>select</code>标签经常有显示的问题，例如<code>id</code>和<code>name</code>对应不上，原因在于<code>value</code>属性的值：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Select</span><br><span class="line">          value={param.personId}</span><br><span class="line">          onChange={(value) =&gt;</span><br><span class="line">            setParam({</span><br><span class="line">              ...param,</span><br><span class="line">              personId: value,</span><br><span class="line">            })</span><br><span class="line">          }</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;Select.Option value={""}&gt;负责人&lt;/Select.Option&gt;</span><br><span class="line">          {users.map((user) =&gt; (</span><br><span class="line">            &lt;Select.Option key={user.id} value={String(user.id)}&gt;</span><br><span class="line">              {user.name}</span><br><span class="line">            &lt;/Select.Option&gt;</span><br><span class="line">          ))}</span><br><span class="line">        &lt;/Select&gt;</span><br></pre></td></tr></tbody></table></figure><p><code>Option</code>中的value值在传给<code>onChange</code>回调函数中时，如果是<code>number</code>类型，但<code>personId</code>定义的又是<code>string</code>类型的话，就不会按预期显示，而是直接用传入的值。</p><p>于是现在封装一个组件<code>id-select</code>，解决上述问题。</p><h2 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h2><p>在<code>components</code>文件夹下新建一个id-select.tsx文件，首先写好组件基本内容。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import { Select } from "antd";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const IdSelect = () =&gt; {</span><br><span class="line">    return (</span><br><span class="line">        &lt;Select value={} onChange={}&gt;</span><br><span class="line">            &lt;Select.Option value={}&gt;{}&lt;/Select.Option&gt;</span><br><span class="line">        &lt;/Select&gt;</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们要封装一个<code>Select</code>组件，使得其</p><ul><li>value可以传入多种类型的值</li><li>onChange只会回调number | undefined类型</li><li>当 isNaN(Number(value))为true 代表选择默认类型</li><li>当选择默认类型，onChange回调undefined</li></ul><p>定义下组件所需的<code>props</code>类型:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IdSelectProps {</span><br><span class="line">  value: string | number | null | undefined;</span><br><span class="line">  onChange: (value?: number) =&gt; void;</span><br><span class="line">  defaultOptionName?: string;</span><br><span class="line">  options?: { name: string; id: number }[];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>定义一个辅助函数:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const toNumber = (value: unknown) =&gt; {</span><br><span class="line">  return isNaN(Number(value)) ? 0 : Number(value);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>完善组件:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export const IdSelect = (props: IdSelectProps) =&gt; {</span><br><span class="line">  const { value, onChange, defaultOptionName, options } = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Select</span><br><span class="line">      value={toNumber(value)}</span><br><span class="line">      onChange={(value) =&gt; onChange(toNumber(value) || undefined)}</span><br><span class="line">    &gt;</span><br><span class="line">      {defaultOptionName ? (</span><br><span class="line">        &lt;Select.Option value={0}&gt;{defaultOptionName}&lt;/Select.Option&gt;</span><br><span class="line">      ) : null}</span><br><span class="line">      {options?.map((option) =&gt; (</span><br><span class="line">        &lt;Select.Option value={option.id} key={option.id}&gt;</span><br><span class="line">          {option.name}</span><br><span class="line">        &lt;/Select.Option&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/Select&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>还有一个问题，如果我们需要用到<code>Select</code>本身的<code>props</code>呢，或者说我想改变<code>Select</code>本身的样式呢？</p><p>这就是一个<code>props</code>透传问题</p><p><code>React</code>中有专门的处理方法，将接口改为如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 继承Select组件本身的props</span><br><span class="line">type SelectProps = React.ComponentProps&lt;typeof Select&gt;;</span><br><span class="line"></span><br><span class="line">// 去掉我们接口中定义的，防止重名</span><br><span class="line">interface IdSelectProps</span><br><span class="line">  extends Omit&lt;</span><br><span class="line">    SelectProps,</span><br><span class="line">    "value" | "onChange" | "defaultOptionName" | "options"</span><br><span class="line">  &gt; {</span><br><span class="line">  value: string | number | null | undefined;</span><br><span class="line">  onChange: (value?: number) =&gt; void;</span><br><span class="line">  defaultOptionName?: string;</span><br><span class="line">  options?: { name: string; id: number }[];</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>然后传给里面的<code>Select</code>组件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export const IdSelect = (props: IdSelectProps) =&gt; {</span><br><span class="line">    // 用扩展操作符 ...rest取得props中剩余的属性</span><br><span class="line">  const { value, onChange, defaultOptionName, options, ...rest } = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Select</span><br><span class="line">      value={toNumber(value)}</span><br><span class="line">      onChange={(value) =&gt; onChange(toNumber(value) || undefined)}</span><br><span class="line">        // 传给Select</span><br><span class="line">      {...rest}</span><br><span class="line">    &gt;</span><br><span class="line">      {defaultOptionName ? (</span><br><span class="line">        &lt;Select.Option value={0}&gt;{defaultOptionName}&lt;/Select.Option&gt;</span><br><span class="line">      ) : null}</span><br><span class="line">      {options?.map((option) =&gt; (</span><br><span class="line">        &lt;Select.Option value={option.id} key={option.id}&gt;</span><br><span class="line">          {option.name}</span><br><span class="line">        &lt;/Select.Option&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/Select&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>完整代码:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import { Select } from "antd";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">type SelectProps = React.ComponentProps&lt;typeof Select&gt;;</span><br><span class="line"></span><br><span class="line">interface IdSelectProps</span><br><span class="line">  extends Omit&lt;</span><br><span class="line">    SelectProps,</span><br><span class="line">    "value" | "onChange" | "defaultOptionName" | "options"</span><br><span class="line">  &gt; {</span><br><span class="line">  value: string | number | null | undefined;</span><br><span class="line">  onChange: (value?: number) =&gt; void;</span><br><span class="line">  defaultOptionName?: string;</span><br><span class="line">  options?: { name: string; id: number }[];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * value 可以传入都多种类型的值</span><br><span class="line"> * onChange只会回调 number | undefined 类型</span><br><span class="line"> * 当 isNaN(Number(value))为true 代表选择默认类型</span><br><span class="line"> * 当选择默认类型，onChange回调undefined</span><br><span class="line"> */</span><br><span class="line">export const IdSelect = (props: IdSelectProps) =&gt; {</span><br><span class="line">  const { value, onChange, defaultOptionName, options, ...rest } = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Select</span><br><span class="line">      value={toNumber(value)}</span><br><span class="line">      onChange={(value) =&gt; onChange(toNumber(value) || undefined)}</span><br><span class="line">      {...rest}</span><br><span class="line">    &gt;</span><br><span class="line">      {defaultOptionName ? (</span><br><span class="line">        &lt;Select.Option value={0}&gt;{defaultOptionName}&lt;/Select.Option&gt;</span><br><span class="line">      ) : null}</span><br><span class="line">      {options?.map((option) =&gt; (</span><br><span class="line">        &lt;Select.Option value={option.id} key={option.id}&gt;</span><br><span class="line">          {option.name}</span><br><span class="line">        &lt;/Select.Option&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/Select&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">const toNumber = (value: unknown) =&gt; {</span><br><span class="line">  return isNaN(Number(value)) ? 0 : Number(value);</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>一个简单的组件就封装好了</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import { useUser } from "screens/project-list/user";</span><br><span class="line">import { IdSelect } from "./id-select";</span><br><span class="line"></span><br><span class="line">export const UserSelect = (props: React.ComponentProps&lt;typeof IdSelect&gt;) =&gt; {</span><br><span class="line">  const { users } = useUser();</span><br><span class="line">  return &lt;IdSelect options={users || []} {...props}&gt;&lt;/IdSelect&gt;;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-router</title>
      <link href="2021/05/14/React%E8%B7%AF%E7%94%B1/"/>
      <url>2021/05/14/React%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="react-router安装"><a href="#react-router安装" class="headerlink" title="react-router安装"></a>react-router安装</h2><p><code>yarn add react-router@6 react-router-dom@6</code></p><p><code>yarn add history</code></p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import { Route, Routes } from "react-router";</span><br><span class="line">import { BrowserRouter as Router } from "react-router-dom";</span><br><span class="line">import { ProjectScreen } from "screens/project";</span><br></pre></td></tr></tbody></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="example1"><a href="#example1" class="headerlink" title="example1"></a>example1</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Routes&gt;</span><br><span class="line">    &lt;Route</span><br><span class="line">      path={"/projects"}</span><br><span class="line">      element={&lt;ProjectListScreen&gt;&lt;/ProjectListScreen&gt;}</span><br><span class="line">    &gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route</span><br><span class="line">      path={"/projects/:projectsId/*"}</span><br><span class="line">      element={&lt;ProjectScreen&gt;&lt;/ProjectScreen&gt;}</span><br><span class="line">    &gt;&lt;/Route&gt;</span><br><span class="line">  &lt;/Routes&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></tbody></table></figure><p>在<code>ProjectListScreen</code>组件中:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import { Link } from "react-router-dom";</span><br><span class="line"></span><br><span class="line">   render: (value, project) =&gt; (</span><br><span class="line">            &lt;Link to={String(project.id)}&gt;{project.name}&lt;/Link&gt;</span><br><span class="line">          )</span><br><span class="line">// 注意，该组件以及在/projects路由下了，此时&lt;Link&gt;to跳转到的路由就是在/projects后面拼接，例如/projects/5</span><br></pre></td></tr></tbody></table></figure><h3 id="example2"><a href="#example2" class="headerlink" title="example2"></a>example2</h3><p>在<code>ProjectScreen</code>组件中:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import { Link } from "react-router-dom";</span><br><span class="line">import { Routes, Route } from "react-router";</span><br><span class="line">import { KanbanScreen } from "screens/kanban";</span><br><span class="line">import { EpicScreen } from "screens/epic";</span><br><span class="line"></span><br><span class="line">export const ProjectScreen = () =&gt; {</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;ProjectScreen&lt;/h1&gt;</span><br><span class="line">      // 注意，这里不是/kanban 如果是的话则代表直接跳到localhost/kanban</span><br><span class="line">      // 这里代表跳到 当前组件路由后面 localhost/projects/1/kanban</span><br><span class="line">      &lt;Link to={"kanban"}&gt;看板&lt;/Link&gt;</span><br><span class="line">      &lt;Link to={"epic"}&gt;epic&lt;/Link&gt;</span><br><span class="line">      &lt;Routes&gt;</span><br><span class="line">        &lt;Route path={"/kanban"} element={&lt;KanbanScreen&gt;&lt;/KanbanScreen&gt;}&gt;&lt;/Route&gt;</span><br><span class="line">        &lt;Route path={"/epic"} element={&lt;EpicScreen&gt;&lt;/EpicScreen&gt;}&gt;&lt;/Route&gt;</span><br><span class="line">          // 默认路由(上面两个匹配不到的话)</span><br><span class="line">         &lt;Navigate to={window.location.pathname + '/kanban'}&gt;&lt;/Navigate&gt;</span><br><span class="line">      &lt;/Routes&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="重置路由"><a href="#重置路由" class="headerlink" title="重置路由"></a>重置路由</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const resetRoute = () =&gt; (window.location.href = window.location.origin);</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript-as const应用</title>
      <link href="2021/05/14/TypeScript%E4%B9%8Bas%20const/"/>
      <url>2021/05/14/TypeScript%E4%B9%8Bas%20const/</url>
      
        <content type="html"><![CDATA[<h1 id="as-const"><a href="#as-const" class="headerlink" title="as const"></a>as const</h1><p>在项目中遇到了一个问题:</p><p><img src="images/artical-image/image-20210514184232090.png" alt="image-20210514184232090"></p><p>这个函数签名简直莫名奇妙</p><p>后来发现加上<code>as const</code></p><p><img src="images/artical-image/image-20210514184313551.png" alt="image-20210514184313551"></p><p>变得顺眼多了</p><p>那<code>as const</code>究竟是啥?</p><p>看一个例子:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a = ["jack", 1, { id: "5" }];</span><br></pre></td></tr></tbody></table></figure><p><img src="images/artical-image/image-20210514184447025.png" alt="image-20210514184447025"></p><p>a是一个元素为<code>string</code>或者<code>number</code>或者含有id对象的数组，这明显与我们的预期不符，因为我们想要一个元素为string | number | object的数组，主要原因是ts中的数组里面的类型必须一致，所以他会解析成上面那种情况。</p><p>如果我们加上<code>as const</code>呢?</p><p><img src="images/artical-image/image-20210514184705302.png" alt="image-20210514184705302"></p><p>a变成了一个数组，里面第一个元素是’jack’，第二个是1，第三个是对象</p><p><code>as const</code>主要用在数组中，在编写ts代码时，灵活运用<code>as const</code>能解决一些有趣的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css in Js-emotion</title>
      <link href="2021/05/10/Css%20in%20Js-emotion/"/>
      <url>2021/05/10/Css%20in%20Js-emotion/</url>
      
        <content type="html"><![CDATA[<h2 id="emotion的安装"><a href="#emotion的安装" class="headerlink" title="emotion的安装"></a>emotion的安装</h2><p><code>yarn add @emotion/react @emotion/styled</code></p><h2 id="emotion的基本使用"><a href="#emotion的基本使用" class="headerlink" title="emotion的基本使用"></a>emotion的基本使用</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import styled from "@emotion/styled"; // 引入emotion</span><br><span class="line">import logo from "assets/logo.svg"; // 引入图片</span><br><span class="line">import left from "assets/left.svg";</span><br><span class="line">import right from "assets/right.svg";</span><br><span class="line"></span><br><span class="line">export const UnauthenticatedApp = () =&gt; {</span><br><span class="line">  const [isRegister, setIsRegister] = useState(false);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &lt;Header&gt;&lt;/Header&gt;</span><br><span class="line">      &lt;ShadowCard&gt;</span><br><span class="line">        {isRegister ? (</span><br><span class="line">          &lt;RegisterScreen&gt;&lt;/RegisterScreen&gt;</span><br><span class="line">        ) : (</span><br><span class="line">          &lt;LoginScreen&gt;&lt;/LoginScreen&gt;</span><br><span class="line">        )}</span><br><span class="line">        &lt;Divider&gt;&lt;/Divider&gt;</span><br><span class="line">        &lt;a onClick={() =&gt; setIsRegister(!isRegister)}&gt;</span><br><span class="line">          切换到{isRegister ? "登录" : "注册"}</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/ShadowCard&gt;</span><br><span class="line">    &lt;/Container&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 每个style都是一个组件</span><br><span class="line">const Header = styled.header`</span><br><span class="line">  background: url(${logo}) no-repeat center;</span><br><span class="line">  padding: 5rem 0;</span><br><span class="line">  background-size: 8rem;</span><br><span class="line">  width: 100%;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const ShadowCard = styled(Card)`// 非html原生标签要用括号，比如组件库和React.component</span><br><span class="line">  width: 40rem;</span><br><span class="line">  min-height: 56rem;</span><br><span class="line">  padding: 3.2rem 4rem;</span><br><span class="line">  border-radius: 0.3rem;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  box-shadow: rgba(0, 0, 0, 0.1) 0 0 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 原生html</span><br><span class="line">const Container = styled.div`</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  justify-content: center;</span><br><span class="line">`;</span><br></pre></td></tr></tbody></table></figure><h2 id="emotion中使用grid和flex布局"><a href="#emotion中使用grid和flex布局" class="headerlink" title="emotion中使用grid和flex布局"></a>emotion中使用grid和flex布局</h2><p><code>grid</code>:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const Container = styled.div`</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-rows: 6rem 1fr 6rem;</span><br><span class="line">  grid-template-columns: 20rem 1fr 20rem;</span><br><span class="line">  grid-template-areas: "header header header" "nav main aside" "footer footer footer"</span><br><span class="line"></span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 这里value没有引号</span><br><span class="line">const Header = styled.header`</span><br><span class="line">  grid-area: header; </span><br><span class="line">`;</span><br><span class="line">const Nav = styled.nav`</span><br><span class="line">  grid-area: nav;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Main = styled.main`</span><br><span class="line">  grid-area: main;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Aside = styled.aside`</span><br><span class="line">  grid-area: aside;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Footer = styled.footer`</span><br><span class="line">  grid-area: footer;</span><br><span class="line">`;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>flex</code>:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Header = styled.header`</span><br><span class="line">  grid-area: header;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-flow: row nowrap;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  align-items: center;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const HeaderLeft = styled.div`</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-flow: row nowrap;</span><br><span class="line">`;</span><br></pre></td></tr></tbody></table></figure><p><code>flex和grid使用场景?</code></p><ul><li>1维布局用flex，二维布局用grid。</li><li>从内容出发：先有一组内容（数量一般不固定），希望他们均匀分布在容器中，由内容的大小决定占据的空间–flex。</li><li>从布局触发：先规划网格（数量一般固定），然后再把元素往里填充。–grid</li></ul><h2 id="用emotion封装一个flex布局"><a href="#用emotion封装一个flex布局" class="headerlink" title="用emotion封装一个flex布局"></a>用emotion封装一个flex布局</h2><p><code>style.component</code>创建出来的是是一个<code>React.component</code>对象，那么当然可以接受参数（毕竟组件实质上也只是一个函数），将<code>style</code>写成一个组件的形式，听起来很厉害</p><p>在src下的componets文件里新建一个<code>lib.tsx</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">"@emotion/styled"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了一个flex布局，接受三个参数(between, gap, marginBottom)</span></span><br><span class="line"><span class="comment">// 参数的样子是不是很像接口?</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Row = styled.div&lt;{</span><br><span class="line">  between?: <span class="built_in">boolean</span>;</span><br><span class="line">  gap?: <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">  marginBottom?: <span class="built_in">number</span>;</span><br><span class="line">}&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  flex-flow: row nowrap;</span></span><br><span class="line"><span class="string">  align-items: center;</span></span><br><span class="line"><span class="string">  justify-content: <span class="subst">${(props) =&gt; (props.between ? <span class="string">"space-between"</span> : <span class="literal">undefined</span>)}</span>;</span></span><br><span class="line"><span class="string">  margin-bottom: <span class="subst">${(props) =&gt; props.marginBottom + <span class="string">"rem"</span>}</span>;</span></span><br><span class="line"><span class="string">  &gt; * { // 这里代表所有子元素</span></span><br><span class="line"><span class="string">    margin-top: 0 !important;</span></span><br><span class="line"><span class="string">    margin-bottom: 0 !important;</span></span><br><span class="line"><span class="string">    margin-right: <span class="subst">${(props) =&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">      <span class="keyword">typeof</span> props.gap === <span class="string">"number"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        ? props.gap + <span class="string">"rem"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        : props.gap</span></span></span><br><span class="line"><span class="string"><span class="subst">        ? <span class="string">"2rem"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        : <span class="literal">undefined</span>}</span>;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在项目中引用并使用:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import { Row } from "components/lib";</span><br><span class="line"></span><br><span class="line">const Header = styled(Row)``;</span><br><span class="line"></span><br><span class="line">const HeaderLeft = styled(Row)``;</span><br><span class="line"></span><br><span class="line">     &lt;Header between={true}&gt; // 在这里传递参数，是不是很像组件!</span><br><span class="line">        &lt;HeaderLeft gap={true}&gt;</span><br><span class="line">          &lt;h3&gt;logo&lt;/h3&gt;</span><br><span class="line">          &lt;h3&gt;我的&lt;/h3&gt;</span><br><span class="line">          &lt;h3&gt;项目&lt;/h3&gt;</span><br><span class="line">        &lt;/HeaderLeft&gt;</span><br><span class="line">        &lt;HeaderRight&gt;</span><br><span class="line">          &lt;button onClick={() =&gt; logout()}&gt;登出&lt;/button&gt;</span><br><span class="line">        &lt;/HeaderRight&gt;</span><br><span class="line">      &lt;/Header&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="emotion在行内样式中使用"><a href="#emotion在行内样式中使用" class="headerlink" title="emotion在行内样式中使用"></a>emotion在行内样式中使用</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** @jsxRuntime classic */</span><br><span class="line">/** @jsx jsx */</span><br><span class="line">// 第一行表示使用旧版传统模式手动导入运行时</span><br><span class="line">// 第二行表示指明下一行为运行时的导入</span><br><span class="line"></span><br><span class="line">&lt;Form css={{ marginBottom: "2rem" }} layout={"inline"}&gt;</span><br></pre></td></tr></tbody></table></figure><p>不是很推荐使用 css props ，可以选择使用外链 css 文件或 <code>@emotion/styled</code> 的 <em>styled-components</em> 方案，都是很不错的选择。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React中的图片</title>
      <link href="2021/05/10/React%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87/"/>
      <url>2021/05/10/React%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="React中图片使用方法"><a href="#React中图片使用方法" class="headerlink" title="React中图片使用方法"></a>React中图片使用方法</h1><h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import softwareLogo from 'assets/software-logo.svg'</span><br><span class="line"></span><br><span class="line">&lt;img src={softwareLogo} alt="" /&gt;</span><br></pre></td></tr></tbody></table></figure><p>优点是使用方便，但不好规定样式和图片大小</p><h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import { ReactComponent as SoftwareLogo } from "assets/software-logo.svg";</span><br><span class="line">// 将图片作为一个组件引入</span><br><span class="line">&lt;SoftwareLogo width={'18rem'} color={'rgb(38, 132, 255)'}&gt;&lt;/SoftwareLogo&gt;</span><br></pre></td></tr></tbody></table></figure><p>轻易的就能改变样式</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript如何合理处理对象</title>
      <link href="2021/05/10/TypeScript%E8%BF%9B%E9%98%B6-%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/05/10/TypeScript%E8%BF%9B%E9%98%B6-%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript中的object出现的错误"><a href="#TypeScript中的object出现的错误" class="headerlink" title="TypeScript中的object出现的错误"></a>TypeScript中的object出现的错误</h2><p><code>object</code>是个很基础也很常见的引用类型，比如我用<code>typescript</code>定义一个<code>object</code>类型的变量</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">object</span>;</span><br></pre></td></tr></tbody></table></figure><p>乍一看没什么问题，但却_暗藏玄机_</p><p>比如我现在想定义一个函数，它能判断对象哪些属性是<code>number</code>类型，然后返回一个由这些属性组成的新的对象:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNumber = <span class="function">(<span class="params"><span class="built_in">object</span>: <span class="built_in">object</span></span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 在一个函数里，改变传入的对象本身是不好的</span></span><br><span class="line">    <span class="keyword">const</span> result = { ...object }</span><br><span class="line">    <span class="built_in">Object</span>.keys(result).forEach(<span class="function"><span class="params">key</span> =&gt;</span> {</span><br><span class="line">        <span class="keyword">const</span> value = result[key];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">'number'</span>) {</span><br><span class="line">            <span class="keyword">delete</span> result[key];</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样看上去没什么问题，但是编译器会报错：</p><p><img src="images/artical-image/image-20210510173337280.png" alt="image-20210510173337280"></p><p>上面提示不能用<code>key</code>作为<code>{}</code>类型的索引，但result为什么是<code>{}</code>类型呢？它为什么是个空对象呢?</p><p>这就是<code>object</code>类型的弊端，它覆盖的范围太广，几乎除了原始类型外的所有类型都是由它而衍生的，原型链的终点都有它</p><p>看下面一段代码就明白了：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">object</span>;</span><br><span class="line">a = {<span class="attr">name</span>: <span class="string">'jack'</span>}</span><br><span class="line">a = <span class="function">() =&gt;</span> {}</span><br><span class="line">a = []</span><br></pre></td></tr></tbody></table></figure><p>在这三种情况下，ts都没有报错</p><p>于是上面的问题就找到原因了，_js引擎_并不知道这个result具体是个字面量对象，还是函数或者说是索引类型，所以它非常人性化的给你返回了<code>{}</code>，而<code>key</code>当作<code>{}</code>的索引就报错了。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>通过 <strong>keyof</strong> 的方式可以获取ts 类型的属性key的值</p><p>适用与非<strong>函数</strong>场景</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = {</span><br><span class="line">    a: <span class="string">'1'</span>,</span><br><span class="line">    b: <span class="string">'2'</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 这里typeof foo =&gt; foo的类型 等同于 interface Foo { a: string; b: string; }// typeof foo === Foo，这里只所以用 typeof foo，因为这样方便，对于不想写interface的直接量对象很容易获取它的类型// keyof typeof foo这里只获取 Foo的类型的key值，注意这个keyof后面一定是 typescript的类型</span></span><br><span class="line"><span class="keyword">type</span> FooType = keyof <span class="keyword">typeof</span> foo; <span class="keyword">var</span> getPropertyValue = <span class="built_in">Object</span>.keys(foo).map(<span class="function"><span class="params">item</span> =&gt;</span> foo[item <span class="keyword">as</span> FooType])</span><br></pre></td></tr></tbody></table></figure><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>将参数类型改为_key-value_对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> isNumber = <span class="function">(<span class="params"><span class="built_in">object</span>: {[key: <span class="built_in">string</span>]: unknown}</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 在一个函数里，改变传入的对象本身是不好的</span></span><br><span class="line">  <span class="keyword">const</span> result = { ...object }</span><br><span class="line">  <span class="built_in">Object</span>.keys(result).forEach(<span class="function"><span class="params">key</span> =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> value = result[key];</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">'number'</span>) {</span><br><span class="line">          <span class="keyword">delete</span> result[key];</span><br><span class="line">      }</span><br><span class="line">  })</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript进阶之封装axios</title>
      <link href="2021/05/09/TypeScript%E8%BF%9B%E9%98%B6-%E5%B0%81%E8%A3%85axios/"/>
      <url>2021/05/09/TypeScript%E8%BF%9B%E9%98%B6-%E5%B0%81%E8%A3%85axios/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript对axios的封装"><a href="#TypeScript对axios的封装" class="headerlink" title="TypeScript对axios的封装"></a>TypeScript对axios的封装</h1><p>项目中用到了<code>typescript</code>和<code>axios</code>，对<code>axios</code>进行封装:</p><p><code>request.js</code>：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入axios模块 用{}引入的表示类型</span></span><br><span class="line"><span class="keyword">import</span> axios, {</span><br><span class="line">  AxiosInstance, <span class="comment">// axios实例</span></span><br><span class="line">  AxiosRequestConfig, <span class="comment">//axios请求config</span></span><br><span class="line">  AxiosPromise, <span class="comment">// axios返回的类型</span></span><br><span class="line">  AxiosResponse, <span class="comment">// axios返回的数据</span></span><br><span class="line">} <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="keyword">const</span> apiBaseUrl = process.env.REACT_APP_API_URL;</span><br></pre></td></tr></tbody></table></figure><p>根据服务端返回的数据格式对返回数据进行约束:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ResponseData&lt;T = any&gt; {</span><br><span class="line">    data?: T,</span><br><span class="line">    code?: <span class="built_in">number</span>,</span><br><span class="line">    msg?: <span class="built_in">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>创建<code>HttpRequest</code>类:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>{</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> baseUrl: <span class="built_in">string</span> | <span class="literal">undefined</span> = apiBaseUrl,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> timeout: <span class="built_in">number</span> = <span class="number">5000</span></span></span><br><span class="line"><span class="params">  </span>) {</span><br><span class="line">    <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> request(options: AxiosRequestConfig): AxiosPromise {</span><br><span class="line">    <span class="keyword">const</span> instance: AxiosInstance = axios.create(); <span class="comment">// 创建实例</span></span><br><span class="line">    options = <span class="built_in">this</span>.mergeConfig(options); <span class="comment">// 合并基础路径和每个接口单独传入的配置，比如url、参数等</span></span><br><span class="line">    <span class="built_in">this</span>.interceptors(instance, options.url); <span class="comment">// 调用interceptors方法使拦截器生效</span></span><br><span class="line">    <span class="keyword">return</span> instance(options);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">interceptors</span>(<span class="params">instance: AxiosInstance, url?: <span class="built_in">string</span></span>)</span> {</span><br><span class="line">    <span class="comment">// 在这里添加请求和响应拦截</span></span><br><span class="line">    instance.interceptors.request.use(</span><br><span class="line">      (config: AxiosRequestConfig) =&gt; {</span><br><span class="line">        <span class="comment">// 接口请求的所有配置，都在这个config对象中，他的类型是AxiosRequestConfig，你可以看到他有哪些字段</span></span><br><span class="line">        <span class="comment">// 如果你要修改接口请求配置，需要修改 axios.defaults 上的字段值</span></span><br><span class="line">        <span class="keyword">let</span> token = auth.getToken();</span><br><span class="line">        <span class="keyword">if</span> (token) {</span><br><span class="line">          config.headers[<span class="string">"Authorization"</span>] = <span class="string">`Bearer <span class="subst">${token}</span>`</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">      },</span><br><span class="line">      (error) =&gt; {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">      }</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    instance.interceptors.response.use(</span><br><span class="line">      <span class="keyword">async</span> (res: AxiosResponse) =&gt; {</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> { data } = res; <span class="comment">// res的类型是AxiosResponse&lt;any&gt;，包含六个字段，其中data是服务端返回的数据</span></span><br><span class="line">        <span class="keyword">const</span> { code, msg } = data; <span class="comment">// 通常服务端会将响应状态码、提示信息、数据等放到返回的数据中</span></span><br><span class="line">        <span class="keyword">if</span> (code === <span class="number">401</span>) {</span><br><span class="line">          <span class="keyword">await</span> auth.logout();</span><br><span class="line">          <span class="built_in">window</span>.location.reload();</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.reject({ <span class="attr">message</span>: <span class="string">"请重新登录"</span> });</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">      (error) =&gt; {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">      }</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> mergeConfig(options: AxiosRequestConfig): AxiosRequestConfig {</span><br><span class="line">    <span class="comment">// 这个方法用于合并基础路径配置和接口单独配置</span></span><br><span class="line">    <span class="keyword">return</span> { ...options, <span class="attr">baseURL</span>: <span class="built_in">this</span>.baseUrl, <span class="attr">timeout</span>: <span class="built_in">this</span>.timeout };</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HttpRequest;</span><br></pre></td></tr></tbody></table></figure><p>在<code>api</code>目录下新建一个<code>index.ts</code>文件:</p><p><code>index.ts</code>:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HttpRequest <span class="keyword">from</span> <span class="string">'utils/request'</span>; <span class="comment">// 引入HttpRequest类</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'utils/request'</span> <span class="comment">// 导出request文件中的内容</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> HttpRequest() <span class="comment">// 导出HttpRequest实例</span></span><br></pre></td></tr></tbody></table></figure><p>然后就能在<code>api</code>目录中写请求接口了，例如<code>auth.ts</code>:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http, { ResponseData } <span class="keyword">from</span> <span class="string">"./index"</span>;</span><br><span class="line"><span class="keyword">import</span> { User } <span class="keyword">from</span> <span class="string">'utils/type'</span>;</span><br><span class="line"><span class="keyword">import</span> { AxiosPromise } <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求携带参数</span></span><br><span class="line"><span class="keyword">interface</span> LoginInformation {</span><br><span class="line">  username: <span class="built_in">string</span>;</span><br><span class="line">  password: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数据</span></span><br><span class="line"><span class="keyword">interface</span> Response <span class="keyword">extends</span> User {</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> userLogin = (</span><br><span class="line">  data: LoginInformation <span class="comment">// 这是请求数据</span></span><br><span class="line">): AxiosPromise&lt;ResponseData&lt;Response&gt;&gt;<span class="comment">// 这是返回数据</span></span><br><span class="line">    =&gt; {</span><br><span class="line">  <span class="keyword">return</span> http.request({</span><br><span class="line">    url: <span class="string">`/login`</span>,</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    headers: {</span><br><span class="line">      <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">    },</span><br><span class="line">    data: data,</span><br><span class="line">  });</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> userRegister = (</span><br><span class="line">  data: LoginInformation</span><br><span class="line">): AxiosPromise&lt;ResponseData&gt; =&gt; {</span><br><span class="line">  <span class="keyword">return</span> http.request({</span><br><span class="line">    url: <span class="string">`/register`</span>,</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    headers: {</span><br><span class="line">      <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">    },</span><br><span class="line">    data: data,</span><br><span class="line">  });</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>调用<code>api</code>:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function">(<span class="params">data: { username: <span class="built_in">string</span>; password: <span class="built_in">string</span> | <span class="built_in">number</span>}</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> userLogin(data)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> data = res.data.user;</span><br><span class="line">      <span class="keyword">return</span> handleUserResponse(data);</span><br><span class="line">    })</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">Promise</span>.reject(error));</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这样就能用<code>typescript</code>对请求的数据和返回的数据进行约束，同时对axios也进行了一次封装。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript进阶之utility types</title>
      <link href="2021/05/07/TypeScript%E8%BF%9B%E9%98%B6-utility%20types/"/>
      <url>2021/05/07/TypeScript%E8%BF%9B%E9%98%B6-utility%20types/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-utility-types"><a href="#TypeScript-utility-types" class="headerlink" title="TypeScript utility types"></a>TypeScript utility types</h1><p>下面列举了一些项目中常用的typescript工具</p><h2 id="1、Partial"><a href="#1、Partial" class="headerlink" title="1、Partial"></a>1、Partial</h2><p>构造一个所有属性都Type设置为optional的类型。该实用程序将返回一个表示给定类型的所有子集的类型，所以所有属性都会加上一个undefined</p><h3 id="example"><a href="#example" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Partial&lt;User&gt; = {<span class="attr">id</span>: <span class="string">'1'</span>}</span><br><span class="line"><span class="keyword">let</span> part: Partial&lt;User&gt; = {<span class="attr">id</span>: <span class="literal">undefined</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="2、Required"><a href="#2、Required" class="headerlink" title="2、Required"></a>2、Required</h2><p>构造一个类型，该类型由Typeset的所有属性设置为required</p><h3 id="example-1"><a href="#example-1" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Required&lt;User&gt; = {<span class="attr">id</span>: <span class="string">'1'</span>}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210507203315789.png" alt="image-20210507203315789"></p><h2 id="3、Readonly"><a href="#3、Readonly" class="headerlink" title="3、Readonly"></a>3、Readonly</h2><p>构造一个所有属性都Type设置为的类型readonly，这意味着无法重新分配所构造类型的属性。</p><h2 id="example-2"><a href="#example-2" class="headerlink" title="# example:"></a># example:</h2><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Readonly&lt;User&gt; = {<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">name</span>: <span class="string">'xiaoming'</span>, <span class="attr">token</span>: <span class="string">'abc'</span>}</span><br><span class="line">part.name = <span class="string">'xiaoli'</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210507203606006.png" alt="image-20210507203606006"></p><h2 id="4、Record-lt-Keys-Type-gt"><a href="#4、Record-lt-Keys-Type-gt" class="headerlink" title="4、Record<Keys,Type>"></a>4、Record&lt;Keys,Type&gt;</h2><p>构造一个对象类型，其属性键为Keys，属性值为Type。该实用程序可用于<strong>将一个类型的属性映射到另一个类型。</strong></p><h3 id="example-3"><a href="#example-3" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Record&lt;<span class="string">'keys'</span>, User&gt; = {<span class="attr">keys</span>: {<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">name</span>: <span class="string">'xiaoli'</span>, <span class="attr">token</span>: <span class="string">'a'</span>}}</span><br></pre></td></tr></tbody></table></figure><h2 id="5、Pick-lt-Type-Keys-gt"><a href="#5、Pick-lt-Type-Keys-gt" class="headerlink" title="5、Pick<Type, Keys>"></a>5、Pick&lt;Type, Keys&gt;</h2><p>通过Keys从中选择一组属性（字符串文字或字符串文字并集）来构造类型Type。</p><h3 id="example-4"><a href="#example-4" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Pick&lt;User, <span class="string">'id'</span> &amp; <span class="string">'token'</span>&gt; = {<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">token</span>: <span class="string">'abc'</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="6、Omit-lt-Type-Keys-gt"><a href="#6、Omit-lt-Type-Keys-gt" class="headerlink" title="6、Omit<Type, Keys>"></a>6、Omit&lt;Type, Keys&gt;</h2><p>通过从中选择所有属性Type然后删除Keys（字符串文字或字符串文字的并集）来构造类型。</p><h3 id="example-5"><a href="#example-5" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Omit&lt;User, <span class="string">'id'</span>&gt; = {<span class="attr">name</span>: <span class="string">'xiaoming'</span>, <span class="attr">token</span>: <span class="string">'abc'</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="7、Parameters"><a href="#7、Parameters" class="headerlink" title="7、Parameters"></a>7、Parameters</h2><p>从函数类型的参数中使用的类型构造一个<strong>元组类型Type。</strong></p><h3 id="example-6"><a href="#example-6" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">str: <span class="built_in">string</span>, num: <span class="built_in">number</span></span>) =&gt;</span> {};</span><br><span class="line"><span class="keyword">let</span> params: Parameters&lt;<span class="keyword">typeof</span> fn&gt; = [<span class="string">"str"</span>, <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure><h2 id="8、ReturnType"><a href="#8、ReturnType" class="headerlink" title="8、ReturnType"></a>8、ReturnType</h2><p>构造一个由函数的返回类型组成的<strong>类型Type。</strong></p><h3 id="example-7"><a href="#example-7" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">str: <span class="built_in">string</span>, num: <span class="built_in">number</span></span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> { str, num };</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> params: ReturnType&lt;<span class="keyword">typeof</span> fn&gt; = {<span class="attr">str</span>: <span class="string">'a'</span>, <span class="attr">num</span>: <span class="number">1</span>}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript进阶之泛型</title>
      <link href="2021/05/02/TypeScript%E8%BF%9B%E9%98%B6-%E6%B3%9B%E5%9E%8B/"/>
      <url>2021/05/02/TypeScript%E8%BF%9B%E9%98%B6-%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript-泛型"><a href="#TypeScript-泛型" class="headerlink" title="TypeScript 泛型"></a>TypeScript 泛型</h2><p><strong>通俗来讲</strong>：泛型是指在定义函数、接口或者类时，未指定其参数类型，只有在运行时传入才能确定。那么此时的参数类型就是一个变量，通常用大写字母 <code>T</code> 来表示，当然你也可以使用其他字符，如：<code>U</code>、<code>K</code>等。</p><p><strong>语法</strong>：在函数名、接口名或者类名添加后缀 <code>&lt;T&gt;</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generic</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) </span>{}</span><br><span class="line"><span class="keyword">interface</span> Generic&lt;T&gt; {}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>{}</span><br></pre></td></tr></tbody></table></figure><h3 id="初识泛型"><a href="#初识泛型" class="headerlink" title="初识泛型"></a>初识泛型</h3><p><strong>之所以使用泛型，是因为它帮助我们为不同类型的输入，复用相同的代码。</strong></p><p>比如写一个最简单的函数，这个函数会返回任何传入它的值。如果传入的是 number 类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果传入的是 string 类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过泛型，可以把两个函数统一起来：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，泛型函数的返回值类型是根据你的业务需求决定，并非一定要返回泛型类型 T：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(arg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 入参的类型是未知的，但是通过 String 转换，返回字符串类型。</p><h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><p>泛型函数可以定义多个类型参数：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> second) {</span><br><span class="line">    (first <span class="keyword">as</span> T &amp; U)[key] = second[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> first <span class="keyword">as</span> T &amp; U</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 这个函数用来合并两个对象，具体实现暂且不去管它，这里只需要关注泛型多个类型参数的使用方式，**其语法为通过逗号分隔 <code>&lt;T, U, K&gt;</code>**。</p><h3 id="泛型参数默认类型"><a href="#泛型参数默认类型" class="headerlink" title="泛型参数默认类型"></a>泛型参数默认类型</h3><p>函数参数可以定义默认值，泛型参数同样可以定义默认类型：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>&lt;<span class="title">T</span> = <span class="title">number</span>&gt;(<span class="params">arr:T[]</span>): <span class="title">T</span></span>{</span><br><span class="line">  <span class="keyword">let</span> min = arr[<span class="number">0</span>]</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">value</span>)=&gt;</span>{</span><br><span class="line">     <span class="keyword">if</span>(value &lt; min) {</span><br><span class="line">         min = value</span><br><span class="line">     }</span><br><span class="line">  })</span><br><span class="line">   <span class="keyword">return</span> min</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(min([<span class="number">20</span>, <span class="number">6</span>, <span class="number">8n</span>])) <span class="comment">// 6</span></span><br></pre></td></tr></tbody></table></figure><p><strong>解释：</strong> 同样的不用去关注这个最小数函数的具体实现，要知道**默认参数语法为 <code>&lt;T = 默认类型&gt;</code>**。</p><h3 id="泛型类型与泛型接口"><a href="#泛型类型与泛型接口" class="headerlink" title="泛型类型与泛型接口"></a>泛型类型与泛型接口</h3><p>先来回顾下之前章节介绍的函数类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (x + y).toString()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>等号左侧的 <code>(x: number, y: number) =&gt; string</code> 为函数类型。</p><p>再看下泛型类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity</span><br></pre></td></tr></tbody></table></figure><p>同样的等号左侧的 <code>&lt;T&gt;(arg: T) =&gt; T</code> 即为泛型类型，它还有另一种<em>带有调用签名的对象字面量</em>书写方式：<code>{ &lt;T&gt;(arg: T): T }</code>:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: { &lt;T&gt;(arg: T): T } = identity</span><br></pre></td></tr></tbody></table></figure><p>这就引导我们去写第一个泛型接口了。把上面例子里的对象字面量拿出来作为一个接口：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn {</span><br><span class="line">  &lt;T&gt;(arg: T): T</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn = identity</span><br></pre></td></tr></tbody></table></figure><p>进一步，把泛型参数当作整个接口的一个参数，我们可以把泛型参数提前到接口名上。这样我们就能清楚的知道使用的具体是哪个泛型类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; {</span><br><span class="line">  (arg: T): T</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity</span><br></pre></td></tr></tbody></table></figure><p>注意，在使用泛型接口时，需要传入一个类型参数来指定泛型类型。示例中传入了 number 类型，这就锁定了之后代码里使用的类型。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>始终要记得，<strong>使用泛型是因为可以复用不同类型的代码</strong>。下面用一个最小堆算法举例说明泛型类的使用：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> list: <span class="built_in">number</span>[] = []</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">num: <span class="built_in">number</span></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.list.push(num)</span><br><span class="line">  }</span><br><span class="line">  min(): <span class="built_in">number</span> {</span><br><span class="line">    <span class="keyword">let</span> minNum = <span class="built_in">this</span>.list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.list.length; i++) {</span><br><span class="line">      <span class="keyword">if</span> (minNum &gt; <span class="built_in">this</span>.list[i]) {</span><br><span class="line">        minNum = <span class="built_in">this</span>.list[i]</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minNum</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 示例中我们实现了一个查找 number 类型的最小堆类，但我们的最小堆还需要支持字符串类型，此时就需要泛型的帮助了：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名后加上 &lt;T&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">  <span class="keyword">public</span> list: T[] = []</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">num: T</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.list.push(num)</span><br><span class="line">  }</span><br><span class="line">  min(): T {</span><br><span class="line">    <span class="keyword">let</span> minNum = <span class="built_in">this</span>.list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.list.length; i++) {</span><br><span class="line">      <span class="keyword">if</span> (minNum &gt; <span class="built_in">this</span>.list[i]) {</span><br><span class="line">        minNum = <span class="built_in">this</span>.list[i]</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minNum</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> MinClass&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">m.add(<span class="string">'hello'</span>)</span><br><span class="line">m.add(<span class="string">'world'</span>)</span><br><span class="line">m.add(<span class="string">'generic'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(m.min()) <span class="comment">// generic</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，在声明 <code>类 MinClass</code> 的后面后加上了 <code>&lt;T&gt;</code>，这样就声明了泛型参数 T，作为一个变量可以是字符串类型，也可以是数字类型。</p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p><strong>语法：通过 <code>extends</code> 关键字来实现泛型约束。</strong></p><p>如果我们很明确传入的泛型参数是什么类型，或者明确想要操作的某类型的值具有什么属性，那么就需要对泛型进行约束。通过两个例子来说明：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User {</span><br><span class="line">  username: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">User</span>&gt;(<span class="params">user: T</span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'imooc '</span> + user.username</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 示例中，第 5 行，我们约束了入参 user 必须包含 username 属性，否则在编译阶段就会报错。</p><p>下面再看另外一个例子：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Args = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Args</span>&gt; </span>{}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MinClass&lt;<span class="built_in">boolean</span>&gt;() <span class="comment">// Error, 必须是 number | string 类型</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 3 行，约束了泛型参数 T 继承自类型 Args，而类型 Args 是一个由 number 和 string 组成的联合类型。</p><p>第 5 行，泛型参数只能是 number 和 string 中的一种，传入 boolean 类型是错误的。</p><h3 id="多重类型泛型约束"><a href="#多重类型泛型约束" class="headerlink" title="多重类型泛型约束"></a>多重类型泛型约束</h3><p>通过 <code>&lt;T extends Interface1 &amp; Interface2&gt;</code> 这种语法来实现多重类型的泛型约束：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Sentence {</span><br><span class="line">  title: <span class="built_in">string</span>,</span><br><span class="line">  content: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Music {</span><br><span class="line">  url: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Sentence</span> &amp; <span class="title">Music</span>&gt; </span>{</span><br><span class="line">  <span class="keyword">private</span> prop: T</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">arg: T</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.prop = arg</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">info</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      url: <span class="built_in">this</span>.prop.url,</span><br><span class="line">      title: <span class="built_in">this</span>.prop.title,</span><br><span class="line">      content: <span class="built_in">this</span>.prop.content</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 10 行，约束了泛型参数 <code>T</code> 需继承自交叉类型（后续有单节介绍） <code>Sentence &amp; Music</code>，这样就能访问两个接口类型的参数。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue父组件传递props异步数据到子组件遇到的问题</title>
      <link href="2021/04/27/vue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92props%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
      <url>2021/04/27/vue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92props%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="vue父组件传递props异步数据到子组件遇到的问题"><a href="#vue父组件传递props异步数据到子组件遇到的问题" class="headerlink" title="vue父组件传递props异步数据到子组件遇到的问题"></a>vue父组件传递props异步数据到子组件遇到的问题</h1><p>父组件<code>parent.vue</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// asyncData为异步获取的数据，想传递给子组件使用</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  父组件</span><br><span class="line">  &lt;child :child-data="asyncData"&gt;&lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import child from '../demo/children.vue'</span><br><span class="line"> export default {</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">   asyncData: ''</span><br><span class="line">  }),</span><br><span class="line">  components: {</span><br><span class="line">   child</span><br><span class="line">  },</span><br><span class="line">  created () {</span><br><span class="line">  },</span><br><span class="line">  mounted () {</span><br><span class="line">   // setTimeout模拟异步数据</span><br><span class="line">   setTimeout(() =&gt; {</span><br><span class="line">    this.asyncData = ' async data'</span><br><span class="line">    console.log('parent 组件结束')</span><br><span class="line">   }, 2000)</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h2><p>子组件<code>child.vue</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件{{childData}}</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childData'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">   console.log("子组件created-----   "+this.childData) // 空值</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>在这种情况下，子组件中<code>html</code>中的<code>{{childData}}</code>值会随着父组件传过来的值而改变，这是<strong>数据的响应式变化</strong>（数据的改变会引起界面变化)，但子组件<code>created</code>函数中是<strong>拿不到父组件异步传过来的数据</strong>的，这是生命周期问题。</p><h2 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h2><p>子组件<code>child.vue</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件&lt;!--这里很常见的一个问题，就是childData可以获取且没有报错，但是childData.items[0]不行，往往有个疑问为什么前面获取到值，后面获取不到呢？--&gt;</span><br><span class="line">  &lt;p&gt;{{childData.items[0]}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childData'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">   console.log(this.childData) // 空值</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><code>created</code>里面的仍然是空值， 子组件的<code>html</code>中的<code>{{childObject.items[0]}}</code>的值虽然会随着父组件的值而改变，但是过程中会报错。</p><p>是因为：<strong>首先传过来的是空，然后再异步刷新值</strong>，也就是开始时候<code>childObject.items[0]</code>等同于<code>''.item[0]</code>这样的操作，<br> 所以就会报下面的错：</p><p><img src="/images/artical-image/9441048-d1a7779ec4be1599" alt="img"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p>使用<code>v-if</code>可以解决报错问题和<code>created</code>为空问题</p><p>父组件<code>parent</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  父组件</span><br><span class="line">  &lt;child :child-object="asyncObject"  v-if="flag"&gt;&lt;/child&gt;</span><br><span class="line">  &lt;!--没拿到数据前，不渲染子组件，这样子组件created生命周期就能拿到数据了--&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from '../demo1/children.vue'</span><br><span class="line"> export default {</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">   asyncObject: '',</span><br><span class="line">   flag:false</span><br><span class="line">  }),</span><br><span class="line">  components: {</span><br><span class="line">   child</span><br><span class="line">  },</span><br><span class="line">  created () {</span><br><span class="line">  },</span><br><span class="line">  mounted () {</span><br><span class="line">   // setTimeout模拟异步数据</span><br><span class="line">   setTimeout(() =&gt; {</span><br><span class="line">    this.asyncObject = {'items': [1, 2, 3]}</span><br><span class="line">    this.flag= true</span><br><span class="line">    console.log('parent 结束')</span><br><span class="line">   }, 2000)</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>子页面 children</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件</span><br><span class="line">  &lt;p&gt;{{childObject.items[0]}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childObject'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">    console.log("子组件create-----"+JSON.stringify(this.childObject)) //能拿到了</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><img src="../images/artical-image/9441048-47f9515b58d48759" alt="img"></p></li><li><p>子组件使用<code>watch</code>来监听父组件改变的<code>prop</code>，使用<code>methods</code>来代替<code>created</code></p><p>子组件 children</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  &lt;p&gt;{{test}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childObject'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">       test: ''</span><br><span class="line">  }),</span><br><span class="line">   watch: {</span><br><span class="line">     'childObject.items': function (new, old) { // 直接监听childObject.item属性</span><br><span class="line">      this.test = new[0]</span><br><span class="line">      this.updata()</span><br><span class="line">     }</span><br><span class="line">    },</span><br><span class="line">  methods: {</span><br><span class="line">     updata () { // 既然created只会执行一次，但是又想监听改变的值做其他事情的话，只能搬到这里咯</span><br><span class="line">      console.log(this.test)// 1</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>子组件<code>watch computed data</code> 相结合(麻烦，不推荐)</p><p>子组件children</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   &lt;p&gt;{{test}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">    props: ['childObject'],</span><br><span class="line">    data: () =&gt; ({</span><br><span class="line">     test: ''</span><br><span class="line">    }),</span><br><span class="line">    watch: {</span><br><span class="line">     'childObject.items': function (n, o) {</span><br><span class="line">      this._test = n[0]</span><br><span class="line">     }</span><br><span class="line">    },</span><br><span class="line"> computed: {</span><br><span class="line">    _test: {</span><br><span class="line">     set (value) {</span><br><span class="line">      this.update()</span><br><span class="line">      this.test = value</span><br><span class="line">     },</span><br><span class="line">     get () {</span><br><span class="line">      return this.test</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   },</span><br><span class="line">  methods: {</span><br><span class="line">   update () {</span><br><span class="line">      console.log(this.childObject) // {items: [1,2,3]}</span><br><span class="line">     }</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用<code>prop default</code>来解决<code>{{childObject.items[0]}}</code></p><p>父组件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  父组件</span><br><span class="line">  &lt;child :child-object="asyncObject"&gt;&lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import child from  '../demo4/children.vue'</span><br><span class="line"> export default {</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">   asyncObject: undefined // 这里使用null反而报0的错</span><br><span class="line">  }),</span><br><span class="line">  components: {</span><br><span class="line">   child</span><br><span class="line">  },</span><br><span class="line">  created () {</span><br><span class="line">  },</span><br><span class="line">  mounted () {</span><br><span class="line">   // setTimeout模拟异步数据</span><br><span class="line">   setTimeout(() =&gt; {</span><br><span class="line">    this.asyncObject = {'items': [1, 2, 3]}</span><br><span class="line">    console.log('parent finish')</span><br><span class="line">   }, 2000)</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>子组件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件&lt;!--1--&gt;</span><br><span class="line">  &lt;p&gt;{{childObject.items[0]}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: {</span><br><span class="line">   childObject: {</span><br><span class="line">    type: Object,</span><br><span class="line">    default () {</span><br><span class="line">     return {</span><br><span class="line">      items: ''</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   }</span><br><span class="line">  },</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">   console.log(this.childObject) // {item: ''}</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript安装和使用</title>
      <link href="2021/04/26/TypeScript%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>2021/04/26/TypeScript%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript安装和使用"><a href="#TypeScript安装和使用" class="headerlink" title="TypeScript安装和使用"></a>TypeScript安装和使用</h1><p><code>npm install typescript -g</code> 全局安装</p><p>使用有两种方式:</p><ul><li>tsc直接编译一个<code>.ts</code>文件，生产<code>.js</code>文件</li><li>在项目中编译，通过<code>npm run tsc</code>实现对整个项目编译</li></ul><p>在ts-practice文件夹下新建一个src目录，src目录下新建一个index.ts文件</p><p>index.ts里写入如下内容:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> TokenType {</span><br><span class="line">    ACCESS = <span class="string">'accessToken'</span>,</span><br><span class="line">    REFRESH = <span class="string">'refreshToken'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用<code>npm init</code>初始化项目，生成了<code>package.json</code>文件，在<code>package.json</code>文件的scripts标签里写入：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": {</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "tsc": "tsc"</span><br><span class="line">  }，</span><br><span class="line">"main": "src/index.ts"</span><br></pre></td></tr></tbody></table></figure><p>然后，用<code>tsc --init</code>命令进行初始化</p><p>这时候目录下多了一个<code>tsconfig.js</code>文件，它<strong>指定了用来编译这个项目的根文件和编译选项</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: {</span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="comment">// "incremental": true,                         /* Enable incremental compilation */</span></span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,                                <span class="comment">/* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */</span></span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,                           <span class="comment">/* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */</span></span><br><span class="line">    <span class="comment">// "lib": [],                                   /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="comment">// "allowJs": true,                             /* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="comment">// "checkJs": true,                             /* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// "jsx": "preserve",                           /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */</span></span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>,                         <span class="comment">/* Generates corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "declarationMap": true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "sourceMap": true,                           /* Generates corresponding '.map' file. */</span></span><br><span class="line">    <span class="comment">// "outFile": "./",                             /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./lib"</span>,                              <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"./src"</span>,                             <span class="comment">/* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// "composite": true,                           /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// "tsBuildInfoFile": "./",                     /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="comment">// "removeComments": true,                      /* Do not emit comments to output. */</span></span><br><span class="line">    <span class="comment">// "noEmit": true,                              /* Do not emit outputs. */</span></span><br><span class="line">    <span class="comment">// "importHelpers": true,                       /* Import emit helpers from 'tslib'. */</span></span><br><span class="line">    <span class="comment">// "downlevelIteration": true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */</span></span><br><span class="line">    <span class="comment">// "isolatedModules": true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,                                 <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="comment">// "noImplicitAny": true,                       /* Raise error on expressions and declarations with an implied 'any' type. */</span></span><br><span class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">false</span>,                    <span class="comment">/* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// "strictFunctionTypes": true,                 /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// "strictBindCallApply": true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */</span></span><br><span class="line">    <span class="comment">// "strictPropertyInitialization": true,        /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="attr">"noImplicitThis"</span>: <span class="literal">true</span>,                      <span class="comment">/* Raise error on 'this' expressions with an implied 'any' type. */</span></span><br><span class="line">    <span class="comment">// "alwaysStrict": true,                        /* Parse in strict mode and emit "use strict" for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// "noUnusedLocals": true,                      /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// "noUnusedParameters": true,                  /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// "noImplicitReturns": true,                   /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// "noFallthroughCasesInSwitch": true,          /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line">    <span class="comment">// "noUncheckedIndexedAccess": true,            /* Include 'undefined' in index signature results */</span></span><br><span class="line">    <span class="comment">// "noPropertyAccessFromIndexSignature": true,  /* Require undeclared properties from index signatures to use element accesses. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// "moduleResolution": "node",                  /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// "baseUrl": "./",                             /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// "paths": {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */</span></span><br><span class="line">    <span class="comment">// "rootDirs": [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// "typeRoots": [],                             /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// "types": [],                                 /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// "allowSyntheticDefaultImports": true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,                        <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */</span></span><br><span class="line">    <span class="comment">// "preserveSymlinks": true,                    /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// "allowUmdGlobalAccess": true,                /* Allow accessing UMD globals from modules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// "sourceRoot": "",                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// "mapRoot": "",                               /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// "inlineSourceMap": true,                     /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// "inlineSources": true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// "experimentalDecorators": true,              /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// "emitDecoratorMetadata": true,               /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">"skipLibCheck"</span>: <span class="literal">true</span>,                           <span class="comment">/* Skip type checking of declaration files. */</span></span><br><span class="line">    <span class="attr">"forceConsistentCasingInFileNames"</span>: <span class="literal">true</span>        <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>, <span class="string">"lib"</span>, <span class="string">"**/*.test.ts"</span>],</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src"</span>]</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>执行<code>npm install</code>下载项目所需的依赖，<code>node_modules</code>是项目的所有依赖包，<code>package-lock.json</code>文件将项目依赖包的版本锁定，避免<strong>依赖包大升级造成的不兼容问题</strong>。</p><p>在根目录执行<code>npm run tes</code></p><p><img src="/images/artical-image/image-20210426163128179.png" alt="img"></p><p>得到编译后结果。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript基础类型</title>
      <link href="2021/04/26/TypeScript%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
      <url>2021/04/26/TypeScript%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript-基础类型"><a href="#TypeScript-基础类型" class="headerlink" title="TypeScript 基础类型"></a>TypeScript 基础类型</h2><p>TypeScript 中的类型有</p><blockquote><p>TypeScript中的基础类型都是小写，大写开头的表示的是javascript的构造函数</p></blockquote><ul><li>原始类型<ul><li>boolean</li><li>number</li><li>string</li><li>bigint</li><li>null</li><li>undefined</li><li>symbol</li><li>void</li></ul></li><li>元组 tuple</li><li>枚举 enum</li><li>任意 any</li><li>unknown</li><li>never</li><li>数组 Array</li><li>对象 object</li></ul><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>当一个函数没有返回值时，可以声明为void</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>(<span class="params"></span>): <span class="title">void</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还可以声明一个<code>void</code>类型的变量，但只能赋值为<code>undefined</code>或者<code>null</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nothing: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><h3 id="null-类型和-undefined-类型"><a href="#null-类型和-undefined-类型" class="headerlink" title="null 类型和 undefined 类型"></a>null 类型和 undefined 类型</h3><p><code>undefined</code> 和 <code>null</code> 是<strong>所有类型的子类型</strong>。</p><p>一般项目是默认开启 <code>--strictNullChecks</code> 检测的，如果你将 <code>tsconfig.json</code> 中 <code>strictNullChecks</code> 选项设置为 <code>false</code>，下面这种操作不会报错，不过尽量不要这么做：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组类型有两种表示方法，第一种在元素类型后接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> names: <span class="built_in">string</span>[] = [<span class="string">'Sherlock'</span>, <span class="string">'Watson'</span>, <span class="string">'Mrs. Hudson'</span>]</span><br></pre></td></tr></tbody></table></figure><p>另一种方式是使用数组泛型（<em>泛型后续会单独介绍</em>），<code>Array&lt;元素类型&gt;</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'Sherlock'</span>, <span class="string">'Watson'</span>, <span class="string">'Mrs. Hudson'</span>]</span><br></pre></td></tr></tbody></table></figure><p>混合各种元素类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br></pre></td></tr></tbody></table></figure><p>推荐使用第一种数组类型的表示方法，书写比较简洁直观。</p><h3 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h3><p>有时候接收来自用户的输入，我们是不能确定其变量类型的。这种情况下，我们不希望类型检查器对这些值进行检查，而是直接让它们通过编译阶段的检查，此时可以使用 <code>any</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input: <span class="built_in">any</span> = <span class="string">'nothing'</span></span><br><span class="line"></span><br><span class="line">input = <span class="number">0</span>                   <span class="comment">// ok</span></span><br><span class="line">input = <span class="literal">true</span>                <span class="comment">// ok</span></span><br><span class="line">input = []                  <span class="comment">// ok</span></span><br><span class="line">input = <span class="literal">null</span>                <span class="comment">// ok</span></span><br><span class="line">input = <span class="built_in">Symbol</span>(<span class="string">'any'</span>)       <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure><p>如果一个数据是 any 类型，那么可以访问它的任意属性，即使这个属性不存在：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anything: <span class="built_in">any</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">anything.eat()              <span class="comment">// ok</span></span><br><span class="line">anything.name               <span class="comment">// ok</span></span><br><span class="line">anything[<span class="number">0</span>]                 <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">new</span> anything()              <span class="comment">// ok</span></span><br><span class="line">anything()                  <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure><p>从上面的例子中可以看到，any 类型几乎可以做任何操作，这样很容易编写类型正确但是执行异常的代码。我们使用 TypeScript 就是为了代码的健壮性，所以要<strong>尽量减少 any 的使用</strong>。</p><blockquote><p>any类型很像在javascript直接定义一个变量</p></blockquote><h3 id="容易混淆的点"><a href="#容易混淆的点" class="headerlink" title="容易混淆的点"></a>容易混淆的点</h3><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">Number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">'10'</span>) <span class="comment">// a === 10 为 false</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">number</span> = <span class="built_in">Number</span>(<span class="string">'10'</span>) <span class="comment">// b === 10 为 true</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，通过 <code>new Number('10')</code> 得到的是<strong>一个构造函数，本质是一个对象</strong>。</p><p>第 2 行，<code>Number('10')</code> 与 <code>10</code> 都是声明一个数字 10 的方法，本质就是一个数字。</p><p>第 4 - 5 行，<code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。<code>a</code> 是一个对象，它的 <code>__proto__</code> 属性指向该对象的构造函数的原型对象 <code>Number</code>，所以为 <code>true</code>。<code>b</code> 是一个数字，所以为 <code>false</code>。</p><p><code>__proto__</code> 是非标准属性，你也可以使用 <strong><code>Object.getPrototypeOf()</code></strong> 方法来访问一个对象的原型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__ === <span class="built_in">Object</span>.getPrototypeOf(a) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h3><p><code>bigint</code> 是一种基本数据类型（primitive data type）。</p><p>JavaScript 中可以用 <code>Number</code> 表示的最大整数为 <code>2^53 - 1</code>，可以写为 <code>Number.MAX_SAFE_INTEGER</code>。如果超过了这个界限，可以用 <code>BigInt</code>来表示，它可以表示任意大的整数。</p><p>在一个整数字面量后加 <code>n</code> 的方式定义一个 <code>BigInt</code>，如：<code>10n</code> 或者调用函数 <code>BigInt()</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theBiggestInt: bigint = <span class="number">9007199254740991n</span></span><br><span class="line"><span class="keyword">const</span> alsoHuge: bigint = <span class="built_in">BigInt</span>(<span class="number">9007199254740991</span>)</span><br><span class="line"><span class="keyword">const</span> hugeString: bigint = <span class="built_in">BigInt</span>(<span class="string">"9007199254740991"</span>)</span><br><span class="line"></span><br><span class="line">theBiggestInt === alsoHuge <span class="comment">// true</span></span><br><span class="line">theBiggestInt === hugeString <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><code>BigInt</code> 与 <code>Number</code> 的不同点：</p><ul><li><code>BigInt</code> 不能用于 <code>Math</code> 对象中的方法。</li><li><code>BigInt</code> 不能和任何 <code>Number</code> 实例混合运算，两者必须转换成同一种类型。</li><li><code>BigInt</code> 变量在转换为 <code>Number</code> 变量时可能会丢失精度。</li></ul><p><code>Number</code> 和 <code>BigInt</code> 可以进行比较：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0n</span> === <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1n</span> &lt; <span class="number">2</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">1</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">2</span>   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">2</span>  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt;= <span class="number">2</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>条件判断：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0n</span>) {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'条件成立!'</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'条件不成立!'</span>); <span class="comment">// 输出结果</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> || <span class="number">10n</span>    <span class="comment">// 10n</span></span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> &amp;&amp; <span class="number">10n</span>    <span class="comment">// 0n</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0n</span>)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">10n</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="number">10n</span>         <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!<span class="number">0n</span>          <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p><code>symbol</code> 是一种基本数据类型。</p><p><code>Symbol()</code> 函数会返回 <code>symbol</code> 类型的值。每个从 <code>Symbol()</code> 返回的 <code>symbol</code> 值都是<strong>唯一</strong>的。</p><p>使用 Symbol() 创建新的 symbol 类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym1: symbol = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> sym2: symbol = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">const</span> sym3: symbol = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line">代码块<span class="number">123</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码创建了三个新的 symbol 类型，但要注意每个从 Symbol() 返回的值都是唯一的：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sym2 === sym3) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 每个 <code>Symbol()</code> 方法返回的值都是唯一的，所以，sym2 和 sym3 不相等。</p><p>Symbol() 作为构造函数是不完整的：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="keyword">new</span> <span class="built_in">Symbol</span>() <span class="comment">// TypeError</span></span><br></pre></td></tr></tbody></table></figure><p>这种语法会报错，是因为从 ECMAScript 6 开始<strong>围绕原始数据类型创建一个显式包装器对象已不再被支持</strong>，但因历史遗留原因， <code>new Boolean()</code>、<code>new String()</code> 以及 <code>new Number()</code> 仍可被创建：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>()   <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">const</span> bigint = <span class="keyword">new</span> <span class="built_in">BigInt</span>()   <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>()   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>() <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> = <span class="keyword">new</span> <span class="built_in">String</span>()   <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><h4 id="symbol使用场景"><a href="#symbol使用场景" class="headerlink" title="symbol使用场景"></a>symbol使用场景</h4><ul><li>当一个对象有较多属性时（<em>往往分布在不同文件中由模块组合而成</em>），很容易将某个属性名覆盖掉，使用 <code>Symbol</code> 值可以避免这一现象，比如 <code>vue-router</code> 中的 <code>name</code> 属性。</li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js 文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> aRouter = {</span><br><span class="line">  path: <span class="string">'/index'</span>,</span><br><span class="line">  name: <span class="built_in">Symbol</span>(<span class="string">'index'</span>),</span><br><span class="line">  component: Index</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bRouter = {</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="built_in">Symbol</span>(<span class="string">'index'</span>), <span class="comment">// 不重复</span></span><br><span class="line">  component: Home</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes.js 文件</span></span><br><span class="line"><span class="keyword">import</span> { aRouter } <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> { bRouter } <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  aRouter,</span><br><span class="line">  bRouter</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 两个不同文件使用了同样的 <code>Symbol('index')</code> 作为属性 name 的值，因 symbol 类型的唯一性，就避免了<strong>重复定义</strong>。</p><ul><li>模拟类的<strong>私有方法</strong></li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permission: symbol = <span class="built_in">Symbol</span>(<span class="string">'permission'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auth</span> </span>{</span><br><span class="line">  [permission]() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种情况<strong>通过类的实例是</strong>无法取到该方法，模拟类的私有方法。</p><p>但是，TypeScript 是可以使用 <code>private</code> 关键字的，所以这种方法可以在 JavaScript 中使用。</p><ul><li>判断是否可以用 <code>for...of</code> 迭代</li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> iterable) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n <span class="keyword">of</span> iterable) {</span><br><span class="line">      <span class="built_in">console</span>.log(n)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个知识点后续会在 <code>迭代器</code> 那一节会着重介绍，这里可以先知晓：</p><p>   <code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。<br>   <code>for...of</code> 只能迭代可枚举属性。</p><ul><li>Symbol.prototype.description</li></ul><p><code>Symbol([description])</code> 中可选的字符串即为这个 Symbol 的描述，如果想要获取这个描述：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">'imooc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sym);               <span class="comment">// Symbol(imooc)</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.toString());    <span class="comment">// Symbol(imooc)</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.description);   <span class="comment">// imooc</span></span><br></pre></td></tr></tbody></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>通过元组可以存储不同类型的元素，而非像数组那样只能存储相同元素类型（any[] 除外）。</p><p>声明一个由 <code>string</code> 和 <code>number</code> 构成的元组：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]   <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list1: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="number">1887</span>, <span class="string">'Sherlock'</span>]  <span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 元组中规定的元素类型<strong>顺序必须是完全对照的</strong>，而且<strong>不能多、不能少</strong>（数量也必须一样，数组有了长度）<code>list1</code> 中定义的第一个元素为 <code>string</code>类型，不能赋值为 <code>number</code>类型的数据。</p><p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">0</span>].substr(<span class="number">1</span>)  <span class="comment">// ok</span></span><br><span class="line">list[<span class="number">1</span>].substr(<span class="number">1</span>)  <span class="comment">// Property 'substr' does not exist on type 'number'.</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 3 行，<code>list[0]</code> 是一个字符串类型，拥有 substr() 方法。</p><p>第 4 行，<code>list[1]</code> 是一个数字类型，没有 substr() 方法，所以报错。</p><p>要注意元组的越界问题，虽然<strong>可以越界添加元素</strong>（<em>不建议</em>），但是<strong>不可越界访问</strong>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br><span class="line">list.push(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(list)      <span class="comment">// ok [ 'Sherlock', 1887, 'hello world' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(list[<span class="number">2</span>])   <span class="comment">// Tuple type '[string, number]' of length '2' has no element at index '2'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，向一个声明了<strong>只有两个元素的元组</strong>继续添加元素，这种操作虽然可行，但是严重不建议！</p><p>第 5 行，该元组只有两个元素，不可越界访问第三个元素。</p><p>元组类型允许在元素类型后缀一个 <code>?</code> 来说明元素是可选的：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">number</span>, <span class="built_in">string</span>?, <span class="built_in">boolean</span>?]</span><br><span class="line">list = [<span class="number">10</span>, <span class="string">'Sherlock'</span>, <span class="literal">true</span>]</span><br><span class="line">list = [<span class="number">10</span>, <span class="string">'Sherlock'</span>]</span><br><span class="line">list = [<span class="number">10</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>可选元素必须在必选元素的后面，也就是如果一个元素后缀了 <code>?</code>号，其后的所有元素都要后缀 <code>?</code>号</strong>。</p><p>元组可以作为参数传递给函数，函数的 Rest 形参可以定义为元组类型（动态长度）：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">rest</span>(<span class="params">...args: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>]</span>): <span class="title">void</span></span></span><br></pre></td></tr></tbody></table></figure><p>等价于：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">rest</span>(<span class="params">arg1: <span class="built_in">number</span>, arg2: <span class="built_in">string</span>, arg3: <span class="built_in">boolean</span></span>): <span class="title">void</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>TIPS：</strong> 在声明文件（.d.ts）中，关键字 declare 表示声明作用。声明文件用于编写第三方类库，通过配置 <code>tsconfig.json</code> 文件中的 <code>declaration 为 true</code>，在编译时可自行生成。</p></blockquote><p>还可以这样：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">number</span>, ...string[]] = [<span class="number">10</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list1: [<span class="built_in">string</span>, ...number[]] = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> Rest 元素指定了元组类型是无限扩展的，可能有零个或多个具有数组元素类型的额外元素。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>需要定义一组相同主题的常量数据时，应该立即想到枚举类型。在学习过程中，需要注意枚举类型的<strong>正向映射和反向映射</strong></p><p>使用枚举我们可以定义一些<strong>带名字的常量</strong>。TypeScript 支持<strong>数字</strong>的和基于<strong>字符串</strong>的枚举。</p><p>枚举类型弥补了 JavaScript 的设计不足，很多语言都拥有枚举类型。</p><p>当我们需要一组相同主题下的数据时，枚举类型就很有用了。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction { Up, Down, Left, Right }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Months { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Size { big = <span class="string">'大'</span>, medium = <span class="string">'中'</span>, small = <span class="string">'小'</span> }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Agency { province = <span class="number">1</span>, city = <span class="number">2</span>, district = <span class="number">3</span> }</span><br></pre></td></tr></tbody></table></figure><p>声明一个枚举类型，如果没有赋值，它们的值默认为<strong>数字类型</strong>且从 0 开始累加：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Months.Jan === <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">Months.Feb === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">Months.Mar === <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line">Months.Apr === <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>现实中月份是从 1 月开始的，那么只需要这样：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第一个数字赋值，往后依次累加</span></span><br><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Months.Jan === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">Months.Feb === <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line">Months.Mar === <span class="number">3</span> <span class="comment">// true</span></span><br><span class="line">Months.Apr === <span class="number">4</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>枚举类型的值为<strong>字符串类型</strong>：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> TokenType {</span><br><span class="line">  ACCESS = <span class="string">'accessToken'</span>,</span><br><span class="line">  REFRESH = <span class="string">'refreshToken'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种不同的取值写法</span></span><br><span class="line"><span class="built_in">console</span>.log(TokenType.ACCESS === <span class="string">'accessToken'</span>)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(TokenType[<span class="string">'REFRESH'</span>] === <span class="string">'refreshToken'</span>)   <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 枚举的取值，有 <code>TokenType.ACCESS</code> 和 <code>TokenType['ACCESS']</code> 这两种不同的写法，效果是相同的。</p><p><strong>数字类型和字符串类型可以混合使用，但是不建议：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> BooleanLikeHeterogeneousEnum {</span><br><span class="line">    No = <span class="number">0</span>,</span><br><span class="line">    Yes = <span class="string">"YES"</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>枚举类型的值可以是一个简单的<strong>计算表达式</strong>：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Calculate {</span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">  expired = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>,</span><br><span class="line">  length = <span class="string">'imooc'</span>.length,</span><br><span class="line">  plus = <span class="string">'hello '</span> + <span class="string">'world'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.expired)   <span class="comment">// 86400</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.length)    <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.plus)      <span class="comment">// hello world</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Tips:</strong></p><ul><li>计算结果必须为常量。</li><li>计算项必须放在最后。</li></ul><p>所谓的反向映射就是指枚举的取值，不但可以正向的 <code>Months.Jan</code> 这样取值，也可以反向的 <code>Months[1]</code> 这样取值。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Months.Mar === <span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么反过来能取到 Months[3] 的值吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(Months[<span class="number">3</span>])  <span class="comment">// 'Mar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以</span></span><br><span class="line"><span class="built_in">console</span>.log(Months.Mar === <span class="number">3</span>)     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Months[<span class="number">3</span>] === <span class="string">'Mar'</span>)  <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Tips:</strong></p><ol><li>字符串枚举成员不会生成反向映射。</li><li>枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。</li></ol><p>在枚举上使用 <code>const</code> 修饰符：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> month = Months.Mar</span><br></pre></td></tr></tbody></table></figure><p>查看一下编译后的内容：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> month = <span class="number">3</span> <span class="comment">/* Mar */</span></span><br><span class="line">代码块<span class="number">12</span></span><br></pre></td></tr></tbody></table></figure><p>发现枚举类型应该编译出的对象没有了，只剩下 <code>month</code> 常量。这就是使用 <code>const</code> 关键字声明枚举的作用。因为变量 <code>month</code> 已经使用过枚举类型，在编译阶段 TypeScript 就将枚举类型抹去，这也是<strong>性能提升</strong>的一种方案。</p><p>分开声明名称相同的枚举类型，会<strong>自动合并</strong>：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  May = <span class="number">5</span>,</span><br><span class="line">  Jun</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Months.Apr) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(Months.Jun) <span class="comment">// 6</span></span><br></pre></td></tr></tbody></table></figure><h2 id="TypeScript-Never-与-Unknown"><a href="#TypeScript-Never-与-Unknown" class="headerlink" title="TypeScript Never 与 Unknown"></a>TypeScript Never 与 Unknown</h2><p>本节介绍 never 和 unknown 类型，其中 unknown 类型作为 any 类型对应的安全类型使用起来更加安全，如果有<strong>any 类型的使用需求</strong>，应尽量使用 **unknown 类型来替代 **any 类型。</p><p><code>never</code> 类型表示那些永不存在的值的类型。</p><p><code>unknown</code> 类型是 <code>any</code> 类型对应的安全类型。</p><h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>一个抛出异常的函数表达式，其函数返回值类型为 never：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message:<span class="built_in">string</span></span>): <span class="title">never</span> </span>{</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样的，不会有返回值的函数表达式，其函数返回值类型也为 never:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断的返回值类型为 never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>): <span class="title">never</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不能取得值的地方：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo {</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'foo'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bar {</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'bar'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> All = Foo | Bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleValue</span>(<span class="params">val: All</span>) </span>{</span><br><span class="line">  <span class="keyword">switch</span> (val.type) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'foo'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'bar'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 此处不能取值</span></span><br><span class="line">      <span class="keyword">const</span> exhaustiveCheck: <span class="built_in">never</span> = val</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Unknown"><a href="#Unknown" class="headerlink" title="Unknown"></a>Unknown</h3><p>我们知道 any 无需事先执行任何类型的检查：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="number">10</span>               <span class="comment">// OK</span></span><br><span class="line">value = <span class="string">"Hello World"</span>    <span class="comment">// OK</span></span><br><span class="line">value = []               <span class="comment">// OK</span></span><br><span class="line">value = {}               <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Math</span>.random      <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">null</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">undefined</span>        <span class="comment">// OK</span></span><br><span class="line">value = <span class="keyword">new</span> <span class="built_in">TypeError</span>()  <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)   <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">value.foo.bar            <span class="comment">// OK</span></span><br><span class="line">value.trim()             <span class="comment">// OK</span></span><br><span class="line">value()                  <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">new</span> value()              <span class="comment">// OK</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]              <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><p>在许多情况下，这太宽松了。 <code>unknown</code> 类型呢？</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="number">10</span>               <span class="comment">// OK</span></span><br><span class="line">value = <span class="string">"Hello World"</span>    <span class="comment">// OK</span></span><br><span class="line">value = []               <span class="comment">// OK</span></span><br><span class="line">value = {}               <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Math</span>.random      <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">null</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">undefined</span>        <span class="comment">// OK</span></span><br><span class="line">value = <span class="keyword">new</span> <span class="built_in">TypeError</span>()  <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)   <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><p>所有对该 <code>value</code> 变量的分配都被认为是类型正确的。</p><p>但是，如果尝试：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value1: unknown = value   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> value2: <span class="built_in">any</span> = value       <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value3: <span class="built_in">boolean</span> = value   <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value4: <span class="built_in">number</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value5: <span class="built_in">string</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value6: <span class="built_in">object</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value7: <span class="built_in">any</span>[] = value     <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，该 unknown 类型<strong>只能分配给 any 类型和 unknown 类型</strong>本身。</p><p>现在继续尝试：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line">value.foo.bar  <span class="comment">// Error</span></span><br><span class="line">value.trim()   <span class="comment">// Error</span></span><br><span class="line">value()        <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">new</span> value()    <span class="comment">// Error</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]    <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure><p><strong><code>unknown</code> 类型在被确定为某个类型之前，不能被进行诸如函数执行、实例化等操作，一定程度上对类型进行了保护。</strong></p><blockquote><p>在那些将取得任意值，但不知道具体类型的地方使用 <code>unknown</code>，而非 <code>any</code>。</p></blockquote><h2 id="TypeScript-接口-Interface"><a href="#TypeScript-接口-Interface" class="headerlink" title="TypeScript 接口(Interface)"></a>TypeScript 接口(Interface)</h2><blockquote><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。——官方定义</p></blockquote><p>接口是对 JavaScript 本身的随意性进行约束，通过定义一个接口，<strong>约定了变量、类、函数等</strong>应该按照什么样的格式进行声明，实现多人合作的一致性。TypeScript 编译器依赖接口用于类型检查，最终编译为 JavaScript 后，接口将会被移除。</p><p><strong>接口主要是对对象、函数、类的类型做一些定义</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line"><span class="keyword">interface</span> DemoInterface {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在声明一个<strong>对象</strong>、<strong>函数</strong>或者<strong>类</strong>时，先定义接口，确保其数据结构的一致性。</p><p>在多人协作时，定义接口尤为重要。</p><h3 id="接口的好处"><a href="#接口的好处" class="headerlink" title="接口的好处"></a>接口的好处</h3><p>过去我们写 JavaScript 定义一个函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClothesInfo</span>(<span class="params">clothes</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(clothes.price)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClothes = {</span><br><span class="line">  color: <span class="string">'black'</span>, </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line">getClothesInfo(myClothes)</span><br></pre></td></tr></tbody></table></figure><p>之前我们写 JavaScript 这样是很正常的，但同时你可能会遇到下面这些问题:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getClothesInfo() <span class="comment">// Uncaught TypeError: Cannot read property 'price' of undefined</span></span><br><span class="line">getClothesInfo({ <span class="attr">color</span>: <span class="string">'black'</span> }) <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>相信原因你也知道，JavaScript 是 <code>弱类型</code> 语言，并不会对传入的参数进行任何检测，错误在运行时才被发现。那么通过定义 <code>接口</code>，在编译阶段甚至开发阶段就避免掉这类错误，接口<strong>将检查类型是否和某种结构做匹配</strong>。</p><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>下面通过接口的方式重写之前的例子：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClothesInfo</span>(<span class="params">clothes: Clothes</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(clothes.price)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  color: <span class="string">'black'</span>, </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getClothesInfo(myClothes)</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 代码中，定义了一个接口 <code>Clothes</code>，在传入的变量 <code>clothes</code> 中，它的类型为 <code>Clothes</code>。这样，就约束了这个传入对象的 <code>外形</code> 与接口定义一致。只要传入的对象满足上面的类型约束，那么它就是被允许的。</p><p><strong>Tips：</strong></p><ol><li>定义接口要 <code>首字母大写</code>。</li><li>只需要关注值的 <code>外形</code>，并不像其他语言一样，定义接口是为了实现。</li><li>如果没有特殊声明，定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致。</li></ol><h3 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h3><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>接口中的属性不全是必需的。可选属性的含义是该属性在被变量定义时可以不存在。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以不定义属性 color</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p><p>这时，<strong>仍不允许添加未定义的属性</strong>，如果引用了不存在的属性时 TS 将直接捕获错误。</p><h4 id="只读属性-和const对应，一个是属性一个是变量"><a href="#只读属性-和const对应，一个是属性一个是变量" class="headerlink" title="只读属性(和const对应，一个是属性一个是变量)"></a>只读属性(和const对应，一个是属性一个是变量)</h4><p>一些对象属性<strong>只能在对象刚刚创建的时候修改其值</strong>。你可以在属性名前用 <code>readonly</code> 来指定只读属性，比如价格是不能被修改的:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的时候给 price 赋值</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可修改</span></span><br><span class="line">myClothes.price = <span class="number">100</span></span><br><span class="line"><span class="comment">// error TS2540: Cannot assign to 'price' because it is a constant or a read-only property</span></span><br></pre></td></tr></tbody></table></figure><p>TypeScript 可以通过 <code>ReadonlyArray&lt;T&gt;</code> 设置数组为只读，那么它的所有<strong>写方法</strong>都会失效。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">6</span>; <span class="comment">// Index signature in type 'readonly number[]' only permits reading</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 代码中的泛型语法在之后会有专门的小节介绍。</p><h5 id="readonlyvsconst"><a href="#readonlyvsconst" class="headerlink" title="readonlyvsconst`"></a>readonly<code>vs</code>const`</h5><p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为<strong>变量使用还是做为一个属性</strong>。做为 <code>变量</code> 使用的话用 const，若做为 <code>属性</code> 则使用 readonly。</p><h4 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h4><p>有时候我们希望接口允许有任意的属性，语法是用 <code>[]</code> 将属性包裹起来：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> price: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意属性 activity</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span>,</span><br><span class="line">  activity: <span class="string">'coupon'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 这里的接口 <code>Clothes</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> <code>size</code> 和 <code>price</code>，那么就无所谓它们的类型是什么。</p><ul><li>项目案例：使用 axios 库发起 HTTP 传输的时候，可以写入一个自定义的属性，就是因为源码中定义了一个任意属性：</li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$axios({</span><br><span class="line">  method: <span class="string">'put'</span>,</span><br><span class="line">  url: <span class="string">'/cms/user'</span>,</span><br><span class="line">  data: {</span><br><span class="line">    nickname: <span class="built_in">this</span>.nickname,</span><br><span class="line">  },</span><br><span class="line">  showBackend: <span class="literal">true</span>,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>除了描述带有属性的普通对象外，接口也可以描述<strong>函数类型。</strong></p><p>为了使接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个<strong>只有 <code>参数列表</code> 和 <code>返回值类型</code> 的函数定义</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> source.search(subString) &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于函数类型的类型检查来说，<strong>函数的参数名不需要与接口里定义的名字相匹配</strong>。你可以改变函数的参数名，<strong>只要保证函数参数的位置不变。函数的参数会被逐个进行检查：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"><span class="comment">// source =&gt; src, subString =&gt; sub</span></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> src.search(sub) &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>如果接口中的函数类型带有函数名，下面两种书写方式是等价的：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Calculate {</span><br><span class="line">  add(x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">  multiply: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h3><p>可索引类型接口读起来有些拗口，直接看例子：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常的js代码</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  brand: <span class="string">'imooc'</span>,</span><br><span class="line">  type: <span class="string">'education'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line">obj[<span class="string">'brand'</span>]</span><br></pre></td></tr></tbody></table></figure><p>再来看定义可索引类型接口：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ScenicInterface {</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: ScenicInterface = [<span class="string">'西湖'</span>, <span class="string">'华山'</span>, <span class="string">'故宫'</span>]</span><br><span class="line"><span class="keyword">let</span> favorite: <span class="built_in">string</span> = arr[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><p>示例中索引签名是 <code>number类型</code>，返回值是字符串类型。</p><p>另外还有一种索引签名是 <code>字符串类型</code>。我们可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。通过下面的例子理解这句话：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">interface</span> Foo {</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">interface</span> Bar {</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">string</span>; <span class="comment">// Error: y 属性必须为 number 类型， 代表用y去索引返回string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>语法错误是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>我们希望<strong>类的实现必须遵循接口定义</strong>，那么可以使用 <code>implements</code> 关键字来确保兼容性。</p><p>这种类型的接口在传统面向对象语言中最为常见，比如 java 中接口就是这种类类型的接口。<strong>这种接口与抽象类比较相似，但是接口只能含有抽象方法和成员属性，实现类中必须实现接口中所有的抽象方法和成员属性。</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AnimalInterface {</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">AnimalInterface</span> </span>{</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你也可以在接口中描述一个方法，在类里实现它:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AnimalInterface {</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  eat(m: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">AnimalInterface</span> </span>{</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params">m: <span class="built_in">number</span></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">${<span class="built_in">this</span>.name}</span>吃肉<span class="subst">${m}</span>分钟`</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p>接口描述了类的公共部分，而不是公共和私有两部分。 它<strong>不会帮你检查类是否具有某些私有成员。</strong></p><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以通过关键字 <code>extents</code> 相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape {</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = {} <span class="keyword">as</span> Square;</span><br><span class="line"><span class="comment">// 继承了 Shape 的属性</span></span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke {</span><br><span class="line">  penWidth: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke {</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = {} <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>在前面已经介绍，接口可以<strong>描述函数、对象的方法或者对象的属性。</strong></p><p>有时希望一个对象同时具有上面提到多种类型，比如一个<strong>对象可以当做函数使用，同时又具有属性和方法。</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter {</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>{</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>{ } <span class="keyword">as</span> Counter;</span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ };</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，声明一个接口，<strong>如果只有 <code>(start: number): string</code> 一个成员，那么这个接口就是函数接口</strong>，同时还具有其他两个成员，可以用来描述对象的属性和方法，这样就构成了一个混合接口。</p><p>第 7 行，创建一个 <code>getCounter()</code> 函数，它的返回值是 Counter 类型的。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>{ } <span class="keyword">as</span> Counter;</span><br></pre></td></tr></tbody></table></figure><p>第 8 行，通过类型断言，将函数对象转换为 <code>Counter</code> 类型，转换后的对象不但实现了函数接口的描述，使之成为一个函数，还具有 interval 属性和 reset() 方法。断言成功的条件是，两个数据类型只要有一方可以赋值给另一方，这里函数类型数据不能赋值给接口类型的变量，因为它不具有 interval 属性和 reset() 方法。</p><p>类型断言在之后的小节也会单节介绍。</p><h2 id="TypeScript-类-Class"><a href="#TypeScript-类-Class" class="headerlink" title="TypeScript 类(Class)"></a>TypeScript 类(Class)</h2><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>TypeScript 可以使用四种访问修饰符 <code>public</code>、<code>protected</code>、<code>private</code> 和 <code>readonly</code>。</p><h4 id="4-1-public"><a href="#4-1-public" class="headerlink" title="4.1 public"></a>4.1 public</h4><p>TypeScript 中，类的成员全部默认为 <code>public</code>，当然你也可以显式的将一个成员标记为 <code>public</code>，标记为 <code>public</code> 后，在程序类的外部可以访问。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>{</span><br><span class="line">  <span class="comment">// 类的属性</span></span><br><span class="line">  <span class="keyword">public</span> x: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">public</span> y: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> add () {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x + <span class="built_in">this</span>.y</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="4-2-protected"><a href="#4-2-protected" class="headerlink" title="4.2 protected"></a>4.2 protected</h4><p>当成员被定义为 <code>protected</code> 后，只能被<strong>类的内部以及类的子类访问</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>{</span><br><span class="line">  <span class="keyword">protected</span> baseUrl: <span class="built_in">string</span> = <span class="string">'http://api.com/'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {}</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="title">request</span>(<span class="params">method: <span class="built_in">string</span></span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`<span class="subst">${<span class="built_in">this</span>.baseUrl}</span><span class="subst">${method}</span>`</span></span><br><span class="line">    <span class="comment">// TODO 封装基础的 http 请求</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(<span class="string">'address'</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，Base 类的属性 baseUrl 被定义为受保护的，那么第 7 行该属性在类中被访问是可以的。</p><p>第 14 行，因 Address 类是 Base 类的子类，在子类中允许访问父类中被定义为受保护类型的方法 request() 。</p><h4 id="4-3-private"><a href="#4-3-private" class="headerlink" title="4.3 private"></a>4.3 private</h4><p>当类的成员被定义为 <code>private</code> 后，只能被<strong>类的内部访问</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mom</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">labour</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'baby is coming'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Mom</span> </span>{</span><br><span class="line">  test () {</span><br><span class="line">    <span class="built_in">this</span>.labour() <span class="comment">// Error, Property 'labour' is private and only accessible within class 'Mom'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">代码块<span class="number">1234567891011</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 9 行，父类中的 labour() 方法被定义为私有方法，只能在父类中被使用，子类中调用报错。</p><h4 id="4-4-readonly"><a href="#4-4-readonly" class="headerlink" title="4.4 readonly"></a>4.4 readonly</h4><p>通过 <code>readonly</code> 关键字将属性设置为只读的。<strong>只读属性必须在声明时或构造函数里被初始化。</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>{</span><br><span class="line">  <span class="keyword">readonly</span> secret: <span class="built_in">string</span> = <span class="string">'xjx*xh3GzW#3'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">readonly</span> expired: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">expired: <span class="built_in">number</span></span>) {</span><br><span class="line">    <span class="built_in">this</span>.expired = expired</span><br><span class="line">  } </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> token = <span class="keyword">new</span> Token(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>)</span><br><span class="line">token.expired = <span class="number">60</span> * <span class="number">60</span> * <span class="number">2</span> <span class="comment">// Error, expired 是只读的</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>最后一行，因 Token 类的属性 expired 被设置为只读属性，不可被修改。</p><h3 id="5-静态方法"><a href="#5-静态方法" class="headerlink" title="5. 静态方法"></a>5. 静态方法</h3><p>通过 <code>static</code> 关键字来创建类的静态成员，这些属性存在于<strong>类本身上面而不是类的实例上</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> getInformation () {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'This guy is too lazy to write anything.'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">User.getInformation() <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User()</span><br><span class="line">user.getInformation() <span class="comment">// Error 实例中无此方法</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> getInformation() 方法被定义为静态方法，只存在于类本身上，类的实例无法访问。</p><p>静态方法调用同一个类中的其他静态方法，可使用 this 关键字。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethodCall</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'Static method has been called'</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">anotherStaticMethod</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.staticMethod() + <span class="string">' from another static method'</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 静态方法中的 <code>this</code> 指向类本身，而静态方法也存在于类本身，所以可以在静态方法中用 this 访问在同一类中的其他静态方法。</p><p>非静态方法中，不能直接使用 <code>this</code> 关键字来访问静态方法。而要用类本身或者构造函数的属性来调用该方法：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethodCall</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="comment">// 类本身调用</span></span><br><span class="line">      <span class="built_in">console</span>.log(StaticMethodCall.staticMethod())</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构造函数的属性调用</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.constructor.staticMethod())</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'static method has been called.'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 类指向其构造函数本身，在非静态方法中，<code>this.constructor === StaticMethodCall</code> 为 <code>true</code>， 也就是说这两种写法等价。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类作为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节。</p><p><code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line">    <span class="keyword">abstract</span> makeSound(): <span class="built_in">void</span>;</span><br><span class="line">    move(): <span class="built_in">void</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'roaming the earch...'</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> Animal() <span class="comment">// Error, 无法创建抽象类实例</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>通常我们需要创建子类继承抽象类，将抽象类中的抽象方法一一实现，这样在大型项目中可以很好的约束子类的实现。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">makeSound</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bark bark bark...'</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"></span><br><span class="line">dog.makeSound()  <span class="comment">// bark bark bark...</span></span><br><span class="line">dog.move()       <span class="comment">// roaming the earch...</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h3><p>类也可以作为接口来使用，这在项目中是很常见的。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> toppings: <span class="built_in">string</span>[]</span>)</span> {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaMaker</span> </span>{</span><br><span class="line">  <span class="comment">// 把 Pizza 类当做接口</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params">event: Pizza</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pizza(event.name, event.toppings)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pizza = PizzaMaker.create({ </span><br><span class="line">  name: <span class="string">'Cheese and nut pizza'</span>, </span><br><span class="line">  toppings: [<span class="string">'pasta'</span>, <span class="string">'eggs'</span>, <span class="string">'milk'</span>, <span class="string">'cheese'</span>]</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>第 7 行，把 Pizza 类当做接口。</p><p>因为接口和类都定义了对象的结构，在某些情况下可以互换使用。如果你需要创建一个可以自定义参数的实例，同时也可以进行类型检查，把类当做接口使用不失为一个很好的方法。</p><p>这就是 TypeScript 的强大功能，而且非常灵活，<strong>拥有全面的面向对象设计和通用的类型检查</strong>。</p><h2 id="TypeScript函数"><a href="#TypeScript函数" class="headerlink" title="TypeScript函数"></a>TypeScript函数</h2><h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><p>在 TypeScript 中编写函数，需要给形参和返回值指定类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (x + y).toString()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>参数 x 和 y 都是 number 类型，两个参数相加后将其类型转换为 string， 所以整个函数的返回值为 string 类型。</p><p>上面的代码只是对 <code>=</code> 等号右侧的匿名函数进行了类型定义，等号左侧的 <code>add</code> 同样可以添加类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (x + y).toString()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可以看到，等号左侧的类型定义由两部分组成：参数类型和返回值类型，通过 <code>=&gt;</code> 符号来连接。</p><p>这里要注意：<strong>函数类型的 <code>=&gt;</code> 和 箭头函数的 <code>=&gt;</code> 是不同的含义</strong>。</p><p>通过箭头函数改写一下刚才写的函数:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="function"><span class="params">string</span> =&gt;</span> (x + y).toString()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>等号左右两侧书写完整：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要参数位置及类型不变，变量名称可以自己定义，比如把两个参数定位为 a b</span></span><br><span class="line"><span class="keyword">const</span> add: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> = (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="function"><span class="params">string</span> =&gt;</span> (x + y).toString()</span><br></pre></td></tr></tbody></table></figure><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><h4 id="参数个数保持一致"><a href="#参数个数保持一致" class="headerlink" title="参数个数保持一致"></a>参数个数保持一致</h4><p>TypeScript 中每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器会检查用户是否为每个参数都传入了值。简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = (firstName: <span class="built_in">string</span>, <span class="attr">lastName</span>: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> <span class="string">`<span class="subst">${firstName}</span><span class="subst">${lastName}</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = fullName(<span class="string">'Sherlock'</span>, <span class="string">'Holmes'</span>)</span><br><span class="line"><span class="keyword">let</span> result2 = fullName(<span class="string">'Sherlock'</span>, <span class="string">'Holmes'</span>, <span class="string">'character'</span>) <span class="comment">// Error, Expected 2 arguments, but got 3</span></span><br><span class="line"><span class="keyword">let</span> result3 = fullName(<span class="string">'Sherlock'</span>)                        <span class="comment">// Error, Expected 2 arguments, but got 1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，一个需要传入 2 个字符串类型参数的函数类型定义。</p><p>第 4 行，<code>result2</code> 传入了 3 个参数，与声明的 2 个参数不符。</p><p>第 5 行，<code>result3</code> 只传入了 1 个参数，同样与声明的 2 个参数不符。</p><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>在 JavaScript 中每个参数都是可选的，可传可不传。没传参的时候，它的值就是 undefined。 而在 TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能，<strong>可选参数必须跟在必须参数后面</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = (firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> <span class="string">`<span class="subst">${firstName}</span><span class="subst">${lastName}</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = fullName(<span class="string">'Sherlock'</span>, <span class="string">'Holmes'</span>)</span><br><span class="line"><span class="keyword">let</span> result2 = fullName(<span class="string">'Sherlock'</span>, <span class="string">'Holmes'</span>, <span class="string">'character'</span>) <span class="comment">// Error, Expected 1-2 arguments, but got 3</span></span><br><span class="line"><span class="keyword">let</span> result3 = fullName(<span class="string">'Sherlock'</span>)                        <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，firstName 是必须参数，lastName 是可选参数。</p><p>第 4 行，传入了 3 个参数，与声明的 2 个参数不符。</p><p>第 5 行，lastName 是可选参数，可以省略。</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>参数可以取默认值，上面介绍的<strong>可选参数必须跟在必须参数后面</strong>，而<strong>带默认值的参数不需要放在必须参数的后面，可随意调整位置</strong>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> token = (expired = <span class="number">60</span>*<span class="number">60</span>, <span class="attr">secret</span>: <span class="built_in">string</span>): <span class="function"><span class="params">void</span>  =&gt;</span> {}</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> token1 = (secret: <span class="built_in">string</span>, expired = <span class="number">60</span>*<span class="number">60</span> ): <span class="function"><span class="params">void</span> =&gt;</span> {}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，带默认值的参数 expired 在参数列表首位。</p><p>第 3 行，带默认值的参数 expired 在参数列表末位。</p><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>有的时候，函数的参数个数是不确定的，可能传入未知个数，这时没有关系，有一种方法可以解决这个问题。</p><p>通过 <code>rest 参数</code> (形式为 <code>...变量名</code>)来获取函数的剩余参数，这样就不需要使用 <code>arguments</code> 对象了。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">ok: <span class="built_in">boolean</span>, ...args: <span class="built_in">string</span>[]</span>): <span class="title">void</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (!ok) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(args.join(<span class="string">' '</span>));</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">assert(<span class="literal">false</span>, <span class="string">'上传文件过大'</span>, <span class="string">'只能上传jpg格式'</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，第二个参数传入剩余参数，且均为字符串类型。</p><p>第 7 行，调用函数 <code>assert()</code> 时，除了第一个函数传入一个布尔类型，接下来可以无限传入多个字符串类型的参数。</p><blockquote><p><strong>TIP：注意 <code>rest 参数</code> 只能是最后一个参数。</strong></p></blockquote><h4 id="this-参数"><a href="#this-参数" class="headerlink" title="this 参数"></a>this 参数</h4><p>JavaScript 里，this 的值在函数被调用的时候才会被指定，但是这个 this 到底指的是什么还是需要花点时间弄清楚。</p><p>默认情况下，<code>tsconfig.json</code> 中，编译选项 <code>compilerOptions</code> 的属性 <code>noImplicitThis</code> 为 <code>false</code>，我们在一个对象中使用的 this 时，它的类型是 any 类型。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> triangle = {</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="number">15</span>,</span><br><span class="line">  c: <span class="number">20</span>,</span><br><span class="line">  area: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="comment">// this 为 any 类型</span></span><br><span class="line">      <span class="keyword">const</span> p = (<span class="built_in">this</span>.a + <span class="built_in">this</span>.b + <span class="built_in">this</span>.c) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p * (p - <span class="built_in">this</span>.a) * (p - <span class="built_in">this</span>.b) *(p - <span class="built_in">this</span>.c))</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myArea = triangle.area()</span><br><span class="line"><span class="built_in">console</span>.log(myArea())</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>在实际工作中 any 类型是非常危险的，我们可以添加任意属性到 any 类型的参数上，比如将 <code>const p = (this.a + this.b + this.c) / 2</code> 这句改为 <code>const p = (this.d + this.d + this.d) / 2</code> 也不会报错，这很容易造成不必要的问题。</p><p>所以我们应该明确 this 的指向，下面介绍两种方法：</p><p>第一种，在 <code>tsconfig.json</code> 中，将编译选项 <code>compilerOptions</code> 的属性 <code>noImplicitThis</code> 设置为 <code>true</code>，TypeScript 编译器就会帮你进行正确的类型推断：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> triangle = {</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="number">15</span>,</span><br><span class="line">  c: <span class="number">20</span>,</span><br><span class="line">  area: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> p = (<span class="built_in">this</span>.a + <span class="built_in">this</span>.b + <span class="built_in">this</span>.c) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p * (p - <span class="built_in">this</span>.a) * (p - <span class="built_in">this</span>.b) *(p - <span class="built_in">this</span>.c))</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myArea = triangle.area()</span><br><span class="line"><span class="built_in">console</span>.log(myArea())</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>将 <code>noImplicitThis</code> 设置为 <code>true</code> 以后，把鼠标放在第 7 行的 <code>this</code> 上，可以看到：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this: {</span><br><span class="line">  a: number;</span><br><span class="line">  b: number;</span><br><span class="line">  c: number;</span><br><span class="line">  area: () =&gt; () =&gt; number;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这时，TypeScript 编译器就能准确的知道了 this 的类型，如果取不存在于 this 属性中的 <code>d</code>，将会报错 <code>Property 'd' does not exist on type '{ a: number; b: number; c: number; area: () =&gt; () =&gt; any; }'</code></p><p>除了这种方法，我们还可以通过 <code>this 参数</code> 这种形式来解决 this 为 any 类型这一问题。提供一个显式的 <code>this</code> 参数，它出现在参数列表的最前面：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span></span>) </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改造刚才的例子：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Triangle {</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">  c: <span class="built_in">number</span>;</span><br><span class="line">  area(<span class="built_in">this</span>: Triangle): <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// area接受一个Triangle类型的this参数，返回一个函数，这个函数的返回类型是number</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> triangle: Triangle = {</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="number">15</span>,</span><br><span class="line">  c: <span class="number">20</span>,</span><br><span class="line">  area: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">this</span>: Triangle</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> p = (<span class="built_in">this</span>.a + <span class="built_in">this</span>.b + <span class="built_in">this</span>.c) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p * (p - <span class="built_in">this</span>.a) * (p - <span class="built_in">this</span>.b) *(p - <span class="built_in">this</span>.c))</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myArea = triangle.area()</span><br><span class="line"><span class="built_in">console</span>.log(myArea())</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>我们声明了一个接口 <code>Triangle</code>，其中的函数类型显式的传入了 <code>this</code> 参数，这个参数的类型为 <code>Triangle</code> 类型（第 5 行）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area(this: Triangle): () =&gt; number;</span><br></pre></td></tr></tbody></table></figure><p>此时，在第 14 行，<code>this</code> 指向 <code>Triangle</code>，就可以进行正确的类型判断，如果取未定义参数，编译器将直接报错。</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载是指函数根据传入不同的参数，返回不同类型的数据。</p><p>它的意义在于让你清晰的知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到相同类型的数据，那就不需要使用函数重载。</p><p>比如面试中常考的字符反转问题，这里就不考虑负数情况了，只是为了演示函数重载：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">target: string | number</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'string'</span>) {</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'number'</span>) {</span><br><span class="line">    <span class="keyword">return</span> +[...target.toString()].reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">rse(<span class="string">'imooc'</span>))   <span class="comment">// coomi</span></span><br><span class="line"><span class="built_in">console</span>.log(reverse(<span class="number">23874800</span>))  <span class="comment">// 847832</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>编译器并不知道入参是什么类型的，返回值类型也不能确定。这时可以为同一个函数提供多个函数类型定义来进行函数重载。</p><p>(通过 <code>--downlevelIteration</code> 编译选项增加对生成器和迭代器协议的支持)</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">target: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>{</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> target === <span class="string">'string'</span></span>) </span>{</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">target</span>.<span class="title">split</span>(<span class="params"><span class="string">''</span></span>).<span class="title">reverse</span>(<span class="params"></span>).<span class="title">join</span>(<span class="params"><span class="string">''</span></span>)</span></span><br><span class="line"><span class="function">  }</span></span><br><span class="line"><span class="function">  <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> target === <span class="string">'number'</span></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> +[...target.toString()].reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(reverse(<span class="string">'imooc'</span>))   <span class="comment">// coomi</span></span><br><span class="line"><span class="built_in">console</span>.log(reverse(<span class="number">23874800</span>))  <span class="comment">// 847832</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>因为这个反转函数在传入字符串类型的时候返回字符串类型，传入数字类型的时候返回数字类型，所以在前两行进行了两次函数类型定义。在函数执行时，根据传入的参数类型不同，进行不同的计算。</p><p>为了让编译器能够选择正确的检查类型，它会从重载列表的第一个开始匹配。因此，在定义重载时，一定要<strong>把最精确的定义放在最前面</strong>。</p><h3 id="使用函数时的注意事项"><a href="#使用函数时的注意事项" class="headerlink" title="使用函数时的注意事项"></a>使用函数时的注意事项</h3><ol><li>如果一个函数没有使用 <code>return</code> 语句，则它默认返回 <code>undefined</code>。</li><li>调用函数时，传递给函数的值被称为函数的 <code>实参</code>（值传递），对应位置的函数参数被称为 <code>形参</code>。</li><li>在函数执行时， <code>this</code> 关键字并不会指向正在运行的函数本身，而是 <code>指向调用函数的对象</code>。</li><li><code>arguments</code> 对象是所有（非箭头）函数中都可用的 <code>局部变量</code>。你可以使用 arguments 对象在函数中引用函数的参数。</li></ol><h2 id="TypeScript-字面量类型"><a href="#TypeScript-字面量类型" class="headerlink" title="TypeScript 字面量类型"></a>TypeScript 字面量类型</h2><p>通俗的讲，字面量也可以叫直接量，就是你看见什么，它就是什么。</p><p>我们之前介绍字符串类型，其实是一个集合类型，所有的字符串集合在一起构成了 string 类型。而字符串字面量类型就直接多了，你定义为 <code>'imooc'</code>，那这个变量的类型就是 <code>'imooc'</code> 类型。</p><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>字符串字面量类型允许你指定字符串必须的固定值。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protagonist: <span class="string">'Sherlock'</span></span><br><span class="line"></span><br><span class="line">protagonist = <span class="string">'Sherlock'</span></span><br><span class="line">protagonist = <span class="string">'Watson'</span> <span class="comment">// Error, Type '"Watson"' is not assignable to type '"Sherlock"'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 变量 <code>protagonist</code> 被声明为 <code>'Sherlock'</code> 字面量类型，就只能赋值为 <code>'Sherlock'</code>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">'ease-in'</span> | <span class="string">'ease-out'</span> | <span class="string">'ease-in-out'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIElement</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">animate</span>(<span class="params">dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing</span>)</span> {</span><br><span class="line">      <span class="keyword">if</span> (easing === <span class="string">'ease-in'</span>) {}</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">'ease-out'</span>) {}</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">'ease-in-out'</span>) {}</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// Error, 不应该传递 null 或 undefined</span></span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement()</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'ease-in'</span>)</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'uneasy'</span>) <span class="comment">// Error, 'uneasy' 不被允许</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，通过类型别名，声明了类型 <code>Easing</code> 为 <code>'ease-in' | 'ease-out' | 'ease-in-out'</code><br>这样三个字符串字面量构成的联合类型。</p><p>第 4 行，你<strong>只能</strong>从三种允许的字符中选择<strong>其一</strong>来做为参数传递，传入其它值则会产生错误。</p><p>字符串字面量类型还可以用于区分函数重载：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="string">'img'</span></span>): <span class="title">HTMLImageElement</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="string">'input'</span></span>): <span class="title">HTMLInputElement</span></span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="built_in">string</span></span>): <span class="title">Element</span> </span>{}</span></span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>如果参数 tagName 为 <code>'img'</code> 类型，返回值类型为 <code>HTMLImageElement</code>; 如果参数 tagName 为 <code>'input'</code> 类型，返回值类型为 <code>HTMLInputElement</code>。</p><h3 id="布尔字面量类型"><a href="#布尔字面量类型" class="headerlink" title="布尔字面量类型"></a>布尔字面量类型</h3><p>声明布尔字面量类型，注意这里是 <code>:</code> 不是 <code>=</code>。 <code>=</code> 等号是变量赋值，<code>:</code> 表示声明的类型。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> success: <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> fail: <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> value: <span class="literal">true</span> | <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>接口的返回值，会有正确返回和异常两种情况，这两种情况要有不同的数据返回格式：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result = { <span class="attr">success</span>: <span class="literal">true</span>, <span class="attr">code</span>: <span class="built_in">number</span>, <span class="attr">object</span>: <span class="built_in">object</span> } | { <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">code</span>: <span class="built_in">number</span>, <span class="attr">errMsg</span>: <span class="built_in">string</span> }</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res: Result = { <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">code</span>: <span class="number">90001</span>, <span class="attr">errMsg</span>: <span class="string">'该二维码已使用'</span> }</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!res.success) {</span><br><span class="line">  res.errMsg <span class="comment">// OK</span></span><br><span class="line">  res.object <span class="comment">// Error, Property 'object' does not exist on type '{ success: false; code: number; errMsg: string; }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>类型别名 Result 是一个由两个对象组成的联合类型，都有一个共同的 success 属性，这个属性的类型就是布尔字面量类型。因为涉及很多后续才会介绍的知识点，这里看不懂没关系，只需要大概了解这是布尔字面量类型的一种应用即可。</p><h3 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h3><p>TypeScript 还具有数字字面量类型。</p><p>比如骰子只有六种点数：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> die: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span></span><br><span class="line"></span><br><span class="line">die = <span class="number">9</span> <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure><h2 id="TypeScript-类型推断"><a href="#TypeScript-类型推断" class="headerlink" title="TypeScript 类型推断"></a>TypeScript 类型推断</h2><p>TypeScript 类型检查机制包含三个部分：</p><ul><li>类型推断</li><li>类型保护</li><li>类型兼容性</li></ul><p>类型推断的含义是不需要指定变量类型或函数的返回值类型，TypeScript 可以根据一些简单的规则推断其的类型。</p><h3 id="基础类型推断"><a href="#基础类型推断" class="headerlink" title="基础类型推断"></a>基础类型推断</h3><p>基础的类型推断发生在 <strong>初始化变量，设置默认参数和决定返回值时。</strong></p><p><strong>初始化变量例子：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>             <span class="comment">// let x: number</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">'hello world'</span> <span class="comment">// let y: string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> z                 <span class="comment">// let z: any</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>变量 <code>x</code> 的类型被推断为数字，变量 <code>y</code> 的类型被推断为字符串。如果定义时没有赋值，将被推断为 any 类型。</p><p>设置默认参数和决定返回值时的例子：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值推断为 number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a:<span class="built_in">number</span>, b:<span class="number">10</span></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="string">'hello world'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">15</span> <span class="comment">// Error，Type '15' is not assignable to type 'string'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，参数 b 有默认值 10，被推断为 number 类型。</p><p>第 2 行，两个 number 类型相加，函数 <code>add()</code> 返回值被推断为 number 类型。</p><p>最后一行，<code>obj</code> 的类型被推断为 <code>{a: number, b: string}</code>，所以属性 b 不能被赋值为数字。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  protagonist: <span class="string">'Sherlock'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> { protagonist } = obj</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 通过解构赋值也可以完成正确的类型推断：<code>let protagonist: string</code>。</p><h3 id="最佳通用类型推断"><a href="#最佳通用类型推断" class="headerlink" title="最佳通用类型推断"></a>最佳通用类型推断</h3><p>当需要从多个元素类型推断出一个类型时，TypeScript 会尽可能推断出一个兼容所有类型的通用类型。</p><p>比如声明一个数组：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">1</span>, <span class="string">'imooc'</span>, <span class="literal">null</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 为了推断 <code>x</code> 的类型，必须考虑所有的元素类型。这里有三种元素类型 number、string 和 null，此时数组被推断为 <code>let x: (string | number | null)[]</code> 联合类型。</p><blockquote><p><strong>Tip：</strong> 是否兼容 null 类型可以通过 tsconfig.json 文件中属性 <code>strictNullChecks</code> 的值设置为 true 或 false 来决定。</p></blockquote><h3 id="4-上下文类型推断"><a href="#4-上下文类型推断" class="headerlink" title="4. 上下文类型推断"></a>4. 上下文类型推断</h3><p><strong>前面两种都是根据从右向左流动进行类型推断，上下文类型推断则是从左向右的类型推断。</strong></p><p>例如定义一个 <code>Animal</code> 的类作为接口使用：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> species: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">public</span> weight: <span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> simba: Animal = {</span><br><span class="line">  species: <span class="string">'lion'</span>,</span><br><span class="line">  speak: <span class="literal">true</span>  <span class="comment">// Error, 'speak' does not exist in type 'Animal'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 第 6 行，将 <code>Animal 类型</code>显示的赋值给 <code>变量 simba</code>，<code>Animal 类型</code> 没有 <code>speak 属性</code>，所以不可赋值。</p><h2 id="TypeScript-类型断言"><a href="#TypeScript-类型断言" class="headerlink" title="TypeScript 类型断言"></a>TypeScript 类型断言</h2><p>本节介绍类型断言，有使用关键字 <code>as</code> 和标签 <code>&lt;&gt;</code> 两种方式，因后者会与<code>JSX</code> 语法冲突，建议统一使用 <code>as</code> 来进行类型断言。</p><p>TypeScript 允许你覆盖它的推断，毕竟作为开发者你比编译器更了解你写的代码。</p><p>类型断言主要用于当 TypeScript 推断出来类型并不满足你的需求，你需要手动指定一个类型。</p><h3 id="关键字-as"><a href="#关键字-as" class="headerlink" title="关键字 as"></a>关键字 as</h3><p>当你把 JavaScript 代码迁移到 TypeScript 时，一个常见的问题：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = {}</span><br><span class="line"></span><br><span class="line">user.nickname = <span class="string">'Evan'</span>  <span class="comment">// Error, Property 'nickname' does not exist on type '{}'</span></span><br><span class="line">user.admin = <span class="literal">true</span>       <span class="comment">// Error, Property 'admin' does not exist on type '{}'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 编译器推断 <code>const user: {}</code>，这是一个没有属性的对象，所以你不能对其添加属性。</p><p>此时可以使用类型断言（<em>as关键字</em>）覆盖其类型推断：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User {</span><br><span class="line">  nickname: <span class="built_in">string</span>,</span><br><span class="line">  admin: <span class="built_in">boolean</span>,</span><br><span class="line">  groups: <span class="built_in">number</span>[]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = {} <span class="keyword">as</span> User</span><br><span class="line"></span><br><span class="line">user.nickname = <span class="string">'Evan'</span> </span><br><span class="line">user.admin = <span class="literal">true</span>       </span><br><span class="line">user.groups = [<span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 7 行，这里通过 <code>as</code> 关键字进行类型断言，将变量 <code>user</code> 的类型覆盖为 <code>User</code> 类型。<strong>但是请注意，类型断言不要滥用，除非你完全明白你在干什么。</strong></p><h3 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言 !"></a>非空断言 !</h3><p>如果编译器不能够去除 null 或 undefined，可以使用非空断言 <code>!</code> 手动去除。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> name!.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet; <span class="comment">// name 被断言为非空</span></span><br><span class="line">  }</span><br><span class="line">  name = name || <span class="string">"Bob"</span></span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">"great"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，<code>postfix()</code> 是一个嵌套函数，因为编译器无法去除嵌套函数的 null (除非是立即调用的函数表达式)，所以 TypeScript 推断第 3 行的 <code>name</code> 可能为空。</p><p>第 5 行，而 <code>name = name || "Bob"</code> 这行代码已经明确了 <code>name</code> 不为空，所以可以直接给 name 断言为非空（第 3 行）。</p><h3 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h3><p>双重断言极少有应用场景，只需要知道有这种操作即可：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User {</span><br><span class="line">  nickname: <span class="built_in">string</span>,</span><br><span class="line">  admin: <span class="built_in">boolean</span>,</span><br><span class="line">  group: <span class="built_in">number</span>[]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="string">'Evan'</span> <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> User</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 最后一行，使用 as 关键字进行了两次断言，最终变量 user 被强制转化为 User 类型。</p><h2 id="TypeScript-类型保护"><a href="#TypeScript-类型保护" class="headerlink" title="TypeScript 类型保护"></a>TypeScript 类型保护</h2><p>类型保护是指缩小类型的范围，在一定的块级作用域内由编译器推导其类型，提示并规避不合法的操作。</p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>通过 <code>typeof</code> 运算符判断变量类型，下面看一个之前介绍函数重载时的例子：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">target: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'string'</span>) {</span><br><span class="line">    target.toFixed(<span class="number">2</span>) <span class="comment">// Error，在这个代码块中，target 是 string 类型，没有 toFixed 方法</span></span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'number'</span>) {</span><br><span class="line">    target.toFixed(<span class="number">2</span>) <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">return</span> +[...target.toString()].reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  target.forEach(<span class="function"><span class="params">element</span> =&gt;</span> {}) <span class="comment">// Error，在这个代码块中，target 是 string 或 number 类型，没有 forEach 方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，通过 typeof 关键字，将这个代码块中变量 target 的类型限定为 string 类型。</p><p>第 6 行，通过 typeof 关键字，将这个代码块中变量 target 的类型限定为 number 类型。</p><p>第 11 行，因没有限定，在这个代码块中，变量 target 是 string 或 number 类型，没有 forEach 方法，所以报错。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 与 typeof 类似，区别在于 typeof 判断基础类型，instanceof 判断是否为某个对象的实例：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> nickname: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">public</span> group: <span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> count: <span class="built_in">number</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">public</span> keyword: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeGuard</span>(<span class="params">arg: User | Log</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> User) {</span><br><span class="line">    arg.count = <span class="number">15</span> <span class="comment">// Error, User 类型无此属性</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Log) {</span><br><span class="line">    arg.count = <span class="number">15</span> <span class="comment">// OK</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 12 行，通过 instanceof 关键字，将这个代码块中变量 arg 的类型限定为 User 类型。</p><p>第 16 行，通过 instanceof 关键字，将这个代码块中变量 arg 的类型限定为 Log 类型。</p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p><code>in</code> 操作符用于确定属性是否存在于某个对象上，这也是一种缩小范围的类型保护。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> nickname: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">public</span> groups!: <span class="built_in">number</span>[]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> count: <span class="built_in">number</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">public</span> keyword: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeGuard</span>(<span class="params">arg: User | Log</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'nickname'</span> <span class="keyword">in</span> arg) {</span><br><span class="line">    <span class="comment">// (parameter) arg: User，编辑器将推断在当前块作用域 arg 为 User 类型</span></span><br><span class="line">    arg.nickname = <span class="string">'imooc'</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'count'</span> <span class="keyword">in</span> arg) {</span><br><span class="line">    <span class="comment">// (parameter) arg: Log，编辑器将推断在当前块作用域 arg 为 Log 类型</span></span><br><span class="line">    arg.count = <span class="number">15</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 12 行，通过 in 关键字，将这个代码块中变量 arg 的类型限定为 User 类型。</p><p>第 17 行，通过 in 关键字，将这个代码块中变量 arg 的类型限定为 Log 类型。</p><h3 id="字面量类型保护"><a href="#字面量类型保护" class="headerlink" title="字面量类型保护"></a>字面量类型保护</h3><p>用字面量类型那一节的例子改造一下来介绍字面量类型保护：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Success = {</span><br><span class="line">  success: <span class="literal">true</span>,</span><br><span class="line">  code: <span class="built_in">number</span>,</span><br><span class="line">  <span class="built_in">object</span>: <span class="built_in">object</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fail = {</span><br><span class="line">  success: <span class="literal">false</span>,</span><br><span class="line">  code: <span class="built_in">number</span>,</span><br><span class="line">  errMsg: <span class="built_in">string</span>,</span><br><span class="line">  request: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg: Success | Fail</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (arg.success === <span class="literal">true</span>) {</span><br><span class="line">    <span class="built_in">console</span>.log(arg.object) <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.errMsg) <span class="comment">// Error, Property 'errMsg' does not exist on type 'Success'</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(arg.errMsg) <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.object) <span class="comment">// Error, Property 'object' does not exist on type 'Fail'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 15 行，通过布尔字面量，将这个代码块中变量 arg 的类型限定为 Success 类型。</p><p>第 18 行，通过布尔字面量，将这个代码块中变量 arg 的类型限定为 Fail 类型。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS linear-gradient函数</title>
      <link href="2021/04/24/linear-gradient/"/>
      <url>2021/04/24/linear-gradient/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS-linear-gradient的介绍和在实际项目中的使用"><a href="#CSS-linear-gradient的介绍和在实际项目中的使用" class="headerlink" title="CSS: linear-gradient的介绍和在实际项目中的使用"></a>CSS: linear-gradient的介绍和在实际项目中的使用</h1><p>linear-gradient函数是CSS3中的一些新特性,最近在学习CSS揭秘这本书中一开始就接触到了这个属性,以前接触的实在不多,CSS揭秘上对这两个属性的运用又让我大开眼界,于是写篇文章好好学习一下</p><h2 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h2><p>CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()"><code>linear-gradient&nbsp;</code></a>函数用于创建一个表示两种或多种颜色线性见表的图片</p><p><code>linear-gradient</code>函数接收三个值: </p><p><code>&lt;side-or-corner&gt;</code></p><p>​    描述渐变线的起始点位置。它包含<strong>to</strong>和两个关键词：第一个指出水平位置<strong>left or right</strong>，第二个指出垂直位置<strong>top or bottom</strong>。关键词的先后顺序无影响，且都是可选的。</p><p>​    to top, to bottom, to left 和 to right这些值会被转换成角度<strong>0度、180度、270度和90度</strong>。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。</p><p><code>&lt;angle&gt;</code></p><p>​    用角度值指定渐变的方向（或角度）。角度顺时针增加。 </p><p><code>&lt;linear-color-stop&gt;</code></p><p>​    由一个color值组成，并且跟随着一个可选的<strong>终点位置</strong>（可以是一个<strong>百分比值</strong>或者是沿着渐变轴的<strong>length</strong>。CSS渐变的颜色渲染采取了与<strong>SVG相同</strong>的规则。</p><p><code>&lt;color-hint&gt;</code></p><p>​    颜色中转点是一个插值提示，它定义了在相邻颜色之间渐变如何进行。长度定义了在两种颜色之间的哪个点停止渐变颜色应该达到颜色过渡的中点。如果省略，颜色转换的中点是两个颜色停止之间的中点。 </p><p>听起来很复杂，看几个例子就明白了</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red, yellow, blue);</span><br><span class="line">    <span class="comment">/*等价于*/</span></span><br><span class="line">    <span class="comment">/*background: linear-gradient(180deg, red, yellow, blue)*/</span></span><br><span class="line">    <span class="comment">/*background: linear-gradient(to bottom, red, yellow, blue)*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424133125189.png" alt="image-20210424133125189"></p><p>可以看到，实现了从<code>red -&gt; yellow -&gt; blue</code>的线性渐变，且渐变角度从上到下，也就是从<strong>180deg到0deg</strong>，即默认情况下，第一个参数等于<strong>180deg</strong></p><p>现在改变一下角度试试:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">0deg</span>, red, yellow, blue);</span><br><span class="line">    <span class="comment">/*等价于*/</span></span><br><span class="line">    <span class="comment">/*background: linear-gradient(to top, red, yellow, blue)*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424133512095.png" alt="image-20210424133512095"></p><p>可以看到，图片完完全全的倒立过来了</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, red, yellow, blue)</span><br><span class="line">    /*等价于*/</span><br><span class="line">    /*background: <span class="built_in">linear-gradient</span>(to right top, red, yellow, blue)*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424133802029.png" alt="image-20210424133802029"></p><p>由此可以看出，<code>linear-gradient</code>中图片角度的规律</p><p><img src="/images/artical-image/image-20210424134420095.png" alt="image-20210424134420095"></p><p>除此之外，颜色的每个值都可以设置终止位置</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red <span class="number">0%</span>, orange <span class="number">25%</span>, yellow <span class="number">50%</span>, green <span class="number">75%</span>, blue <span class="number">100%</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424135509560.png" alt="image-20210424135509560"></p><p>当然也可以使用<code>px</code></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red <span class="number">50px</span>, orange <span class="number">100px</span>, yellow <span class="number">150px</span>, green <span class="number">180px</span>, blue)</span><br><span class="line">   /*最后一个默认为终点位置*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424135947658.png" alt="image-20210424135947658"></p><blockquote><p>需要注意的是，当你生命了<code>linear-gradient</code>中的颜色属性后，再添加<code>background-color</code>或者向<code>background</code>中添加颜色是无效的，因为linear-gradient的颜色把原来的背景颜色全部覆盖了，但把<code>color</code>值设为<code>tranparent</code>能显示回原来的颜色，也就是你用<code>background-color</code>设置的颜色</p></blockquote><p>那我们怎样在项目中去<strong>合理</strong>的应用这个属性呢?</p><p>举个简单的例子，当我们创建一个按钮</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#446d88</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> gray;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -<span class="number">0.05em</span> <span class="number">0.05em</span> <span class="number">#335166</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424141714525.png" alt="image-20210424141714525"></p><p>现在给这个按钮添加换一个渐变背景</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#446d88</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#77a0bb</span>, <span class="number">#58a</span>);</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> gray;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -<span class="number">0.05em</span> <span class="number">0.05em</span> <span class="number">#335166</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424141930939.png" alt="image-20210424141930939"></p><p>到这里，一个简单的有<strong>质感</strong>的按钮就完成了</p><p>但到这里仍存在一些问题，按钮是在项目中经常重复用到的部分，假如现在我们要创建一个红色按钮或者黄色按钮，该怎么办呢?</p><p>我们可能需要覆盖四条属性，<code>border-color</code>，<code>text-shadow</code>，<code>box-shadow</code>，<code>background</code>，因为颜色变了后这些属性都要跟着改变，而且，确定一个颜色的<strong>渐变</strong>效果需要知道这个颜色的<strong>亮色</strong>和<strong>暗色</strong>版本(例如上面的按钮就需要知道<code>#58a</code>和<code>#77a0bb</code>)，并且如果按钮放在一个<strong>非纯白色背景</strong>上呢，例如放到<code>gray</code>背景里</p><p><img src="/images/artical-image/image-20210424143615958.png" alt="image-20210424143615958"></p><p>此时<code>box-shadow: gray</code>属性明显就不能体现出来该有的效果</p><p>那有没有方法能一次性解决上面的问题又更加简洁呢，<code>linear-gradient</code>可以派上用场了，用<code>linear-gradient</code>设置一个<strong>半透明的白色</strong>作为主色调就能解决这个难题</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>);</span><br><span class="line">        <span class="attribute">background</span>:   <span class="number">#58a</span> <span class="built_in">linear-gradient</span>(<span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">100%</span>, .<span class="number">5</span>), transparent);;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -.<span class="number">05em</span> .<span class="number">05em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424151914438.png" alt="image-20210424151914438"></p><p>现在，我们只需要改变<code>background-color</code>就能得到不同颜色的<strong>渐变按钮</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>);</span><br><span class="line">        <span class="attribute">background</span>:   <span class="number">#58a</span> <span class="built_in">linear-gradient</span>(<span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">100%</span>, .<span class="number">5</span>), transparent);;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -.<span class="number">05em</span> .<span class="number">05em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-class">.cancel</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424160249913.png" alt="image-20210424160249913"></p><p>这就是<code>linear-gradient</code>在实际项目中的一个小应用，也是我读<a href="https://www.ituring.com.cn/book/1695">Css揭秘</a>这本书学到的一个有用的知识。</p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

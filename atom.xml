<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaoyao日志</title>
  
  <subtitle>努力且幸运</subtitle>
  <link href="https://yjunuser.github.io/atom.xml" rel="self"/>
  
  <link href="https://yjunuser.github.io/"/>
  <updated>2021-04-27T01:33:14.610Z</updated>
  <id>https://yjunuser.github.io/</id>
  
  <author>
    <name>姚伯骏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue父组件传递props异步数据到子组件遇到的问题</title>
    <link href="https://yjunuser.github.io/2021/04/27/vue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92props%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
    <id>https://yjunuser.github.io/2021/04/27/vue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92props%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6/</id>
    <published>2021-04-26T16:00:00.000Z</published>
    <updated>2021-04-27T01:33:14.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue父组件传递props异步数据到子组件遇到的问题"><a href="#vue父组件传递props异步数据到子组件遇到的问题" class="headerlink" title="vue父组件传递props异步数据到子组件遇到的问题"></a>vue父组件传递props异步数据到子组件遇到的问题</h1><p>父组件<code>parent.vue</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// asyncData为异步获取的数据，想传递给子组件使用</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  父组件</span><br><span class="line">  &lt;child :child-data="asyncData"&gt;&lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import child from '../demo/children.vue'</span><br><span class="line"> export default {</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">   asyncData: ''</span><br><span class="line">  }),</span><br><span class="line">  components: {</span><br><span class="line">   child</span><br><span class="line">  },</span><br><span class="line">  created () {</span><br><span class="line">  },</span><br><span class="line">  mounted () {</span><br><span class="line">   // setTimeout模拟异步数据</span><br><span class="line">   setTimeout(() =&gt; {</span><br><span class="line">    this.asyncData = ' async data'</span><br><span class="line">    console.log('parent 组件结束')</span><br><span class="line">   }, 2000)</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h2><p>子组件<code>child.vue</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件{{childData}}</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childData'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">   console.log("子组件created-----   "+this.childData) // 空值</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>在这种情况下，子组件中<code>html</code>中的<code>{{childData}}</code>值会随着父组件传过来的值而改变，这是<strong>数据的响应式变化</strong>（数据的改变会引起界面变化)，但子组件<code>created</code>函数中是<strong>拿不到父组件异步传过来的数据</strong>的，这是生命周期问题。</p><h2 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h2><p>子组件<code>child.vue</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件&lt;!--这里很常见的一个问题，就是childData可以获取且没有报错，但是childData.items[0]不行，往往有个疑问为什么前面获取到值，后面获取不到呢？--&gt;</span><br><span class="line">  &lt;p&gt;{{childData.items[0]}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childData'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">   console.log(this.childData) // 空值</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><code>created</code>里面的仍然是空值， 子组件的<code>html</code>中的<code>{{childObject.items[0]}}</code>的值虽然会随着父组件的值而改变，但是过程中会报错。</p><p>是因为：<strong>首先传过来的是空，然后再异步刷新值</strong>，也就是开始时候<code>childObject.items[0]</code>等同于<code>''.item[0]</code>这样的操作，<br> 所以就会报下面的错：</p><p><img src="../images/artical-image/9441048-d1a7779ec4be1599" alt="img"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p>使用<code>v-if</code>可以解决报错问题和<code>created</code>为空问题</p><p>父组件<code>parent</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  父组件</span><br><span class="line">  &lt;child :child-object="asyncObject"  v-if="flag"&gt;&lt;/child&gt;</span><br><span class="line">  &lt;!--没拿到数据前，不渲染子组件，这样子组件created生命周期就能拿到数据了--&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from '../demo1/children.vue'</span><br><span class="line"> export default {</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">   asyncObject: '',</span><br><span class="line">   flag:false</span><br><span class="line">  }),</span><br><span class="line">  components: {</span><br><span class="line">   child</span><br><span class="line">  },</span><br><span class="line">  created () {</span><br><span class="line">  },</span><br><span class="line">  mounted () {</span><br><span class="line">   // setTimeout模拟异步数据</span><br><span class="line">   setTimeout(() =&gt; {</span><br><span class="line">    this.asyncObject = {'items': [1, 2, 3]}</span><br><span class="line">    this.flag= true</span><br><span class="line">    console.log('parent 结束')</span><br><span class="line">   }, 2000)</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>子页面 children</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件</span><br><span class="line">  &lt;p&gt;{{childObject.items[0]}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childObject'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">    console.log("子组件create-----"+JSON.stringify(this.childObject)) //能拿到了</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><img src="../images/artical-image/9441048-47f9515b58d48759" alt="img"></p></li><li><p>子组件使用<code>watch</code>来监听父组件改变的<code>prop</code>，使用<code>methods</code>来代替<code>created</code></p><p>子组件 children</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  &lt;p&gt;{{test}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childObject'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">       test: ''</span><br><span class="line">  }),</span><br><span class="line">   watch: {</span><br><span class="line">     'childObject.items': function (new, old) { // 直接监听childObject.item属性</span><br><span class="line">      this.test = new[0]</span><br><span class="line">      this.updata()</span><br><span class="line">     }</span><br><span class="line">    },</span><br><span class="line">  methods: {</span><br><span class="line">     updata () { // 既然created只会执行一次，但是又想监听改变的值做其他事情的话，只能搬到这里咯</span><br><span class="line">      console.log(this.test)// 1</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>子组件<code>watch computed data</code> 相结合(麻烦，不推荐)</p><p>子组件children</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   &lt;p&gt;{{test}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">    props: ['childObject'],</span><br><span class="line">    data: () =&gt; ({</span><br><span class="line">     test: ''</span><br><span class="line">    }),</span><br><span class="line">    watch: {</span><br><span class="line">     'childObject.items': function (n, o) {</span><br><span class="line">      this._test = n[0]</span><br><span class="line">     }</span><br><span class="line">    },</span><br><span class="line"> computed: {</span><br><span class="line">    _test: {</span><br><span class="line">     set (value) {</span><br><span class="line">      this.update()</span><br><span class="line">      this.test = value</span><br><span class="line">     },</span><br><span class="line">     get () {</span><br><span class="line">      return this.test</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   },</span><br><span class="line">  methods: {</span><br><span class="line">   update () {</span><br><span class="line">      console.log(this.childObject) // {items: [1,2,3]}</span><br><span class="line">     }</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用<code>prop default</code>来解决<code>{{childObject.items[0]}}</code></p><p>父组件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  父组件</span><br><span class="line">  &lt;child :child-object="asyncObject"&gt;&lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import child from  '../demo4/children.vue'</span><br><span class="line"> export default {</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">   asyncObject: undefined // 这里使用null反而报0的错</span><br><span class="line">  }),</span><br><span class="line">  components: {</span><br><span class="line">   child</span><br><span class="line">  },</span><br><span class="line">  created () {</span><br><span class="line">  },</span><br><span class="line">  mounted () {</span><br><span class="line">   // setTimeout模拟异步数据</span><br><span class="line">   setTimeout(() =&gt; {</span><br><span class="line">    this.asyncObject = {'items': [1, 2, 3]}</span><br><span class="line">    console.log('parent finish')</span><br><span class="line">   }, 2000)</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>子组件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件&lt;!--1--&gt;</span><br><span class="line">  &lt;p&gt;{{childObject.items[0]}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: {</span><br><span class="line">   childObject: {</span><br><span class="line">    type: Object,</span><br><span class="line">    default () {</span><br><span class="line">     return {</span><br><span class="line">      items: ''</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   }</span><br><span class="line">  },</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">   console.log(this.childObject) // {item: ''}</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue父组件传递props异步数据到子组件遇到的问题&quot;&gt;&lt;a href=&quot;#vue父组件传递props异步数据到子组件遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;vue父组件传递props异步数据到子组件遇到的问题&quot;&gt;&lt;/a&gt;vue父组件传递</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://yjunuser.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript安装和使用</title>
    <link href="https://yjunuser.github.io/2021/04/26/TypeScript%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://yjunuser.github.io/2021/04/26/TypeScript%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2021-04-26T08:36:43.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript安装和使用"><a href="#TypeScript安装和使用" class="headerlink" title="TypeScript安装和使用"></a>TypeScript安装和使用</h1><p><code>npm install typescript -g</code> 全局安装</p><p>使用有两种方式:</p><ul><li>tsc直接编译一个<code>.ts</code>文件，生产<code>.js</code>文件</li><li>在项目中编译，通过<code>npm run tsc</code>实现对整个项目编译</li></ul><p>在ts-practice文件夹下新建一个src目录，src目录下新建一个index.ts文件</p><p>index.ts里写入如下内容:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> TokenType {</span><br><span class="line">    ACCESS = <span class="string">'accessToken'</span>,</span><br><span class="line">    REFRESH = <span class="string">'refreshToken'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用<code>npm init</code>初始化项目，生成了<code>package.json</code>文件，在<code>package.json</code>文件的scripts标签里写入：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": {</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "tsc": "tsc"</span><br><span class="line">  }，</span><br><span class="line">"main": "src/index.ts"</span><br></pre></td></tr></tbody></table></figure><p>然后，用<code>tsc --init</code>命令进行初始化</p><p>这时候目录下多了一个<code>tsconfig.js</code>文件，它<strong>指定了用来编译这个项目的根文件和编译选项</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: {</span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="comment">// "incremental": true,                         /* Enable incremental compilation */</span></span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,                                <span class="comment">/* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */</span></span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,                           <span class="comment">/* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */</span></span><br><span class="line">    <span class="comment">// "lib": [],                                   /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="comment">// "allowJs": true,                             /* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="comment">// "checkJs": true,                             /* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// "jsx": "preserve",                           /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */</span></span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>,                         <span class="comment">/* Generates corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "declarationMap": true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "sourceMap": true,                           /* Generates corresponding '.map' file. */</span></span><br><span class="line">    <span class="comment">// "outFile": "./",                             /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./lib"</span>,                              <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"./src"</span>,                             <span class="comment">/* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// "composite": true,                           /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// "tsBuildInfoFile": "./",                     /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="comment">// "removeComments": true,                      /* Do not emit comments to output. */</span></span><br><span class="line">    <span class="comment">// "noEmit": true,                              /* Do not emit outputs. */</span></span><br><span class="line">    <span class="comment">// "importHelpers": true,                       /* Import emit helpers from 'tslib'. */</span></span><br><span class="line">    <span class="comment">// "downlevelIteration": true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */</span></span><br><span class="line">    <span class="comment">// "isolatedModules": true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,                                 <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="comment">// "noImplicitAny": true,                       /* Raise error on expressions and declarations with an implied 'any' type. */</span></span><br><span class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">false</span>,                    <span class="comment">/* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// "strictFunctionTypes": true,                 /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// "strictBindCallApply": true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */</span></span><br><span class="line">    <span class="comment">// "strictPropertyInitialization": true,        /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="attr">"noImplicitThis"</span>: <span class="literal">true</span>,                      <span class="comment">/* Raise error on 'this' expressions with an implied 'any' type. */</span></span><br><span class="line">    <span class="comment">// "alwaysStrict": true,                        /* Parse in strict mode and emit "use strict" for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// "noUnusedLocals": true,                      /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// "noUnusedParameters": true,                  /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// "noImplicitReturns": true,                   /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// "noFallthroughCasesInSwitch": true,          /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line">    <span class="comment">// "noUncheckedIndexedAccess": true,            /* Include 'undefined' in index signature results */</span></span><br><span class="line">    <span class="comment">// "noPropertyAccessFromIndexSignature": true,  /* Require undeclared properties from index signatures to use element accesses. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// "moduleResolution": "node",                  /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// "baseUrl": "./",                             /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// "paths": {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */</span></span><br><span class="line">    <span class="comment">// "rootDirs": [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// "typeRoots": [],                             /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// "types": [],                                 /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// "allowSyntheticDefaultImports": true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,                        <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */</span></span><br><span class="line">    <span class="comment">// "preserveSymlinks": true,                    /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// "allowUmdGlobalAccess": true,                /* Allow accessing UMD globals from modules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// "sourceRoot": "",                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// "mapRoot": "",                               /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// "inlineSourceMap": true,                     /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// "inlineSources": true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// "experimentalDecorators": true,              /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// "emitDecoratorMetadata": true,               /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">"skipLibCheck"</span>: <span class="literal">true</span>,                           <span class="comment">/* Skip type checking of declaration files. */</span></span><br><span class="line">    <span class="attr">"forceConsistentCasingInFileNames"</span>: <span class="literal">true</span>        <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>, <span class="string">"lib"</span>, <span class="string">"**/*.test.ts"</span>],</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src"</span>]</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>执行<code>npm install</code>下载项目所需的依赖，<code>node_modules</code>是项目的所有依赖包，<code>package-lock.json</code>文件将项目依赖包的版本锁定，避免<strong>依赖包大升级造成的不兼容问题</strong>。</p><p>在根目录执行<code>npm run tes</code></p><p><img src="E:\blog\hexo-blog\source\images\artical-image\image-20210426163128179.png" alt="image-20210426163128179"></p><p>得到编译后结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript安装和使用&quot;&gt;&lt;a href=&quot;#TypeScript安装和使用&quot; class=&quot;headerlink&quot; title=&quot;TypeScript安装和使用&quot;&gt;&lt;/a&gt;TypeScript安装和使用&lt;/h1&gt;&lt;p&gt;&lt;code&gt;npm install </summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="https://yjunuser.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript基础类型</title>
    <link href="https://yjunuser.github.io/2021/04/26/TypeScript%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    <id>https://yjunuser.github.io/2021/04/26/TypeScript%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2021-04-27T03:44:57.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-基础类型"><a href="#TypeScript-基础类型" class="headerlink" title="TypeScript 基础类型"></a>TypeScript 基础类型</h1><p>TypeScript 中的类型有</p><blockquote><p>TypeScript中的基础类型都是小写，大写开头的表示的是javascript的构造函数</p></blockquote><ul><li>原始类型<ul><li>boolean</li><li>number</li><li>string</li><li>bigint</li><li>null</li><li>undefined</li><li>symbol</li><li>void</li></ul></li><li>元组 tuple</li><li>枚举 enum</li><li>任意 any</li><li>unknown</li><li>never</li><li>数组 Array</li><li>对象 object</li></ul><h2 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h2><p>当一个函数没有返回值时，可以声明为void</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>(<span class="params"></span>): <span class="title">void</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还可以声明一个<code>void</code>类型的变量，但只能赋值为<code>undefined</code>或者<code>null</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nothing: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><h2 id="null-类型和-undefined-类型"><a href="#null-类型和-undefined-类型" class="headerlink" title="null 类型和 undefined 类型"></a>null 类型和 undefined 类型</h2><p><code>undefined</code> 和 <code>null</code> 是<strong>所有类型的子类型</strong>。</p><p>一般项目是默认开启 <code>--strictNullChecks</code> 检测的，如果你将 <code>tsconfig.json</code> 中 <code>strictNullChecks</code> 选项设置为 <code>false</code>，下面这种操作不会报错，不过尽量不要这么做：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>数组类型有两种表示方法，第一种在元素类型后接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> names: <span class="built_in">string</span>[] = [<span class="string">'Sherlock'</span>, <span class="string">'Watson'</span>, <span class="string">'Mrs. Hudson'</span>]</span><br></pre></td></tr></tbody></table></figure><p>另一种方式是使用数组泛型（<em>泛型后续会单独介绍</em>），<code>Array&lt;元素类型&gt;</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'Sherlock'</span>, <span class="string">'Watson'</span>, <span class="string">'Mrs. Hudson'</span>]</span><br></pre></td></tr></tbody></table></figure><p>混合各种元素类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br></pre></td></tr></tbody></table></figure><p>推荐使用第一种数组类型的表示方法，书写比较简洁直观。</p><h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>有时候接收来自用户的输入，我们是不能确定其变量类型的。这种情况下，我们不希望类型检查器对这些值进行检查，而是直接让它们通过编译阶段的检查，此时可以使用 <code>any</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input: <span class="built_in">any</span> = <span class="string">'nothing'</span></span><br><span class="line"></span><br><span class="line">input = <span class="number">0</span>                   <span class="comment">// ok</span></span><br><span class="line">input = <span class="literal">true</span>                <span class="comment">// ok</span></span><br><span class="line">input = []                  <span class="comment">// ok</span></span><br><span class="line">input = <span class="literal">null</span>                <span class="comment">// ok</span></span><br><span class="line">input = <span class="built_in">Symbol</span>(<span class="string">'any'</span>)       <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure><p>如果一个数据是 any 类型，那么可以访问它的任意属性，即使这个属性不存在：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anything: <span class="built_in">any</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">anything.eat()              <span class="comment">// ok</span></span><br><span class="line">anything.name               <span class="comment">// ok</span></span><br><span class="line">anything[<span class="number">0</span>]                 <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">new</span> anything()              <span class="comment">// ok</span></span><br><span class="line">anything()                  <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure><p>从上面的例子中可以看到，any 类型几乎可以做任何操作，这样很容易编写类型正确但是执行异常的代码。我们使用 TypeScript 就是为了代码的健壮性，所以要<strong>尽量减少 any 的使用</strong>。</p><blockquote><p>any类型很像在javascript直接定义一个变量</p></blockquote><h2 id="容易混淆的点"><a href="#容易混淆的点" class="headerlink" title="容易混淆的点"></a>容易混淆的点</h2><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">Number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">'10'</span>) <span class="comment">// a === 10 为 false</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">number</span> = <span class="built_in">Number</span>(<span class="string">'10'</span>) <span class="comment">// b === 10 为 true</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，通过 <code>new Number('10')</code> 得到的是<strong>一个构造函数，本质是一个对象</strong>。</p><p>第 2 行，<code>Number('10')</code> 与 <code>10</code> 都是声明一个数字 10 的方法，本质就是一个数字。</p><p>第 4 - 5 行，<code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。<code>a</code> 是一个对象，它的 <code>__proto__</code> 属性指向该对象的构造函数的原型对象 <code>Number</code>，所以为 <code>true</code>。<code>b</code> 是一个数字，所以为 <code>false</code>。</p><p><code>__proto__</code> 是非标准属性，你也可以使用 <strong><code>Object.getPrototypeOf()</code></strong> 方法来访问一个对象的原型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__ === <span class="built_in">Object</span>.getPrototypeOf(a) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h2 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h2><p><code>bigint</code> 是一种基本数据类型（primitive data type）。</p><p>JavaScript 中可以用 <code>Number</code> 表示的最大整数为 <code>2^53 - 1</code>，可以写为 <code>Number.MAX_SAFE_INTEGER</code>。如果超过了这个界限，可以用 <code>BigInt</code>来表示，它可以表示任意大的整数。</p><p>在一个整数字面量后加 <code>n</code> 的方式定义一个 <code>BigInt</code>，如：<code>10n</code> 或者调用函数 <code>BigInt()</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theBiggestInt: bigint = <span class="number">9007199254740991n</span></span><br><span class="line"><span class="keyword">const</span> alsoHuge: bigint = <span class="built_in">BigInt</span>(<span class="number">9007199254740991</span>)</span><br><span class="line"><span class="keyword">const</span> hugeString: bigint = <span class="built_in">BigInt</span>(<span class="string">"9007199254740991"</span>)</span><br><span class="line"></span><br><span class="line">theBiggestInt === alsoHuge <span class="comment">// true</span></span><br><span class="line">theBiggestInt === hugeString <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><code>BigInt</code> 与 <code>Number</code> 的不同点：</p><ul><li><code>BigInt</code> 不能用于 <code>Math</code> 对象中的方法。</li><li><code>BigInt</code> 不能和任何 <code>Number</code> 实例混合运算，两者必须转换成同一种类型。</li><li><code>BigInt</code> 变量在转换为 <code>Number</code> 变量时可能会丢失精度。</li></ul><p><code>Number</code> 和 <code>BigInt</code> 可以进行比较：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0n</span> === <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1n</span> &lt; <span class="number">2</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">1</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">2</span>   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">2</span>  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt;= <span class="number">2</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>条件判断：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0n</span>) {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'条件成立!'</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'条件不成立!'</span>); <span class="comment">// 输出结果</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> || <span class="number">10n</span>    <span class="comment">// 10n</span></span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> &amp;&amp; <span class="number">10n</span>    <span class="comment">// 0n</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0n</span>)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">10n</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="number">10n</span>         <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!<span class="number">0n</span>          <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p><code>symbol</code> 是一种基本数据类型。</p><p><code>Symbol()</code> 函数会返回 <code>symbol</code> 类型的值。每个从 <code>Symbol()</code> 返回的 <code>symbol</code> 值都是<strong>唯一</strong>的。</p><p>使用 Symbol() 创建新的 symbol 类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym1: symbol = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> sym2: symbol = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">const</span> sym3: symbol = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line">代码块<span class="number">123</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码创建了三个新的 symbol 类型，但要注意每个从 Symbol() 返回的值都是唯一的：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sym2 === sym3) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 每个 <code>Symbol()</code> 方法返回的值都是唯一的，所以，sym2 和 sym3 不相等。</p><p>Symbol() 作为构造函数是不完整的：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="keyword">new</span> <span class="built_in">Symbol</span>() <span class="comment">// TypeError</span></span><br></pre></td></tr></tbody></table></figure><p>这种语法会报错，是因为从 ECMAScript 6 开始<strong>围绕原始数据类型创建一个显式包装器对象已不再被支持</strong>，但因历史遗留原因， <code>new Boolean()</code>、<code>new String()</code> 以及 <code>new Number()</code> 仍可被创建：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>()   <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">const</span> bigint = <span class="keyword">new</span> <span class="built_in">BigInt</span>()   <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>()   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>() <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> = <span class="keyword">new</span> <span class="built_in">String</span>()   <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><h4 id="symbol使用场景"><a href="#symbol使用场景" class="headerlink" title="symbol使用场景"></a>symbol使用场景</h4><ul><li>当一个对象有较多属性时（<em>往往分布在不同文件中由模块组合而成</em>），很容易将某个属性名覆盖掉，使用 <code>Symbol</code> 值可以避免这一现象，比如 <code>vue-router</code> 中的 <code>name</code> 属性。</li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js 文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> aRouter = {</span><br><span class="line">  path: <span class="string">'/index'</span>,</span><br><span class="line">  name: <span class="built_in">Symbol</span>(<span class="string">'index'</span>),</span><br><span class="line">  component: Index</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bRouter = {</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="built_in">Symbol</span>(<span class="string">'index'</span>), <span class="comment">// 不重复</span></span><br><span class="line">  component: Home</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes.js 文件</span></span><br><span class="line"><span class="keyword">import</span> { aRouter } <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> { bRouter } <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  aRouter,</span><br><span class="line">  bRouter</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 两个不同文件使用了同样的 <code>Symbol('index')</code> 作为属性 name 的值，因 symbol 类型的唯一性，就避免了<strong>重复定义</strong>。</p><ul><li>模拟类的<strong>私有方法</strong></li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permission: symbol = <span class="built_in">Symbol</span>(<span class="string">'permission'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auth</span> </span>{</span><br><span class="line">  [permission]() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种情况<strong>通过类的实例是</strong>无法取到该方法，模拟类的私有方法。</p><p>但是，TypeScript 是可以使用 <code>private</code> 关键字的，所以这种方法可以在 JavaScript 中使用。</p><ul><li>判断是否可以用 <code>for...of</code> 迭代</li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> iterable) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n <span class="keyword">of</span> iterable) {</span><br><span class="line">      <span class="built_in">console</span>.log(n)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个知识点后续会在 <code>迭代器</code> 那一节会着重介绍，这里可以先知晓：</p><p>   <code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。<br>   <code>for...of</code> 只能迭代可枚举属性。</p><ul><li>Symbol.prototype.description</li></ul><p><code>Symbol([description])</code> 中可选的字符串即为这个 Symbol 的描述，如果想要获取这个描述：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">'imooc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sym);               <span class="comment">// Symbol(imooc)</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.toString());    <span class="comment">// Symbol(imooc)</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.description);   <span class="comment">// imooc</span></span><br></pre></td></tr></tbody></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>通过元组可以存储不同类型的元素，而非像数组那样只能存储相同元素类型（any[] 除外）。</p><p>声明一个由 <code>string</code> 和 <code>number</code> 构成的元组：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]   <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list1: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="number">1887</span>, <span class="string">'Sherlock'</span>]  <span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 元组中规定的元素类型<strong>顺序必须是完全对照的</strong>，而且<strong>不能多、不能少</strong>（数量也必须一样，数组有了长度）<code>list1</code> 中定义的第一个元素为 <code>string</code>类型，不能赋值为 <code>number</code>类型的数据。</p><p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">0</span>].substr(<span class="number">1</span>)  <span class="comment">// ok</span></span><br><span class="line">list[<span class="number">1</span>].substr(<span class="number">1</span>)  <span class="comment">// Property 'substr' does not exist on type 'number'.</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 3 行，<code>list[0]</code> 是一个字符串类型，拥有 substr() 方法。</p><p>第 4 行，<code>list[1]</code> 是一个数字类型，没有 substr() 方法，所以报错。</p><p>要注意元组的越界问题，虽然<strong>可以越界添加元素</strong>（<em>不建议</em>），但是<strong>不可越界访问</strong>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br><span class="line">list.push(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(list)      <span class="comment">// ok [ 'Sherlock', 1887, 'hello world' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(list[<span class="number">2</span>])   <span class="comment">// Tuple type '[string, number]' of length '2' has no element at index '2'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，向一个声明了<strong>只有两个元素的元组</strong>继续添加元素，这种操作虽然可行，但是严重不建议！</p><p>第 5 行，该元组只有两个元素，不可越界访问第三个元素。</p><p>元组类型允许在元素类型后缀一个 <code>?</code> 来说明元素是可选的：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">number</span>, <span class="built_in">string</span>?, <span class="built_in">boolean</span>?]</span><br><span class="line">list = [<span class="number">10</span>, <span class="string">'Sherlock'</span>, <span class="literal">true</span>]</span><br><span class="line">list = [<span class="number">10</span>, <span class="string">'Sherlock'</span>]</span><br><span class="line">list = [<span class="number">10</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>可选元素必须在必选元素的后面，也就是如果一个元素后缀了 <code>?</code>号，其后的所有元素都要后缀 <code>?</code>号</strong>。</p><p>元组可以作为参数传递给函数，函数的 Rest 形参可以定义为元组类型（动态长度）：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">rest</span>(<span class="params">...args: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>]</span>): <span class="title">void</span></span></span><br></pre></td></tr></tbody></table></figure><p>等价于：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">rest</span>(<span class="params">arg1: <span class="built_in">number</span>, arg2: <span class="built_in">string</span>, arg3: <span class="built_in">boolean</span></span>): <span class="title">void</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>TIPS：</strong> 在声明文件（.d.ts）中，关键字 declare 表示声明作用。声明文件用于编写第三方类库，通过配置 <code>tsconfig.json</code> 文件中的 <code>declaration 为 true</code>，在编译时可自行生成。</p></blockquote><p>还可以这样：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">number</span>, ...string[]] = [<span class="number">10</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list1: [<span class="built_in">string</span>, ...number[]] = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> Rest 元素指定了元组类型是无限扩展的，可能有零个或多个具有数组元素类型的额外元素。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>需要定义一组相同主题的常量数据时，应该立即想到枚举类型。在学习过程中，需要注意枚举类型的<strong>正向映射和反向映射</strong></p><p>使用枚举我们可以定义一些<strong>带名字的常量</strong>。TypeScript 支持<strong>数字</strong>的和基于<strong>字符串</strong>的枚举。</p><p>枚举类型弥补了 JavaScript 的设计不足，很多语言都拥有枚举类型。</p><p>当我们需要一组相同主题下的数据时，枚举类型就很有用了。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction { Up, Down, Left, Right }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Months { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Size { big = <span class="string">'大'</span>, medium = <span class="string">'中'</span>, small = <span class="string">'小'</span> }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Agency { province = <span class="number">1</span>, city = <span class="number">2</span>, district = <span class="number">3</span> }</span><br></pre></td></tr></tbody></table></figure><p>声明一个枚举类型，如果没有赋值，它们的值默认为<strong>数字类型</strong>且从 0 开始累加：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Months.Jan === <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">Months.Feb === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">Months.Mar === <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line">Months.Apr === <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>现实中月份是从 1 月开始的，那么只需要这样：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第一个数字赋值，往后依次累加</span></span><br><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Months.Jan === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">Months.Feb === <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line">Months.Mar === <span class="number">3</span> <span class="comment">// true</span></span><br><span class="line">Months.Apr === <span class="number">4</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>枚举类型的值为<strong>字符串类型</strong>：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> TokenType {</span><br><span class="line">  ACCESS = <span class="string">'accessToken'</span>,</span><br><span class="line">  REFRESH = <span class="string">'refreshToken'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种不同的取值写法</span></span><br><span class="line"><span class="built_in">console</span>.log(TokenType.ACCESS === <span class="string">'accessToken'</span>)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(TokenType[<span class="string">'REFRESH'</span>] === <span class="string">'refreshToken'</span>)   <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 枚举的取值，有 <code>TokenType.ACCESS</code> 和 <code>TokenType['ACCESS']</code> 这两种不同的写法，效果是相同的。</p><p><strong>数字类型和字符串类型可以混合使用，但是不建议：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> BooleanLikeHeterogeneousEnum {</span><br><span class="line">    No = <span class="number">0</span>,</span><br><span class="line">    Yes = <span class="string">"YES"</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>枚举类型的值可以是一个简单的<strong>计算表达式</strong>：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Calculate {</span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">  expired = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>,</span><br><span class="line">  length = <span class="string">'imooc'</span>.length,</span><br><span class="line">  plus = <span class="string">'hello '</span> + <span class="string">'world'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.expired)   <span class="comment">// 86400</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.length)    <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.plus)      <span class="comment">// hello world</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Tips:</strong></p><ul><li>计算结果必须为常量。</li><li>计算项必须放在最后。</li></ul><p>所谓的反向映射就是指枚举的取值，不但可以正向的 <code>Months.Jan</code> 这样取值，也可以反向的 <code>Months[1]</code> 这样取值。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Months.Mar === <span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么反过来能取到 Months[3] 的值吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(Months[<span class="number">3</span>])  <span class="comment">// 'Mar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以</span></span><br><span class="line"><span class="built_in">console</span>.log(Months.Mar === <span class="number">3</span>)     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Months[<span class="number">3</span>] === <span class="string">'Mar'</span>)  <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Tips:</strong></p><ol><li>字符串枚举成员不会生成反向映射。</li><li>枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。</li></ol><p>在枚举上使用 <code>const</code> 修饰符：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> month = Months.Mar</span><br></pre></td></tr></tbody></table></figure><p>查看一下编译后的内容：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> month = <span class="number">3</span> <span class="comment">/* Mar */</span></span><br><span class="line">代码块<span class="number">12</span></span><br></pre></td></tr></tbody></table></figure><p>发现枚举类型应该编译出的对象没有了，只剩下 <code>month</code> 常量。这就是使用 <code>const</code> 关键字声明枚举的作用。因为变量 <code>month</code> 已经使用过枚举类型，在编译阶段 TypeScript 就将枚举类型抹去，这也是<strong>性能提升</strong>的一种方案。</p><p>分开声明名称相同的枚举类型，会<strong>自动合并</strong>：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  May = <span class="number">5</span>,</span><br><span class="line">  Jun</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Months.Apr) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(Months.Jun) <span class="comment">// 6</span></span><br></pre></td></tr></tbody></table></figure><h1 id="TypeScript-Never-与-Unknown"><a href="#TypeScript-Never-与-Unknown" class="headerlink" title="TypeScript Never 与 Unknown"></a>TypeScript Never 与 Unknown</h1><p>本节介绍 never 和 unknown 类型，其中 unknown 类型作为 any 类型对应的安全类型使用起来更加安全，如果有<strong>any 类型的使用需求</strong>，应尽量使用 **unknown 类型来替代 **any 类型。</p><p><code>never</code> 类型表示那些永不存在的值的类型。</p><p><code>unknown</code> 类型是 <code>any</code> 类型对应的安全类型。</p><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p>一个抛出异常的函数表达式，其函数返回值类型为 never：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message:<span class="built_in">string</span></span>): <span class="title">never</span> </span>{</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样的，不会有返回值的函数表达式，其函数返回值类型也为 never:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断的返回值类型为 never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>): <span class="title">never</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不能取得值的地方：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo {</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'foo'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bar {</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'bar'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> All = Foo | Bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleValue</span>(<span class="params">val: All</span>) </span>{</span><br><span class="line">  <span class="keyword">switch</span> (val.type) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'foo'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'bar'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 此处不能取值</span></span><br><span class="line">      <span class="keyword">const</span> exhaustiveCheck: <span class="built_in">never</span> = val</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Unknown"><a href="#Unknown" class="headerlink" title="Unknown"></a>Unknown</h2><p>我们知道 any 无需事先执行任何类型的检查：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="number">10</span>               <span class="comment">// OK</span></span><br><span class="line">value = <span class="string">"Hello World"</span>    <span class="comment">// OK</span></span><br><span class="line">value = []               <span class="comment">// OK</span></span><br><span class="line">value = {}               <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Math</span>.random      <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">null</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">undefined</span>        <span class="comment">// OK</span></span><br><span class="line">value = <span class="keyword">new</span> <span class="built_in">TypeError</span>()  <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)   <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">value.foo.bar            <span class="comment">// OK</span></span><br><span class="line">value.trim()             <span class="comment">// OK</span></span><br><span class="line">value()                  <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">new</span> value()              <span class="comment">// OK</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]              <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><p>在许多情况下，这太宽松了。 <code>unknown</code> 类型呢？</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="number">10</span>               <span class="comment">// OK</span></span><br><span class="line">value = <span class="string">"Hello World"</span>    <span class="comment">// OK</span></span><br><span class="line">value = []               <span class="comment">// OK</span></span><br><span class="line">value = {}               <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Math</span>.random      <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">null</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">undefined</span>        <span class="comment">// OK</span></span><br><span class="line">value = <span class="keyword">new</span> <span class="built_in">TypeError</span>()  <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)   <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><p>所有对该 <code>value</code> 变量的分配都被认为是类型正确的。</p><p>但是，如果尝试：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value1: unknown = value   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> value2: <span class="built_in">any</span> = value       <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value3: <span class="built_in">boolean</span> = value   <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value4: <span class="built_in">number</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value5: <span class="built_in">string</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value6: <span class="built_in">object</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value7: <span class="built_in">any</span>[] = value     <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，该 unknown 类型<strong>只能分配给 any 类型和 unknown 类型</strong>本身。</p><p>现在继续尝试：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line">value.foo.bar  <span class="comment">// Error</span></span><br><span class="line">value.trim()   <span class="comment">// Error</span></span><br><span class="line">value()        <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">new</span> value()    <span class="comment">// Error</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]    <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure><p><strong><code>unknown</code> 类型在被确定为某个类型之前，不能被进行诸如函数执行、实例化等操作，一定程度上对类型进行了保护。</strong></p><blockquote><p>在那些将取得任意值，但不知道具体类型的地方使用 <code>unknown</code>，而非 <code>any</code>。</p></blockquote><h1 id="TypeScript-接口-Interface"><a href="#TypeScript-接口-Interface" class="headerlink" title="TypeScript 接口(Interface)"></a>TypeScript 接口(Interface)</h1><blockquote><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。——官方定义</p></blockquote><p>接口是对 JavaScript 本身的随意性进行约束，通过定义一个接口，<strong>约定了变量、类、函数等</strong>应该按照什么样的格式进行声明，实现多人合作的一致性。TypeScript 编译器依赖接口用于类型检查，最终编译为 JavaScript 后，接口将会被移除。</p><p><strong>接口主要是对对象、函数、类的类型做一些定义</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line"><span class="keyword">interface</span> DemoInterface {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在声明一个<strong>对象</strong>、<strong>函数</strong>或者<strong>类</strong>时，先定义接口，确保其数据结构的一致性。</p><p>在多人协作时，定义接口尤为重要。</p><h2 id="接口的好处"><a href="#接口的好处" class="headerlink" title="接口的好处"></a>接口的好处</h2><p>过去我们写 JavaScript 定义一个函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClothesInfo</span>(<span class="params">clothes</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(clothes.price)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClothes = {</span><br><span class="line">  color: <span class="string">'black'</span>, </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line">getClothesInfo(myClothes)</span><br></pre></td></tr></tbody></table></figure><p>之前我们写 JavaScript 这样是很正常的，但同时你可能会遇到下面这些问题:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getClothesInfo() <span class="comment">// Uncaught TypeError: Cannot read property 'price' of undefined</span></span><br><span class="line">getClothesInfo({ <span class="attr">color</span>: <span class="string">'black'</span> }) <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>相信原因你也知道，JavaScript 是 <code>弱类型</code> 语言，并不会对传入的参数进行任何检测，错误在运行时才被发现。那么通过定义 <code>接口</code>，在编译阶段甚至开发阶段就避免掉这类错误，接口<strong>将检查类型是否和某种结构做匹配</strong>。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>下面通过接口的方式重写之前的例子：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClothesInfo</span>(<span class="params">clothes: Clothes</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(clothes.price)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  color: <span class="string">'black'</span>, </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getClothesInfo(myClothes)</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 代码中，定义了一个接口 <code>Clothes</code>，在传入的变量 <code>clothes</code> 中，它的类型为 <code>Clothes</code>。这样，就约束了这个传入对象的 <code>外形</code> 与接口定义一致。只要传入的对象满足上面的类型约束，那么它就是被允许的。</p><p><strong>Tips：</strong></p><ol><li>定义接口要 <code>首字母大写</code>。</li><li>只需要关注值的 <code>外形</code>，并不像其他语言一样，定义接口是为了实现。</li><li>如果没有特殊声明，定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致。</li></ol><h2 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h2><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口中的属性不全是必需的。可选属性的含义是该属性在被变量定义时可以不存在。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以不定义属性 color</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p><p>这时，<strong>仍不允许添加未定义的属性</strong>，如果引用了不存在的属性时 TS 将直接捕获错误。</p><h3 id="只读属性-和const对应，一个是属性一个是变量"><a href="#只读属性-和const对应，一个是属性一个是变量" class="headerlink" title="只读属性(和const对应，一个是属性一个是变量)"></a>只读属性(和const对应，一个是属性一个是变量)</h3><p>一些对象属性<strong>只能在对象刚刚创建的时候修改其值</strong>。你可以在属性名前用 <code>readonly</code> 来指定只读属性，比如价格是不能被修改的:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的时候给 price 赋值</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可修改</span></span><br><span class="line">myClothes.price = <span class="number">100</span></span><br><span class="line"><span class="comment">// error TS2540: Cannot assign to 'price' because it is a constant or a read-only property</span></span><br></pre></td></tr></tbody></table></figure><p>TypeScript 可以通过 <code>ReadonlyArray&lt;T&gt;</code> 设置数组为只读，那么它的所有<strong>写方法</strong>都会失效。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">6</span>; <span class="comment">// Index signature in type 'readonly number[]' only permits reading</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 代码中的泛型语法在之后会有专门的小节介绍。</p><h4 id="readonlyvsconst"><a href="#readonlyvsconst" class="headerlink" title="readonlyvsconst`"></a>readonly<code>vs</code>const`</h4><p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为<strong>变量使用还是做为一个属性</strong>。做为 <code>变量</code> 使用的话用 const，若做为 <code>属性</code> 则使用 readonly。</p><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>有时候我们希望接口允许有任意的属性，语法是用 <code>[]</code> 将属性包裹起来：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> price: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意属性 activity</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span>,</span><br><span class="line">  activity: <span class="string">'coupon'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 这里的接口 <code>Clothes</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> <code>size</code> 和 <code>price</code>，那么就无所谓它们的类型是什么。</p><ul><li>项目案例：使用 axios 库发起 HTTP 传输的时候，可以写入一个自定义的属性，就是因为源码中定义了一个任意属性：</li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$axios({</span><br><span class="line">  method: <span class="string">'put'</span>,</span><br><span class="line">  url: <span class="string">'/cms/user'</span>,</span><br><span class="line">  data: {</span><br><span class="line">    nickname: <span class="built_in">this</span>.nickname,</span><br><span class="line">  },</span><br><span class="line">  showBackend: <span class="literal">true</span>,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>除了描述带有属性的普通对象外，接口也可以描述<strong>函数类型。</strong></p><p>为了使接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个<strong>只有 <code>参数列表</code> 和 <code>返回值类型</code> 的函数定义</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> source.search(subString) &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于函数类型的类型检查来说，<strong>函数的参数名不需要与接口里定义的名字相匹配</strong>。你可以改变函数的参数名，<strong>只要保证函数参数的位置不变。函数的参数会被逐个进行检查：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"><span class="comment">// source =&gt; src, subString =&gt; sub</span></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> src.search(sub) &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>如果接口中的函数类型带有函数名，下面两种书写方式是等价的：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Calculate {</span><br><span class="line">  add(x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">  multiply: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="6-可索引类型"><a href="#6-可索引类型" class="headerlink" title="6. 可索引类型"></a>6. 可索引类型</h2><p>可索引类型接口读起来有些拗口，直接看例子：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常的js代码</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  brand: <span class="string">'imooc'</span>,</span><br><span class="line">  type: <span class="string">'education'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line">obj[<span class="string">'brand'</span>]</span><br></pre></td></tr></tbody></table></figure><p>再来看定义可索引类型接口：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ScenicInterface {</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: ScenicInterface = [<span class="string">'西湖'</span>, <span class="string">'华山'</span>, <span class="string">'故宫'</span>]</span><br><span class="line"><span class="keyword">let</span> favorite: <span class="built_in">string</span> = arr[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><p>示例中索引签名是 <code>number类型</code>，返回值是字符串类型。</p><p>另外还有一种索引签名是 <code>字符串类型</code>。我们可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。通过下面的例子理解这句话：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">interface</span> Foo {</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">interface</span> Bar {</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">string</span>; <span class="comment">// Error: y 属性必须为 number 类型， 代表用y去索引返回string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>语法错误是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p><h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><p>我们希望<strong>类的实现必须遵循接口定义</strong>，那么可以使用 <code>implements</code> 关键字来确保兼容性。</p><p>这种类型的接口在传统面向对象语言中最为常见，比如 java 中接口就是这种类类型的接口。<strong>这种接口与抽象类比较相似，但是接口只能含有抽象方法和成员属性，实现类中必须实现接口中所有的抽象方法和成员属性。</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AnimalInterface {</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">AnimalInterface</span> </span>{</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你也可以在接口中描述一个方法，在类里实现它:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AnimalInterface {</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  eat(m: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">AnimalInterface</span> </span>{</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params">m: <span class="built_in">number</span></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">${<span class="built_in">this</span>.name}</span>吃肉<span class="subst">${m}</span>分钟`</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p>接口描述了类的公共部分，而不是公共和私有两部分。 它<strong>不会帮你检查类是否具有某些私有成员。</strong></p><h2 id="8-继承接口"><a href="#8-继承接口" class="headerlink" title="8. 继承接口"></a>8. 继承接口</h2><p>和类一样，接口也可以通过关键字 <code>extents</code> 相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape {</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = {} <span class="keyword">as</span> Square;</span><br><span class="line"><span class="comment">// 继承了 Shape 的属性</span></span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke {</span><br><span class="line">  penWidth: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke {</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = {} <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="9-混合类型"><a href="#9-混合类型" class="headerlink" title="9. 混合类型"></a>9. 混合类型</h2><p>在前面已经介绍，接口可以<strong>描述函数、对象的方法或者对象的属性。</strong></p><p>有时希望一个对象同时具有上面提到多种类型，比如一个<strong>对象可以当做函数使用，同时又具有属性和方法。</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter {</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>{</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>{ } <span class="keyword">as</span> Counter;</span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ };</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，声明一个接口，<strong>如果只有 <code>(start: number): string</code> 一个成员，那么这个接口就是函数接口</strong>，同时还具有其他两个成员，可以用来描述对象的属性和方法，这样就构成了一个混合接口。</p><p>第 7 行，创建一个 <code>getCounter()</code> 函数，它的返回值是 Counter 类型的。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>{ } <span class="keyword">as</span> Counter;</span><br></pre></td></tr></tbody></table></figure><p>第 8 行，通过类型断言，将函数对象转换为 <code>Counter</code> 类型，转换后的对象不但实现了函数接口的描述，使之成为一个函数，还具有 interval 属性和 reset() 方法。断言成功的条件是，两个数据类型只要有一方可以赋值给另一方，这里函数类型数据不能赋值给接口类型的变量，因为它不具有 interval 属性和 reset() 方法。</p><p>类型断言在之后的小节也会单节介绍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript-基础类型&quot;&gt;&lt;a href=&quot;#TypeScript-基础类型&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 基础类型&quot;&gt;&lt;/a&gt;TypeScript 基础类型&lt;/h1&gt;&lt;p&gt;TypeScript 中的类型有&lt;/</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="https://yjunuser.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yjunuser.github.io/2021/04/24/helloworld/"/>
    <id>https://yjunuser.github.io/2021/04/24/helloworld/</id>
    <published>2021-04-24T04:32:07.695Z</published>
    <updated>2021-04-24T11:12:25.294Z</updated>
    
    <content type="html"><![CDATA[<h1>欢迎来到我的博客</h1><h2>aaa</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;欢迎来到我的博客&lt;/h1&gt;
&lt;h2&gt;aaa&lt;/h2&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSS linear-gradient函数</title>
    <link href="https://yjunuser.github.io/2021/04/24/linear-gradient/"/>
    <id>https://yjunuser.github.io/2021/04/24/linear-gradient/</id>
    <published>2021-04-23T16:00:00.000Z</published>
    <updated>2021-04-24T11:12:15.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-linear-gradient的介绍和在实际项目中的使用"><a href="#CSS-linear-gradient的介绍和在实际项目中的使用" class="headerlink" title="CSS: linear-gradient的介绍和在实际项目中的使用"></a>CSS: linear-gradient的介绍和在实际项目中的使用</h1><p>linear-gradient函数是CSS3中的一些新特性,最近在学习CSS揭秘这本书中一开始就接触到了这个属性,以前接触的实在不多,CSS揭秘上对这两个属性的运用又让我大开眼界,于是写篇文章好好学习一下</p><h2 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h2><p>CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()"><code>linear-gradient&nbsp;</code></a>函数用于创建一个表示两种或多种颜色线性见表的图片</p><p><code>linear-gradient</code>函数接收三个值: </p><p><code>&lt;side-or-corner&gt;</code></p><p>​    描述渐变线的起始点位置。它包含<strong>to</strong>和两个关键词：第一个指出水平位置<strong>left or right</strong>，第二个指出垂直位置<strong>top or bottom</strong>。关键词的先后顺序无影响，且都是可选的。</p><p>​    to top, to bottom, to left 和 to right这些值会被转换成角度<strong>0度、180度、270度和90度</strong>。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。</p><p><code>&lt;angle&gt;</code></p><p>​    用角度值指定渐变的方向（或角度）。角度顺时针增加。 </p><p><code>&lt;linear-color-stop&gt;</code></p><p>​    由一个color值组成，并且跟随着一个可选的<strong>终点位置</strong>（可以是一个<strong>百分比值</strong>或者是沿着渐变轴的<strong>length</strong>。CSS渐变的颜色渲染采取了与<strong>SVG相同</strong>的规则。</p><p><code>&lt;color-hint&gt;</code></p><p>​    颜色中转点是一个插值提示，它定义了在相邻颜色之间渐变如何进行。长度定义了在两种颜色之间的哪个点停止渐变颜色应该达到颜色过渡的中点。如果省略，颜色转换的中点是两个颜色停止之间的中点。 </p><p>听起来很复杂，看几个例子就明白了</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red, yellow, blue);</span><br><span class="line">    <span class="comment">/*等价于*/</span></span><br><span class="line">    <span class="comment">/*background: linear-gradient(180deg, red, yellow, blue)*/</span></span><br><span class="line">    <span class="comment">/*background: linear-gradient(to bottom, red, yellow, blue)*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424133125189.png" alt="image-20210424133125189"></p><p>可以看到，实现了从<code>red -&gt; yellow -&gt; blue</code>的线性渐变，且渐变角度从上到下，也就是从<strong>180deg到0deg</strong>，即默认情况下，第一个参数等于<strong>180deg</strong></p><p>现在改变一下角度试试:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">0deg</span>, red, yellow, blue);</span><br><span class="line">    <span class="comment">/*等价于*/</span></span><br><span class="line">    <span class="comment">/*background: linear-gradient(to top, red, yellow, blue)*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424133512095.png" alt="image-20210424133512095"></p><p>可以看到，图片完完全全的倒立过来了</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, red, yellow, blue)</span><br><span class="line">    /*等价于*/</span><br><span class="line">    /*background: <span class="built_in">linear-gradient</span>(to right top, red, yellow, blue)*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424133802029.png" alt="image-20210424133802029"></p><p>由此可以看出，<code>linear-gradient</code>中图片角度的规律</p><p><img src="/images/artical-image/image-20210424134420095.png" alt="image-20210424134420095"></p><p>除此之外，颜色的每个值都可以设置终止位置</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red <span class="number">0%</span>, orange <span class="number">25%</span>, yellow <span class="number">50%</span>, green <span class="number">75%</span>, blue <span class="number">100%</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424135509560.png" alt="image-20210424135509560"></p><p>当然也可以使用<code>px</code></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red <span class="number">50px</span>, orange <span class="number">100px</span>, yellow <span class="number">150px</span>, green <span class="number">180px</span>, blue)</span><br><span class="line">   /*最后一个默认为终点位置*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424135947658.png" alt="image-20210424135947658"></p><blockquote><p>需要注意的是，当你生命了<code>linear-gradient</code>中的颜色属性后，再添加<code>background-color</code>或者向<code>background</code>中添加颜色是无效的，因为linear-gradient的颜色把原来的背景颜色全部覆盖了，但把<code>color</code>值设为<code>tranparent</code>能显示回原来的颜色，也就是你用<code>background-color</code>设置的颜色</p></blockquote><p>那我们怎样在项目中去<strong>合理</strong>的应用这个属性呢?</p><p>举个简单的例子，当我们创建一个按钮</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#446d88</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> gray;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -<span class="number">0.05em</span> <span class="number">0.05em</span> <span class="number">#335166</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424141714525.png" alt="image-20210424141714525"></p><p>现在给这个按钮添加换一个渐变背景</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#446d88</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#77a0bb</span>, <span class="number">#58a</span>);</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> gray;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -<span class="number">0.05em</span> <span class="number">0.05em</span> <span class="number">#335166</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424141930939.png" alt="image-20210424141930939"></p><p>到这里，一个简单的有<strong>质感</strong>的按钮就完成了</p><p>但到这里仍存在一些问题，按钮是在项目中经常重复用到的部分，假如现在我们要创建一个红色按钮或者黄色按钮，该怎么办呢?</p><p>我们可能需要覆盖四条属性，<code>border-color</code>，<code>text-shadow</code>，<code>box-shadow</code>，<code>background</code>，因为颜色变了后这些属性都要跟着改变，而且，确定一个颜色的<strong>渐变</strong>效果需要知道这个颜色的<strong>亮色</strong>和<strong>暗色</strong>版本(例如上面的按钮就需要知道<code>#58a</code>和<code>#77a0bb</code>)，并且如果按钮放在一个<strong>非纯白色背景</strong>上呢，例如放到<code>gray</code>背景里</p><p><img src="/images/artical-image/image-20210424143615958.png" alt="image-20210424143615958"></p><p>此时<code>box-shadow: gray</code>属性明显就不能体现出来该有的效果</p><p>那有没有方法能一次性解决上面的问题又更加简洁呢，<code>linear-gradient</code>可以派上用场了，用<code>linear-gradient</code>设置一个<strong>半透明的白色</strong>作为主色调就能解决这个难题</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>);</span><br><span class="line">        <span class="attribute">background</span>:   <span class="number">#58a</span> <span class="built_in">linear-gradient</span>(<span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">100%</span>, .<span class="number">5</span>), transparent);;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -.<span class="number">05em</span> .<span class="number">05em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424151914438.png" alt="image-20210424151914438"></p><p>现在，我们只需要改变<code>background-color</code>就能得到不同颜色的<strong>渐变按钮</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>);</span><br><span class="line">        <span class="attribute">background</span>:   <span class="number">#58a</span> <span class="built_in">linear-gradient</span>(<span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">100%</span>, .<span class="number">5</span>), transparent);;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -.<span class="number">05em</span> .<span class="number">05em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-class">.cancel</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424160249913.png" alt="image-20210424160249913"></p><p>这就是<code>linear-gradient</code>在实际项目中的一个小应用，也是我读<a href="https://www.ituring.com.cn/book/1695">Css揭秘</a>这本书学到的一个有用的知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS-linear-gradient的介绍和在实际项目中的使用&quot;&gt;&lt;a href=&quot;#CSS-linear-gradient的介绍和在实际项目中的使用&quot; class=&quot;headerlink&quot; title=&quot;CSS: linear-gradient的介绍和在实际项</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="https://yjunuser.github.io/tags/CSS/"/>
    
  </entry>
  
</feed>

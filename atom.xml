<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaoyao日志</title>
  
  <subtitle>努力且幸运</subtitle>
  <link href="https://yjunuser.github.io/atom.xml" rel="self"/>
  
  <link href="https://yjunuser.github.io/"/>
  <updated>2021-06-21T13:52:46.307Z</updated>
  <id>https://yjunuser.github.io/</id>
  
  <author>
    <name>姚伯骏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactNative中封装一个组件</title>
    <link href="https://yjunuser.github.io/2021/06/21/react-native%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6/"/>
    <id>https://yjunuser.github.io/2021/06/21/react-native%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6/</id>
    <published>2021-06-20T16:00:00.000Z</published>
    <updated>2021-06-21T13:52:46.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在ReactNative封装一个组件"><a href="#在ReactNative封装一个组件" class="headerlink" title="在ReactNative封装一个组件"></a>在ReactNative封装一个组件</h1><h2 id="定义组件的Props"><a href="#定义组件的Props" class="headerlink" title="定义组件的Props"></a>定义组件的Props</h2><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ModalProps = Partial&lt;React.ComponentProps&lt;<span class="keyword">typeof</span> Modal&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dataItem = {</span><br><span class="line">  icon: <span class="built_in">string</span>,</span><br><span class="line">  title: <span class="built_in">string</span>,</span><br><span class="line">  color: <span class="built_in">string</span>,</span><br><span class="line">  handle?: <span class="function">(<span class="params">params: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ModalComponentProps <span class="keyword">extends</span> Omit&lt;ModalProps, 'list' | 'ref' | 'title'&gt; {</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  list?: dataItem[]; <span class="comment">// 传过来的数据</span></span><br><span class="line">  toggleModal?: <span class="function">() =&gt;</span> <span class="built_in">void</span>; <span class="comment">// 改变是否可见的函数</span></span><br><span class="line">  ModalStyle?: StyleProp&lt;ViewStyle&gt;, <span class="comment">// modal的样式</span></span><br><span class="line">  ModalContentStyle?: StyleProp&lt;ViewStyle&gt;, <span class="comment">// modal中内容的样式</span></span><br><span class="line">  leftTopChildren?: React.ReactNode, <span class="comment">// 左上角子组件</span></span><br><span class="line">  rightTopChildren?: React.ReactNode, <span class="comment">// 右上角子组件</span></span><br><span class="line">  contentChildren?: React.ReactNode <span class="comment">// 内容组件</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="写组件中应用"><a href="#写组件中应用" class="headerlink" title="写组件中应用"></a>写组件中应用</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 将自己定义的属性和组件自身的属性解构</span><br><span class="line">const { list, toggleModal, title, ModalStyle, ModalContentStyle, rightTopChildren, leftTopChildren, contentChildren, ...rest } = props</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">      // 组件自身的属性直接传给组件</span><br><span class="line">    &lt;Modal onBackdropPress={toggleModal} {...rest}&gt;</span><br><span class="line">          // 自己定义的属性可以加一层判断</span><br><span class="line">      &lt;View style={ModalStyle ? ModalStyle : styles.modal}&gt;</span><br><span class="line">        &lt;View style={styles.leftCom}&gt;</span><br><span class="line">          {</span><br><span class="line">            leftTopChildren</span><br><span class="line">          }</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">        &lt;View style={styles.rightCom}&gt;</span><br><span class="line">          {</span><br><span class="line">            rightTopChildren ? rightTopChildren : &lt;Icon name='closecircle' color="#dcdcdc" size={16} onPress={toggleModal}&gt;&lt;/Icon&gt;</span><br><span class="line">          }</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Text style={styles.title}&gt;{title}&lt;/Text&gt;</span><br><span class="line"></span><br><span class="line">        &lt;View style={ModalContentStyle ? ModalContentStyle : styles.modalContent}&gt;</span><br><span class="line">          {</span><br><span class="line">            contentChildren ? contentChildren :</span><br><span class="line">              list?.map((item, index) =&gt; {</span><br><span class="line">                return (</span><br><span class="line">                  &lt;View style={styles.modalItem} key={index}&gt;</span><br><span class="line">                    &lt;Icon name={item.icon} size={40} color={item.color} onPress={item.handle}&gt;&lt;/Icon&gt;</span><br><span class="line">                    &lt;Text style={styles.modalItemTitle}&gt;{item.title}&lt;/Text&gt;</span><br><span class="line">                  &lt;/View&gt;</span><br><span class="line">                )</span><br><span class="line">              })</span><br><span class="line">          }</span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    &lt;/Modal&gt;</span><br><span class="line">  )</span><br></pre></td></tr></tbody></table></figure><h2 id="调用组件"><a href="#调用组件" class="headerlink" title="调用组件"></a>调用组件</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ModalComponent</span><br><span class="line">     title={'新建文件夹'}</span><br><span class="line">     isVisible={isFolderVisible}</span><br><span class="line">     toggleModal={toggleFolder}</span><br><span class="line">     ModalStyle={styles.folderModal}</span><br><span class="line">     rightTopChildren={&lt;TouchableNativeFeedback onPress={toggleFolder}&gt;&lt;Text style={{ color: '#6a5acd', fontWeight: 'bold' }}&gt;完成&lt;/Text&gt;&lt;/TouchableNativeFeedback&gt;}</span><br><span class="line">     leftTopChildren={&lt;TouchableNativeFeedback onPress={toggleFolder}&gt;&lt;Text style={{ color: '#000000' }}&gt;取消&lt;/Text&gt;&lt;/TouchableNativeFeedback&gt;}</span><br><span class="line">     contentChildren={</span><br><span class="line">       &lt;View style={styles.folderModalContent}&gt;</span><br><span class="line">         &lt;EntypoIcon name='folder' size={150} color={'#6495ed'}&gt;&lt;/EntypoIcon&gt;</span><br><span class="line">         &lt;TextInput style={styles.folderName} placeholder={'新建文件夹'} focusable={true}&gt;&lt;/TextInput&gt;</span><br><span class="line">       &lt;/View&gt;</span><br><span class="line">     }</span><br><span class="line">   &gt;</span><br><span class="line">   &lt;/ModalComponent&gt;</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在ReactNative封装一个组件&quot;&gt;&lt;a href=&quot;#在ReactNative封装一个组件&quot; class=&quot;headerlink&quot; title=&quot;在ReactNative封装一个组件&quot;&gt;&lt;/a&gt;在ReactNative封装一个组件&lt;/h1&gt;&lt;h2 id=&quot;定</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ReactNative" scheme="https://yjunuser.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>react自动化测试</title>
    <link href="https://yjunuser.github.io/2021/06/06/react%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>https://yjunuser.github.io/2021/06/06/react%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</id>
    <published>2021-06-05T16:00:00.000Z</published>
    <updated>2021-06-21T14:13:53.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>yarn add @testing-library/react-hooks msw -D</code></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在<code>src</code>下面新建一个文件夹<code><code>__test__</code></code>(双下划线)</p><h3 id="传统的单元测试"><a href="#传统的单元测试" class="headerlink" title="传统的单元测试"></a>传统的单元测试</h3><p>传统的单元测试通常来测一个方法或者函数：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;&lt;code&gt;yarn add @testing-library/react-hooks msw -D&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>常用的style样式</title>
    <link href="https://yjunuser.github.io/2021/06/03/style/"/>
    <id>https://yjunuser.github.io/2021/06/03/style/</id>
    <published>2021-06-02T16:00:00.000Z</published>
    <updated>2021-06-21T14:14:01.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录一下做项目时经常用到的样式"><a href="#记录一下做项目时经常用到的样式" class="headerlink" title="记录一下做项目时经常用到的样式"></a>记录一下做项目时经常用到的样式</h2><p><code> background-color: rgb(244, 245, 247);&nbsp;</code>用于背景是纯白的灰色</p><p><code>box-shadow: rgba(0,0,0,0.1) 0 0 10px;</code> 四周的阴影</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 滚动条，只在当前组件滚动，其余地方不滚动</span></span><br><span class="line"><span class="keyword">const</span> TaskContainer = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  overflow: scroll;</span></span><br><span class="line"><span class="string">  flex: 1;</span></span><br><span class="line"><span class="string">  ::-webkit-scrollbar {</span></span><br><span class="line"><span class="string">    display: none;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;记录一下做项目时经常用到的样式&quot;&gt;&lt;a href=&quot;#记录一下做项目时经常用到的样式&quot; class=&quot;headerlink&quot; title=&quot;记录一下做项目时经常用到的样式&quot;&gt;&lt;/a&gt;记录一下做项目时经常用到的样式&lt;/h2&gt;&lt;p&gt;&lt;code&gt; background-</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Css" scheme="https://yjunuser.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>react一些可复用的方法</title>
    <link href="https://yjunuser.github.io/2021/05/31/react%E4%B8%80%E4%BA%9Butils%E6%96%B9%E6%B3%95/"/>
    <id>https://yjunuser.github.io/2021/05/31/react%E4%B8%80%E4%BA%9Butils%E6%96%B9%E6%B3%95/</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2021-06-01T12:20:50.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录一下碰到的可复用的方法"><a href="#记录一下碰到的可复用的方法" class="headerlink" title="记录一下碰到的可复用的方法"></a>记录一下碰到的可复用的方法</h2><h3 id="获取url指定pathnmae后面的参数"><a href="#获取url指定pathnmae后面的参数" class="headerlink" title="获取url指定pathnmae后面的参数"></a>获取url指定pathnmae后面的参数</h3><p>形如<code><a href="http://localhost:3000/projects/1/kanban">http://localhost:3000/projects/1/kanban</a></code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 根据url后面的参数去请求， hook获取id</span><br><span class="line">export const useProjectIdInUrl = () =&gt; {</span><br><span class="line">  const { pathname } = useLocation();</span><br><span class="line">  const id = pathname.match(/projects\/(\d+)/)?.[1];</span><br><span class="line">  // &nbsp;["projects/1", "1", index: 1, input: "/projects/1/kanban", groups: undefined] [1]</span><br><span class="line">  return Number(id);</span><br><span class="line">};</span><br><span class="line">// 最后得到1</span><br><span class="line"></span><br><span class="line">// 请求数据</span><br><span class="line">export const useProjectInUrl = () =&gt; useProjectById(useProjectIdInUrl());</span><br><span class="line"></span><br><span class="line">// 获取params</span><br><span class="line">export const useKanbanSearchParams = () =&gt; ({ projectId: useProjectIdInUrl() });</span><br><span class="line"></span><br><span class="line">// 获取QueryKe</span><br><span class="line">export const useKanBansQueryKey = () =&gt; ["kanbans", useKanbanSearchParams()];</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;记录一下碰到的可复用的方法&quot;&gt;&lt;a href=&quot;#记录一下碰到的可复用的方法&quot; class=&quot;headerlink&quot; title=&quot;记录一下碰到的可复用的方法&quot;&gt;&lt;/a&gt;记录一下碰到的可复用的方法&lt;/h2&gt;&lt;h3 id=&quot;获取url指定pathnmae后面的参数&quot;</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React跨组件状态管理总结</title>
    <link href="https://yjunuser.github.io/2021/05/29/React%E8%B7%A8%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    <id>https://yjunuser.github.io/2021/05/29/React%E8%B7%A8%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-28T16:00:00.000Z</published>
    <updated>2021-06-21T14:13:49.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨组件状态管理总结"><a href="#跨组件状态管理总结" class="headerlink" title="跨组件状态管理总结"></a>跨组件状态管理总结</h1><h2 id="小场面"><a href="#小场面" class="headerlink" title="小场面"></a>小场面</h2><p><a href="https://react.docschina.org/docs/lifting-state-up.html">状态提示</a> / <a href="https://react.docschina.org/docs/composition-vs-inheritance.html">组合组件</a></p><h2 id="缓存状态"><a href="#缓存状态" class="headerlink" title="缓存状态"></a>缓存状态</h2><p><a href="https://react-query.tanstack.com/">react-query</a></p><h2 id="客户端状态"><a href="#客户端状态" class="headerlink" title="客户端状态"></a>客户端状态</h2><p><a href="https://segmentfault.com/a/1190000039190541">url</a> / <a href="https://react-redux.js.org/introduction/why-use-react-redux">redux</a> / <a href="https://react.docschina.org/docs/hooks-reference.html#usecontext">context</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;跨组件状态管理总结&quot;&gt;&lt;a href=&quot;#跨组件状态管理总结&quot; class=&quot;headerlink&quot; title=&quot;跨组件状态管理总结&quot;&gt;&lt;/a&gt;跨组件状态管理总结&lt;/h1&gt;&lt;h2 id=&quot;小场面&quot;&gt;&lt;a href=&quot;#小场面&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>如何正确的写一个react页面</title>
    <link href="https://yjunuser.github.io/2021/05/29/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%86%99%E4%B8%80%E4%B8%AAreact%E9%A1%B5%E9%9D%A2/"/>
    <id>https://yjunuser.github.io/2021/05/29/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%86%99%E4%B8%80%E4%B8%AAreact%E9%A1%B5%E9%9D%A2/</id>
    <published>2021-05-28T16:00:00.000Z</published>
    <updated>2021-06-21T14:13:37.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何正确的写一个react页面"><a href="#如何正确的写一个react页面" class="headerlink" title="如何正确的写一个react页面"></a>如何正确的写一个react页面</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>react</code>实在是太灵活，导致我学习的时候一直找不到一个最佳实践，但还是摸索出了一点自己的写法，记录一下。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>先在<code>screens</code>文件夹下创建一个路由页面<code>kanban.tsx</code>，随便写一点东西：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import { useDocumentTitle } from "../../utils/index";</span><br><span class="line"></span><br><span class="line">export const KanbanScreen = () =&gt; {</span><br><span class="line">  useDocumentTitle("看板列表");</span><br><span class="line">  return &lt;h1&gt;看板&lt;/h1&gt;;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>接着定义一下这个页面所需要的基础类型，在<code>types</code>文件夹下新建一个<code>kanban.ts</code>：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Kanban {</span><br><span class="line">    id: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    projectId: <span class="built_in">number</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着定义这个页面所需要的接口，在<code>api</code>文件夹下新建一个<code>kanban.ts</code>:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import http, { ResponseData } from "./index";</span><br><span class="line">import { AxiosPromise, AxiosResponse } from "axios";</span><br><span class="line"></span><br><span class="line">export const getKanbanInfo = (params?: Partial&lt;Kanban&gt;): Promise&lt;AxiosResponse&lt;Kanban[]&gt;&gt; =&gt; {</span><br><span class="line">  return http.request({</span><br><span class="line">    url: `/kanbans`,</span><br><span class="line">    method: "get",</span><br><span class="line">    params,</span><br><span class="line">  });</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>接着写这个页面所需要获取数据的逻辑，即<code>hook</code>，在<code>utils</code>文件夹下新建一个<code>kanban.ts</code>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import { getKanbanInfo } from './../api/kanban';</span><br><span class="line">import { useQuery } from "react-query";</span><br><span class="line">import { Kanban } from "types/Kanban";</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const useKanbans = (param?: Partial&lt;Kanban&gt;) =&gt; {</span><br><span class="line">    return useQuery&lt;Kanban[], Error&gt;(["kanbans", param], async () =&gt; {</span><br><span class="line">      const res = await getKanbanInfo(param || {}); </span><br><span class="line">      return res.data;</span><br><span class="line">    });</span><br><span class="line">  };</span><br><span class="line">  </span><br></pre></td></tr></tbody></table></figure><p>这就是一个基本流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何正确的写一个react页面&quot;&gt;&lt;a href=&quot;#如何正确的写一个react页面&quot; class=&quot;headerlink&quot; title=&quot;如何正确的写一个react页面&quot;&gt;&lt;/a&gt;如何正确的写一个react页面&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react-query实现乐观更新</title>
    <link href="https://yjunuser.github.io/2021/05/26/%E4%BD%BF%E7%94%A8react-query%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E6%9B%B4%E6%96%B0/"/>
    <id>https://yjunuser.github.io/2021/05/26/%E4%BD%BF%E7%94%A8react-query%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E6%9B%B4%E6%96%B0/</id>
    <published>2021-05-25T16:00:00.000Z</published>
    <updated>2021-06-21T14:13:39.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是乐观更新"><a href="#什么是乐观更新" class="headerlink" title="什么是乐观更新"></a>什么是乐观更新</h2><p>In an optimistic update the UI behaves as though a change was successfully completed before receiving confirmation from the server that it actually was - it is being optimistic that it will eventually get the confirmation rather than an error. This allows for a more responsive user experience.</p><h2 id="react-query实现乐观更新"><a href="#react-query实现乐观更新" class="headerlink" title="react-query实现乐观更新"></a>react-query实现乐观更新</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">export const useEditProject = () =&gt; {</span><br><span class="line">  const queryClient = useQueryClient();</span><br><span class="line">  const [searchParams] = useProjectsSearchParam();</span><br><span class="line">    // queryKey,缓存中的key</span><br><span class="line">  const queryKey = ["projects", searchParams];</span><br><span class="line">  return useMutation(</span><br><span class="line">    // variables is an object that mutate will pass to your mutationFn， mutate其实就是把参数传给这个函数，然后触发它</span><br><span class="line">    async (params: Partial&lt;Project&gt;) =&gt; {</span><br><span class="line">      const res = await editProject(params);</span><br><span class="line">      return res.data;</span><br><span class="line">    },</span><br><span class="line">    {</span><br><span class="line">      onSuccess: () =&gt; queryClient.invalidateQueries(queryKey),</span><br><span class="line">      // This function will fire before the mutation function is fired and is passed the same variables the mutation function would receive</span><br><span class="line">      // 在mutate完成前触发，接受和mutate一样的参数</span><br><span class="line">      // 实现乐观更新，在异步请求完成之前，先将改变发生，若发生了错误再回滚</span><br><span class="line">      async onMutate(target: Partial&lt;Project&gt;) {</span><br><span class="line">        const previousItems = queryClient.getQueryData(queryKey);</span><br><span class="line">        queryClient.setQueryData(queryKey, (old?: Project[]) =&gt; {</span><br><span class="line">          const newV =</span><br><span class="line">            old?.map((project) =&gt;</span><br><span class="line">              project.id === target.id ? { ...project, ...target } : project</span><br><span class="line">            ) || [];</span><br><span class="line">          return newV;</span><br><span class="line">        });</span><br><span class="line">        return { previousItems };</span><br><span class="line">      },</span><br><span class="line">      // This function will fire if the mutation encounters an error and will be passed the error.</span><br><span class="line">      // If a promise is returned, it will be awaited and resolved before proceeding</span><br><span class="line">      onError(error: Error, newItems: Partial&lt;Project&gt;, context: any) {</span><br><span class="line">        // 回滚</span><br><span class="line">        queryClient.setQueryData(["projects", param], context.previousItems);</span><br><span class="line">      },</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="封装一个乐观更新hook"><a href="#封装一个乐观更新hook" class="headerlink" title="封装一个乐观更新hook"></a>封装一个乐观更新hook</h2><p>先封装一个通用的<code>config</code>，返回乐观更新所需要的<code>option</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import { QueryKey, useQueryClient } from "react-query";</span><br><span class="line"></span><br><span class="line">export const useConfig = (</span><br><span class="line">  queryKey: QueryKey,</span><br><span class="line">  callback: (target: any, old?: any[]) =&gt; any[]</span><br><span class="line">) =&gt; {</span><br><span class="line">  const queryClient = useQueryClient();</span><br><span class="line">  return {</span><br><span class="line">    onSuccess: () =&gt; queryClient.invalidateQueries(queryKey),</span><br><span class="line">    async onMutate(target: any) {</span><br><span class="line">      const previousItems = queryClient.getQueryData(queryKey);</span><br><span class="line">      queryClient.setQueryData(queryKey, (old?: any[]) =&gt; {</span><br><span class="line">        return callback(target, old);</span><br><span class="line">      });</span><br><span class="line">      return { previousItems };</span><br><span class="line">    },</span><br><span class="line">    onError(error: Error, newItems: any, context: any) {</span><br><span class="line">      queryClient.setQueryData(queryKey, context.previousItems);</span><br><span class="line">    },</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>然后就可以再封装一些具体的乐观更新操作：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export const useDeleteConfig = (queryKey: QueryKey) =&gt;</span><br><span class="line">  useConfig(queryKey, (target, old) =&gt; {</span><br><span class="line">    return old?.filter((item) =&gt; item.id !== target.id) || [];</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">export const useAddConfig = (queryKey: QueryKey) =&gt;</span><br><span class="line">  useConfig(queryKey, (target, old) =&gt; {</span><br><span class="line">    return old ? [...old, ...target] : [];</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">export const useEditConfig = (queryKey: QueryKey) =&gt;</span><br><span class="line">  useConfig(queryKey, (target, old) =&gt; {</span><br><span class="line">    return (</span><br><span class="line">      old?.map((item) =&gt;</span><br><span class="line">        item.id === target.id ? { ...item, ...target } : item</span><br><span class="line">      ) || []</span><br><span class="line">    );</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><p>然后就可以这样使用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">export const useEditProject = () =&gt; {</span><br><span class="line">  const queryClient = useQueryClient();</span><br><span class="line">  const [searchParams] = useProjectsSearchParam();</span><br><span class="line">  const queryKey = ["projects", searchParams];</span><br><span class="line">  return useMutation(</span><br><span class="line">    async (params: Partial&lt;Project&gt;) =&gt; {</span><br><span class="line">      const res = await editProject(params);</span><br><span class="line">      return res.data;</span><br><span class="line">    },</span><br><span class="line">     // 乐观更新hook</span><br><span class="line">    useEditConfig(queryKey)</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>done</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是乐观更新&quot;&gt;&lt;a href=&quot;#什么是乐观更新&quot; class=&quot;headerlink&quot; title=&quot;什么是乐观更新&quot;&gt;&lt;/a&gt;什么是乐观更新&lt;/h2&gt;&lt;p&gt;In an optimistic update the UI behaves as though a</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>用react-query来获取、更新、缓存远程数据</title>
    <link href="https://yjunuser.github.io/2021/05/24/%E7%94%A8react-query%E8%8E%B7%E5%8F%96%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E7%BC%93%E5%AD%98%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE/"/>
    <id>https://yjunuser.github.io/2021/05/24/%E7%94%A8react-query%E8%8E%B7%E5%8F%96%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E7%BC%93%E5%AD%98%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE/</id>
    <published>2021-05-23T16:00:00.000Z</published>
    <updated>2021-06-21T14:13:41.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-query"><a href="#react-query" class="headerlink" title="react-query"></a>react-query</h2><p>先上个链接<a href="https://react-query.tanstack.com/">react-query官方文档</a></p><p>这是一个适用于<code>react hooks</code>的请求库。 这个库将帮助你获取、同步、更新和缓存你的远程数据， 提供两个简单的 hooks，就能完成增删改查等操作</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>yarn add react-query</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h2 id="一些配置参数"><a href="#一些配置参数" class="headerlink" title="一些配置参数"></a>一些配置参数</h2><ul><li><code>staleTime</code> 重新获取数据的时间间隔 默认<code>0</code></li><li><code>cacheTime</code> 数据缓存时间 默认 1000 * 60 * 5 5分钟</li><li><code>retry</code> 失败重试次数 默认 3次</li><li><code>refetchOnWindowFocus</code> 窗口重新获得焦点时重新获取数据 默认 false</li><li><code>refetchOnReconnect</code> 网络重新链接</li><li><code>refetchOnMount</code> 实例重新挂载</li><li><code>enabled</code> 如果为“false”的化，“useQuery”不会触发，需要使用其返回的“refetch”来触发操作</li></ul><p>如何全局配置呢？如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import { ReactQueryConfigProvider, ReactQueryProviderConfig } from 'react-query';</span><br><span class="line"></span><br><span class="line">const queryConfig: ReactQueryProviderConfig = {</span><br><span class="line">  /**</span><br><span class="line">   * refetchOnWindowFocus 窗口获得焦点时重新获取数据</span><br><span class="line">   * staleTime 过多久重新获取服务端数据</span><br><span class="line">   * cacheTime 数据缓存时间 默认是 5 * 60 * 1000 5分钟</span><br><span class="line">   */</span><br><span class="line">  queries: { </span><br><span class="line">    refetchOnWindowFocus: true,</span><br><span class="line">    staleTime: 5 * 60 * 1000, </span><br><span class="line">    retry: 0</span><br><span class="line">  },</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;ReactQueryConfigProvider config={queryConfig}&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/ReactQueryConfigProvider&gt;</span><br><span class="line">    document.getElementById('root')</span><br><span class="line">  );</span><br></pre></td></tr></tbody></table></figure><p>也可以单独配置，如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function Todos() {</span><br><span class="line">   // 第三个参数即可传参了</span><br><span class="line">   // "enabled"参数为false的化，不会自动发起请求，而是需要调用“refetch”来触发</span><br><span class="line">   const {</span><br><span class="line">     isIdle,</span><br><span class="line">     isLoading,</span><br><span class="line">     isError,</span><br><span class="line">     data,</span><br><span class="line">     error,</span><br><span class="line">     refetch,</span><br><span class="line">     isFetching,</span><br><span class="line">   } = useQuery('todos', fetchTodoList, {</span><br><span class="line">     enabled: false,</span><br><span class="line">   })</span><br><span class="line"></span><br><span class="line">   return (</span><br><span class="line">     &lt;&gt;</span><br><span class="line">       &lt;button onClick={() =&gt; refetch()}&gt;Fetch Todos&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">       {isIdle ? (</span><br><span class="line">         'Not ready...'</span><br><span class="line">       ) : isLoading ? (</span><br><span class="line">         &lt;span&gt;Loading...&lt;/span&gt;</span><br><span class="line">       ) : isError ? (</span><br><span class="line">         &lt;span&gt;Error: {error.message}&lt;/span&gt;</span><br><span class="line">       ) : (</span><br><span class="line">         &lt;&gt;</span><br><span class="line">           &lt;ul&gt;</span><br><span class="line">             {data.map(todo =&gt; (</span><br><span class="line">               &lt;li key={todo.id}&gt;{todo.title}&lt;/li&gt;</span><br><span class="line">             ))}</span><br><span class="line">           &lt;/ul&gt;</span><br><span class="line">           &lt;div&gt;{isFetching ? 'Fetching...' : null}&lt;/div&gt;</span><br><span class="line">         &lt;/&gt;</span><br><span class="line">       )}</span><br><span class="line">     &lt;/&gt;</span><br><span class="line">   )</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="useQuery-查"><a href="#useQuery-查" class="headerlink" title="useQuery(查)"></a>useQuery(查)</h3><p><a href="https://react-query.tanstack.com/reference/useQuery">useQuery详细介绍</a></p><p><code>useQuery</code>通常包含两个参数：</p><ul><li>一个能唯一标识这个请求的 <code>Query key</code></li><li>一个真正执行请求并返回数据的异步方法</li></ul><p>ReactQuery 的缓存策略是基于这个 key 来实现的。key 值除了字符串外，还可以是一个数组或者对象，当key改变时，就会<strong>重新执行</strong><code>useQuery</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export const useProject = (param?: Partial&lt;Project&gt;) =&gt; {</span><br><span class="line">  // key变化的时候useQuery就会重新触发, 所以这里加上param</span><br><span class="line">  return useQuery&lt;Project[], Error&gt;(["projects", param], async () =&gt; {</span><br><span class="line">    </span><br><span class="line">    const res = await getProject(param || {}); // 如果不用await 返回的是AxiosPromise&lt;Project []&gt; 即 Promise&lt;AxiosResponse&lt;Project[]&gt;&gt;, 用了后， 就成了 AxiosResponse&lt;Project[]&gt;</span><br><span class="line">    return res.data;</span><br><span class="line">  });</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">export const useProjectById = (id?: number) =&gt; {</span><br><span class="line">  return useQuery&lt;Project&gt;(</span><br><span class="line">    ["project", { id }],</span><br><span class="line">    async () =&gt; {</span><br><span class="line">      const res = await getProjectById(id);</span><br><span class="line">      return res.data;</span><br><span class="line">    },</span><br><span class="line">      // 第三个参数，config</span><br><span class="line">    {</span><br><span class="line">      // 当id为undefined的时候，就不去查询了</span><br><span class="line">      enabled: !!id,</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p> 如果2s内（可设置）有相同的queryKey发出了请求，那么react-query会将其合并，并只发送一次，所以我们可以放心大胆的在不同的组件中或是在相同的组件中多次使用hook请求数据</p></blockquote><p>常用的返回值：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  const { isLoading, isError, data, error } = useProject(param)</span><br><span class="line"></span><br><span class="line">  if (isLoading) {</span><br><span class="line">    return &lt;span&gt;Loading...&lt;/span&gt;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  if (isError) {</span><br><span class="line">    return &lt;span&gt;Error: {error.message}&lt;/span&gt;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // also status === 'success', but "else" logic works, too</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      {data.map(todo =&gt; (</span><br><span class="line">        &lt;li key={todo.id}&gt;{todo.title}&lt;/li&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="useMutation-增、删、改"><a href="#useMutation-增、删、改" class="headerlink" title="useMutation(增、删、改)"></a>useMutation(增、删、改)</h3><p><a href="https://react-query.tanstack.com/reference/useMutation">useMutaion详细介绍</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export const useEditProject = () =&gt; {</span><br><span class="line">    // 获得query实例</span><br><span class="line">  const queryClient = useQueryClient();</span><br><span class="line">  return useMutation(</span><br><span class="line">      // 第一个参数仍然是一个返回Promise&lt;data&gt;的函数</span><br><span class="line">    async (params: Partial&lt;Project&gt;) =&gt; {</span><br><span class="line">      const res = await editProject(params);</span><br><span class="line">      return res.data;</span><br><span class="line">    },</span><br><span class="line">      // 第二个参数是config</span><br><span class="line">    {</span><br><span class="line">        // 成功后，就清除掉缓存中的projects，就会去重新执行所有地方的useQuery，</span><br><span class="line">        // 实现列表的刷新</span><br><span class="line">      onSuccess: () =&gt; queryClient.invalidateQueries("projects"),</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 异步mutate 需要用mutateAsync().then()时</span><br><span class="line">const { mutateAsync, error, isLoading: mutateLoading } = useMutateProject();</span><br></pre></td></tr></tbody></table></figure><p>返回值：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const { mutate } = useEditProject();</span><br><span class="line">// mutate即更新函数</span><br><span class="line">... </span><br><span class="line">     onCheckedChange={async (pin) =&gt; {</span><br><span class="line">         // 更新操作</span><br><span class="line">           await mutate({ id: project.id, pin });</span><br><span class="line">      }}</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="什么时候用react-query"><a href="#什么时候用react-query" class="headerlink" title="什么时候用react-query"></a>什么时候用react-query</h2><p>看起来<code>react-query</code>也是一种状态管理工具，那和<code>redux</code>有异曲同工之妙</p><p>首先，我们需要知道什么是服务端状态。在无意识的行为中，我们通常都将所有的组件渲染所需要的数据都放在一起管理，比如放在 State 中或者通过 Redux 这类状态管理库来管理。</p><p>然而，我们再来斟酌一下我们的数据，是不是通常都有明显的来源特征：</p><p>列表数据、详情数据等通过调接口由<strong>服务端提供的数据</strong>；<br>选中状态、折叠状态这类由<strong>客户端来维护的状态</strong>；<br>基于数据的来源，我们就可以将组件渲染所需要的状态分为<strong>服务端状态</strong>和<strong>客户端状态</strong>。</p><p>所以，我的理解是，客户端状态就交给<code>redux</code>这类库来管理，而服务端状态就交给<code>react-query</code>来管理更方便，因为它包含许多和请求数据有关的api</p><h3 id="ReactQuery-的状态管理"><a href="#ReactQuery-的状态管理" class="headerlink" title="ReactQuery 的状态管理"></a>ReactQuery 的状态管理</h3><p>ReactQuery 就将我们所有的服务端状态维护在全局，并配合它的<strong>缓存策略</strong>来执行数据的存储和更新。借助于这样的特性，我们就可以将所有跟服务端进行交互的数据从类似于 Redux 这样的状态管理工具中剥离，而全部交给 ReactQuery 来管理。</p><p>ReactQuery 会在全局维护一个服务端状态树，根据 <strong>Query key <strong>去查找状态树中是否有可用的数据，</strong>如果有则直接返回，否则则会发起请求</strong>，<strong>并将请求结果以 Query key 为主键存储到状态树中</strong>。当我们用<code>mutaion</code>改变缓存后的key后，<code>react-query</code>会监听到每一个用到这个<code>querykey</code>的地方，并重新执行<code>useQuery</code>，重新渲染用到的那个组件，注意子组件也会重新渲染。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>ReactQuery 的缓存策略使用了 stale-while-revalidate. 在 MDN 的 Cache Control 中对这个缓存策略的解释是：</p><p>客户端愿意接受陈旧的响应，同时在后台异步检查新的响应<br>在 ReactQuery 中的体现是，可以接受状态树中存储的 stale 状态数据, 并且会在缓存失效、新的查询实例被构建或 refetch 等行为后执行更新状态。</p><blockquote><p>Tips： 记得在登出等场景清空所有缓存</p><p> const logout = () =&gt; {</p><p>  return auth.logout().then((user) =&gt; {</p><p>   setUser(null);</p><p>   <strong>queryClient.clear();</strong></p><p>  });</p><p> };</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react-query&quot;&gt;&lt;a href=&quot;#react-query&quot; class=&quot;headerlink&quot; title=&quot;react-query&quot;&gt;&lt;/a&gt;react-query&lt;/h2&gt;&lt;p&gt;先上个链接&lt;a href=&quot;https://react-query.</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>用url参数来管理项目模态框状态</title>
    <link href="https://yjunuser.github.io/2021/05/23/%E7%94%A8url%E5%8F%82%E6%95%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81/"/>
    <id>https://yjunuser.github.io/2021/05/23/%E7%94%A8url%E5%8F%82%E6%95%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81/</id>
    <published>2021-05-22T16:00:00.000Z</published>
    <updated>2021-06-21T14:13:43.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="useUrlQueryParam"><a href="#useUrlQueryParam" class="headerlink" title="useUrlQueryParam"></a>useUrlQueryParam</h2><p>先是封装的一个<code>hook</code>，用于将<code>url</code>中携带的参数给取出来并变成对象：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import { useMemo } from "react";</span><br><span class="line">import { URLSearchParamsInit, useSearchParams } from "react-router-dom";</span><br><span class="line">import { cleanObject } from "./index";</span><br><span class="line"></span><br><span class="line">export const useUrlQueryParam = &lt;K extends string&gt;(keys: K[]) =&gt; {</span><br><span class="line">  const [searchParam, setSearchParam] = useSearchParams();</span><br><span class="line">  return [</span><br><span class="line">    useMemo(</span><br><span class="line">      () =&gt;</span><br><span class="line">        keys.reduce((prev, cur) =&gt; {</span><br><span class="line">          return { ...prev, [cur]: searchParam.get(cur) || "" };</span><br><span class="line">        }, {} as { [key in K]: string }),</span><br><span class="line">      // eslint-disable-next-line react-hooks/exhaustive-deps</span><br><span class="line">      [searchParam]</span><br><span class="line">    ),</span><br><span class="line">    (params: Partial&lt;{ [key in K]: unknown }&gt;) =&gt; {</span><br><span class="line">      const o = cleanObject({</span><br><span class="line">        ...Object.fromEntries(searchParam),</span><br><span class="line">        ...params,</span><br><span class="line">      }) as URLSearchParamsInit;</span><br><span class="line">      return setSearchParam(o);</span><br><span class="line">    },</span><br><span class="line">    // reduce 返回的类型是根据初始值类型来的</span><br><span class="line">  ] as const;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>使用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export const useProjectsSearchParam = () =&gt; {</span><br><span class="line">    // 传过去一个name和personId数组</span><br><span class="line">    // 返回一个诸如{name: 'yaobo', personId: '1'}的param对象</span><br><span class="line">    // 记住返回的都是字符串，要自己处理</span><br><span class="line">  const [param, setParam] = useUrlQueryParam(["name", "personId"]);</span><br><span class="line">  // 返回引用的时候一定要记得useMemo</span><br><span class="line">  const memorized = useMemo(</span><br><span class="line">    () =&gt; ({</span><br><span class="line">      // 返回对象记得加括号</span><br><span class="line">      ...param,</span><br><span class="line">      personId: Number(param.personId) || undefined,</span><br><span class="line">    }),</span><br><span class="line">    [param]</span><br><span class="line">  );</span><br><span class="line">    // 返回元组的时候，用 as const</span><br><span class="line">  return [memorized, setParam] as const;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="使用自定义hook来管理组件状态"><a href="#使用自定义hook来管理组件状态" class="headerlink" title="使用自定义hook来管理组件状态"></a>使用自定义hook来管理组件状态</h2><p>管理组件状态的方式有很多很多，但是如何把组件的状态和url联系起来呢？</p><p>使用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export const useProjectModal = () =&gt; {</span><br><span class="line">  const [{ projectCreate }, setProjectCreate] = useUrlQueryParam([</span><br><span class="line">    "projectCreate",</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  const open = () =&gt; setProjectCreate({ projectCreate: true });</span><br><span class="line">  const close = () =&gt; setProjectCreate({ projectCreate: undefined });</span><br><span class="line"></span><br><span class="line">  return {</span><br><span class="line">    projectModalOpen: projectCreate === "true",</span><br><span class="line">    open,</span><br><span class="line">    close,</span><br><span class="line">  };</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>组件中：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import { Drawer } from "antd";</span><br><span class="line">import React from "react";</span><br><span class="line">import { useProjectModal } from "./util";</span><br><span class="line"></span><br><span class="line">export const ProjectModel = () =&gt; {</span><br><span class="line">  const { projectModalOpen, close } = useProjectModal();</span><br><span class="line">  return (</span><br><span class="line">    &lt;Drawer width={"100%"} visible={projectModalOpen} onClose={close}&gt;</span><br><span class="line">      &lt;h1&gt;projectModel&lt;/h1&gt;</span><br><span class="line">    &lt;/Drawer&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>并且多个组件可以同时共享这个状态，因为这个状态是从<code>url</code>中读取的，所以所有组件都能读取并修改，相当于一个全局的状态管理。</p><p>例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export const ProjectPopover = () =&gt; {</span><br><span class="line">  const { open } = useProjectModal();</span><br><span class="line">  .....</span><br><span class="line">      &lt;ButtonNoPadding type={"link"} onClick={open}&gt;</span><br><span class="line">        创建项目</span><br><span class="line">      &lt;/ButtonNoPadding&gt;</span><br><span class="line">  ....</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>这样，当我们打开模态框时：</p><p><img src="images/artical-image/image-20210523180020172.png" alt="image-20210523180020172"></p><p>关闭后：</p><p><img src="images/artical-image/image-20210523180034456.png" alt="image-20210523180034456"></p><p>赋值<code>url</code>也能直接进入到打开模态框的页面</p><p>done</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;useUrlQueryParam&quot;&gt;&lt;a href=&quot;#useUrlQueryParam&quot; class=&quot;headerlink&quot; title=&quot;useUrlQueryParam&quot;&gt;&lt;/a&gt;useUrlQueryParam&lt;/h2&gt;&lt;p&gt;先是封装的一个&lt;code&gt;h</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react-redux</title>
    <link href="https://yjunuser.github.io/2021/05/22/Redux/"/>
    <id>https://yjunuser.github.io/2021/05/22/Redux/</id>
    <published>2021-05-21T16:00:00.000Z</published>
    <updated>2021-06-21T14:13:57.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redux安装"><a href="#redux安装" class="headerlink" title="redux安装"></a>redux安装</h2><p><code>yarn add react-redux @reduxjs/toolkit</code></p><p><code>yarn add @types/react-redux -D</code></p><h2 id="redux基本使用"><a href="#redux基本使用" class="headerlink" title="redux基本使用"></a>redux基本使用</h2><p>在<code>src</code>目录下新建一个<code>stroe</code>文件夹</p><p><code>store/index.tsx:</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> { configureStore } <span class="keyword">from</span> <span class="string">"@reduxjs/toolkit"</span>;</span><br><span class="line"><span class="keyword">import</span> { projectListSlice } <span class="keyword">from</span> <span class="string">"../screens/project-list/project-list.slice"</span>; <span class="comment">// 这是一个切片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> rootReducer = {</span><br><span class="line">  projectList: projectListSlice.reducer,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = configureStore({</span><br><span class="line">  reducer: rootReducer,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> AppDispatch = <span class="keyword">typeof</span> store.dispatch;</span><br><span class="line"><span class="comment">// 根状态树</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> RootState = ReturnType&lt;<span class="keyword">typeof</span> store.getState&gt;;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>将这个提供状态的组件包裹其他<code>app</code>:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import { ReactNode } from "react";</span><br><span class="line">import { AuthProvider } from "./auth-context";</span><br><span class="line">import { QueryClient, QueryClientProvider } from "react-query";</span><br><span class="line">// 引入store, Provider</span><br><span class="line">import { Provider } from "react-redux";</span><br><span class="line">import { store } from "../store/index";</span><br><span class="line"></span><br><span class="line">export const AppProviders = ({ children }: { children: ReactNode }) =&gt; {</span><br><span class="line">  return (</span><br><span class="line">    &lt;Provider store={store}&gt; // 包裹全局</span><br><span class="line">      &lt;QueryClientProvider client={new QueryClient()}&gt;</span><br><span class="line">        &lt;AuthProvider&gt;{children}&lt;/AuthProvider&gt;</span><br><span class="line">      &lt;/QueryClientProvider&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>创建切片:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import { createSlice } from "@reduxjs/toolkit";</span><br><span class="line">// 导入根store类型</span><br><span class="line">import { RootState } from "../../store/index";</span><br><span class="line"></span><br><span class="line">// 一个切片维护一个状态树</span><br><span class="line">interface State {</span><br><span class="line">  projectModalOpen: boolean;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 切片的state</span><br><span class="line">const initialState: State = {</span><br><span class="line">  projectModalOpen: false,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">export const projectListSlice = createSlice({</span><br><span class="line">  name: "projectListSlice", // 表示slice本身</span><br><span class="line">  initialState, // slice切片状态的默认状态</span><br><span class="line">  // reducer依然是纯洁没有副作用</span><br><span class="line">  reducers: {</span><br><span class="line">    openProjectModal(state) {</span><br><span class="line">      // 为什么可以直接给state赋值，而不是返回一个新对象呢(usereducer)?</span><br><span class="line">      // redux比较机制，a.name = 'dad' a === a true 这里reduxtoolkit借助了immer处理了， 它会创建一个新对象，将行为映射到新对象上，然后再返回</span><br><span class="line">      // 所以我们没有违反纯函数原则</span><br><span class="line">        // 其实这里相当于返回了一个新的state对象</span><br><span class="line">      state.projectModalOpen = true;</span><br><span class="line">    },</span><br><span class="line">    closeProjectModal(state) {</span><br><span class="line">      state.projectModalOpen = false;</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 导出actions</span><br><span class="line">export const projectListActions = projectListSlice.actions;</span><br><span class="line"></span><br><span class="line">// 导出切片状态，读取的是根状态里的，所以用一个函数</span><br><span class="line">export const selectProjectModelOpen = (state: RootState) =&gt; state.projectList.projectModalOpen;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>使用到组件中：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import { Drawer } from "antd";</span><br><span class="line">import React from "react";</span><br><span class="line">import { useDispatch, useSelector } from "react-redux";</span><br><span class="line">import { projectListActions } from "screens/project-list/project-list.slice";</span><br><span class="line">import { selectProjectModelOpen } from "./project-list.slice";</span><br><span class="line"></span><br><span class="line">export const ProjectModel = () =&gt; {</span><br><span class="line">  const dispatch = useDispatch();</span><br><span class="line">  // useSelect是用来读总的状态树(store)里的状态的</span><br><span class="line">  const projectModalOpen = useSelector(selectProjectModelOpen);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Drawer</span><br><span class="line">      width={"100%"}</span><br><span class="line">      visible={projectModalOpen}</span><br><span class="line">      onClose={() =&gt; dispatch(projectListActions.closeProjectModal())}</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;h1&gt;projectModel&lt;/h1&gt;</span><br><span class="line">    &lt;/Drawer&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="redux和异步结合"><a href="#redux和异步结合" class="headerlink" title="redux和异步结合"></a>redux和异步结合</h2><p>利用redux来管理登录状态：</p><p>在<code>store</code>下新建一个<code>auth.slice.ts</code>:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import { UserLogin } from "utils/type";</span><br><span class="line">import { createSlice } from "@reduxjs/toolkit";</span><br><span class="line">import * as auth from "auth-provider";</span><br><span class="line">import { AppDispatch, RootState } from "./index";</span><br><span class="line">import { getMe } from "../api/project-list";</span><br><span class="line"></span><br><span class="line">interface AuthForm {</span><br><span class="line">  username: string;</span><br><span class="line">  password: string;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface State {</span><br><span class="line">  user: UserLogin | null;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const boostrapUser = async () =&gt; {</span><br><span class="line">  let user = null;</span><br><span class="line">  const token = auth.getToken();</span><br><span class="line"></span><br><span class="line">  if (token) {</span><br><span class="line">    await getMe(token).then((res) =&gt; {</span><br><span class="line">      const data = res.data.user;</span><br><span class="line">      user = data;</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line">  return user;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">// 初始状态</span><br><span class="line">const initialState: State = {</span><br><span class="line">  user: null,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">export const authSlice = createSlice({</span><br><span class="line">  name: "auth",</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: {</span><br><span class="line">    setUser(state, action) {</span><br><span class="line">        // 更新状态</span><br><span class="line">      state.user = action.payload;</span><br><span class="line">    },</span><br><span class="line">  },</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 方便使用</span><br><span class="line">const { setUser } = authSlice.actions;</span><br><span class="line"></span><br><span class="line">// 重点，在处理异步时的情况，返回一个函数(react-thunk)</span><br><span class="line">// 检测到返回函数的时候，react-thunk就会去执行那个函数</span><br><span class="line">export const login = (form: AuthForm) =&gt; (dispatch: AppDispatch) =&gt;</span><br><span class="line">  auth.login(form).then((user) =&gt; dispatch(setUser(user)));</span><br><span class="line"></span><br><span class="line">export const register = (form: AuthForm) =&gt; (dispatch: AppDispatch) =&gt;</span><br><span class="line">  auth.register(form).then((user) =&gt; dispatch(setUser(user)));</span><br><span class="line"></span><br><span class="line">export const logout = () =&gt; (dispatch: AppDispatch) =&gt;</span><br><span class="line">  auth.logout().then(() =&gt; dispatch(setUser(null)));</span><br><span class="line"></span><br><span class="line">export const boostrap = () =&gt; (dispatch: AppDispatch) =&gt;</span><br><span class="line">  boostrapUser().then((user) =&gt; dispatch(setUser(user)));</span><br><span class="line"></span><br><span class="line">export const selectUser = (state: RootState) =&gt; state.auth.user;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>使用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export const useAuth = () =&gt; {</span><br><span class="line">    // 规定dispatch的类型，这样用then不会报错</span><br><span class="line">  const dispatch: (...args: unknown[]) =&gt; Promise&lt;UserLogin&gt; = useDispatch();</span><br><span class="line">    // 取得state里的user</span><br><span class="line">  const user = useSelector(selectUser);</span><br><span class="line">    </span><br><span class="line">  const login = useCallback(</span><br><span class="line">      // d</span><br><span class="line">    (form: AuthForm) =&gt; dispatch(authStore.login(form)),</span><br><span class="line">    [dispatch]</span><br><span class="line">  );</span><br><span class="line">  const register = useCallback(</span><br><span class="line">    (form: AuthForm) =&gt; dispatch(authStore.register(form)),</span><br><span class="line">    [dispatch]</span><br><span class="line">  );</span><br><span class="line">  const logout = useCallback(() =&gt; dispatch(authStore.logout()), [dispatch]);</span><br><span class="line">  return {</span><br><span class="line">    user,</span><br><span class="line">    login,</span><br><span class="line">    register,</span><br><span class="line">    logout,</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="react-thunk"><a href="#react-thunk" class="headerlink" title="react-thunk"></a>react-thunk</h2><p><img src="images/artical-image/image-20210522194206152.png" alt="image-20210522194206152"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;redux安装&quot;&gt;&lt;a href=&quot;#redux安装&quot; class=&quot;headerlink&quot; title=&quot;redux安装&quot;&gt;&lt;/a&gt;redux安装&lt;/h2&gt;&lt;p&gt;&lt;code&gt;yarn add react-redux @reduxjs/toolkit&lt;/code&gt;</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React惰性初始化和如何保存函数状态</title>
    <link href="https://yjunuser.github.io/2021/05/17/useState%E7%9A%84%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%87%BD%E6%95%B0/"/>
    <id>https://yjunuser.github.io/2021/05/17/useState%E7%9A%84%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%87%BD%E6%95%B0/</id>
    <published>2021-05-16T16:00:00.000Z</published>
    <updated>2021-06-21T14:14:12.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>今天在做一个功能的时候，需要用到<code>useState</code>保存一个函数，并<code>setState</code>去改变这个函数的状态，初始代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import "./styles.css";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">export default function App() {</span><br><span class="line">  const [callback, setCallback] = React.useState(() =&gt; {</span><br><span class="line">    return "init";</span><br><span class="line">  });</span><br><span class="line">  console.log(callback);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick={() =&gt;</span><br><span class="line">          setCallback(() =&gt; {</span><br><span class="line">            return "update";</span><br><span class="line">          })</span><br><span class="line">        }</span><br><span class="line">      &gt;</span><br><span class="line">        改变函数</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>很快，页面崩溃了，控制台报错：</p><p><img src="images/artical-image/image-20210517143331706.png" alt="image-20210517143331706"></p><p>一开始<code>init</code>就输出了一次，点<code>button</code>后<code>update</code>输出，这是为啥呢？我只是想保存函数，并不想让他执行</p><h2 id="惰性初始State"><a href="#惰性初始State" class="headerlink" title="惰性初始State"></a>惰性初始State</h2><p>为了调查上述问题，当然是去看<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html">React官方文档</a>，在<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html">hooksAPI</a>，这一节中，我发现了问题所在，惰性初始State：</p><h4 id="惰性初始-state"><a href="#惰性初始-state" class="headerlink" title="惰性初始 state"></a>惰性初始 state</h4><p><code>initialState</code> 参数只会在组件的<strong>初始渲染中</strong>起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [state, setState] = useState(() =&gt; {</span><br><span class="line">  const initialState = someExpensiveComputation(props);</span><br><span class="line">  return initialState;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>也就是说，给<code>useState</code>传入一个函数并不会保存函数状态，而是立即执行这个函数，并且只在初始渲染时执行，我猜测应该是为了避免一些高开销的运算，因为官方文档给的代码中函数名就是<code>someExpensiveComputation</code>。</p><p>这就解释了之前的问题，一开始我是想用<code>useState</code>保存一个函数，但这个函数立即就执行了，并且输出了<code>init</code>。</p><p>而在我后面调用<code>setState</code>去更新函数状态的时候，实际上是<code>React</code>以为你要更新那个惰性初始的<code>state</code>，于是就执行了<code>setCallback</code>，并用返回的<code>update</code>更新了callback</p><h2 id="如何保存函数"><a href="#如何保存函数" class="headerlink" title="如何保存函数"></a>如何保存函数</h2><p>那<code>state</code>该如何保存函数呢</p><h3 id="方法1-额外加一个函数"><a href="#方法1-额外加一个函数" class="headerlink" title="方法1 额外加一个函数"></a>方法1 额外加一个函数</h3><p>既然<code>useState</code>中函数作为参数是惰性初始化的意思，那我们再返回一个函数不就好了吗？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import "./styles.css";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">export default function App() {</span><br><span class="line">  const [callback, setCallback] = React.useState(() =&gt; () =&gt; {</span><br><span class="line">    alert("init");</span><br><span class="line">  });</span><br><span class="line">  console.log(callback);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick={() =&gt;</span><br><span class="line">          setCallback(() =&gt; () =&gt; {</span><br><span class="line">            alert("update");</span><br><span class="line">          })</span><br><span class="line">        }</span><br><span class="line">      &gt;</span><br><span class="line">        改变函数</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; callback()}&gt;执行函数&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我们点击<em>执行函数</em>的时候，<code>alert</code>了一个<code>init</code>，当我们<em>改变函数</em>后再去<em>执行函数</em>，<code>alert</code>了一个<code>update</code>，实现了保存函数功能</p><h3 id="方法2-useRef"><a href="#方法2-useRef" class="headerlink" title="方法2 useRef"></a>方法2 useRef</h3><p>当我们想保存一个东西的时候，想到<code>useRef</code>准没错</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import "./styles.css";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">export default function App() {</span><br><span class="line">  const callback = React.useRef(() =&gt; {</span><br><span class="line">    console.log("init");</span><br><span class="line">  });</span><br><span class="line">  console.log(callback);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick={() =&gt; {</span><br><span class="line">          callback.current = () =&gt; {</span><br><span class="line">            console.log("update");</span><br><span class="line">          };</span><br><span class="line">        }}</span><br><span class="line">      &gt;</span><br><span class="line">        改变函数</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick={callback}&gt;执行函数&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>但又出现了新的问题，点击改变函数后，输出的还是<code>init</code>，这是因为<code>useRef</code>的改变并不会引起页面重新渲染。</p><p><code>callback</code>仍然是初次渲染被赋予的函数</p><p>将代码改为如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import "./styles.css";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">export default function App() {</span><br><span class="line">  const callback = React.useRef(() =&gt; {</span><br><span class="line">    console.log("init");</span><br><span class="line">  });</span><br><span class="line">  console.log(callback);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className="App"&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick={() =&gt; {</span><br><span class="line">          callback.current = () =&gt; {</span><br><span class="line">            console.log("update");</span><br><span class="line">          };</span><br><span class="line">        }}</span><br><span class="line">      &gt;</span><br><span class="line">        改变函数</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">          // 将callback换成callback.current()</span><br><span class="line">      &lt;button onClick={() =&gt; callback.current()}&gt;执行函数&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>功能正常，完毕</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;今天在做一个功能的时候，需要用到&lt;code&gt;useState&lt;/code&gt;保存一个函数，并&lt;code&gt;setState&lt;/code&gt;去改变这</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>useMemo和useEffect</title>
    <link href="https://yjunuser.github.io/2021/05/15/useMemo%E5%92%8CuseEffect/"/>
    <id>https://yjunuser.github.io/2021/05/15/useMemo%E5%92%8CuseEffect/</id>
    <published>2021-05-14T16:00:00.000Z</published>
    <updated>2021-06-21T14:14:11.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, {Fragment} <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { useState, useMemo } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品名称列表</span></span><br><span class="line"><span class="keyword">const</span> nameList = [<span class="string">'apple'</span>, <span class="string">'peer'</span>, <span class="string">'banana'</span>, <span class="string">'lemon'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> example = <span class="function">(<span class="params">props</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 产品名称、价格</span></span><br><span class="line">    <span class="keyword">const</span> [price, setPrice] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">'apple'</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设有一个业务函数  获取产品的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getProductName</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getProductName触发'</span>)</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt;{name}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{price}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{getProductName()}&lt;/p&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setPrice(price+<span class="number">1</span>)}&gt;价钱+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setName(nameList[<span class="built_in">Math</span>.random() * nameList.length &lt;&lt; <span class="number">0</span>])}&gt;修改名字&lt;/button&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">}</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> example</span><br></pre></td></tr></tbody></table></figure><p>现在问几个问题：<br>发生下面几种情况会重新渲染界面吗（也就是<code>getProductName</code>函数会被触发）？</p><ol><li>点击价钱+1按钮？</li><li>点击修改名字按钮？</li></ol><p>很显然在进行<code>DOM</code>相关操作（如<code>setState</code>）后，都会触发<code>getProductName</code>函数，但是我们想知道这个产品的名字，产品的价格怎么变不是我们关心的，所以我们需要让这个函数只在产品名字改变的时候再触发，而不是每次重新渲染都触发。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect ?"></a>useEffect ?</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, {Fragment} <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { useState, useEffect, useCallback, useMemo } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { observer } <span class="keyword">from</span> <span class="string">'mobx-react'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nameList = [<span class="string">'apple'</span>, <span class="string">'peer'</span>, <span class="string">'banana'</span>, <span class="string">'lemon'</span>]</span><br><span class="line"><span class="keyword">const</span> Example = observer(<span class="function">(<span class="params">props</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> [price, setPrice] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">'apple'</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getProductName</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getProductName触发'</span>)</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 只对name响应</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name effect 触发'</span>)</span><br><span class="line">        getProductName()</span><br><span class="line">    }, [name])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只对price响应</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'price effect 触发'</span>)</span><br><span class="line">    }, [price])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt;{name}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{price}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{getProductName()}&lt;/p&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setPrice(price+<span class="number">1</span>)}&gt;价钱+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setName(nameList[<span class="built_in">Math</span>.random() * nameList.length &lt;&lt; <span class="number">0</span>])}&gt;修改名字&lt;/button&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">})</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example</span><br></pre></td></tr></tbody></table></figure><ol><li>先看看<code>useEffect</code>的工作顺序，若点击修改名字按钮会打印什么？</li></ol><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; getProductName触发 </span><br><span class="line">&gt; name effect 触发</span><br><span class="line">&gt; getProductName触发 </span><br></pre></td></tr></tbody></table></figure><p>官方文档有说过 <a href="https://links.jianshu.com/go?to=https://zh-hans.reactjs.org/docs/hooks-overview.html">当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数</a></p><p>所以这个顺序很好理解</p><ul><li>因为修改了名字，然后<code>react</code>更改了<code>DOM</code>，触发了<code>getProductName</code></li><li>随后调用了<code>name</code>的<code>effect</code>（在<code>dom</code>更新之后触发，这也是为什么叫做副作用）</li><li><code>effect</code>中调用了<code>getProductName</code></li></ul><p>若点击价钱+1按钮会打印什么？</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; getProductName触发 </span><br><span class="line">&gt; price effect 触发</span><br></pre></td></tr></tbody></table></figure><p>我改变的是价格，还是触发了<code>getProductName</code></p><p>稍微分析：</p><ul><li>显然当我使用<code>setPrice</code>的时候，产生<code>DOM</code>操作，刷新页面<code>DOM</code>的同时也，触发了在<code>p</code>标签中的<code>getProductName</code>函数</li><li>然后调用副作用触发了<code>price</code>的<code>effect</code></li></ul><p>就如前面我所提出的问题，我们的目标是在<code>DOM</code>发生变化时，不相关的函数不需要触发（也就是这里的<code>getProductName</code>在我修改价格的时候不应该触发），而<code>useEffect</code>只能在<code>DOM</code>更新后再触发再去控制，所以这个马后炮并没有什么🐦用</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo?"></a>useMemo?</h2><p>使用<code>useMemo</code>可以解决这个问题<br> 为什么<code>useMemo</code>可以解决？官方文档说过<a href="https://links.jianshu.com/go?to=https://zh-hans.reactjs.org/docs/hooks-reference.html%23usememo">传入 useMemo 的函数会在渲染期间执行</a>，所以使用<code>useMemo</code>就能解决之前的问题，怎么在<code>DOM</code>改变的时候，控制某些函数不被触发。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, {Fragment} <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { useState, useEffect, useCallback, useMemo } <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> { observer } <span class="keyword">from</span> <span class="string">'mobx-react'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nameList = [<span class="string">'apple'</span>, <span class="string">'peer'</span>, <span class="string">'banana'</span>, <span class="string">'lemon'</span>]</span><br><span class="line"><span class="keyword">const</span> Example = observer(<span class="function">(<span class="params">props</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">const</span> [price, setPrice] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> [name, setName] = useState(<span class="string">'apple'</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getProductName</span>(<span class="params"></span>) </span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getProductName触发'</span>)</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 只对name响应</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name effect 触发'</span>)</span><br><span class="line">        getProductName()</span><br><span class="line">    }, [name])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只对price响应</span></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'price effect 触发'</span>)</span><br><span class="line">    }, [price])</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// memo化的getProductName函数   🧬🧬🧬</span></span><br><span class="line">    <span class="keyword">const</span> memo_getProductName = useMemo(<span class="function">() =&gt;</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name memo 触发'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> name  <span class="comment">// 返回一个函数</span></span><br><span class="line">    }, [name])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Fragment&gt;</span><br><span class="line">            &lt;p&gt;{name}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;{price}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;普通的name：{getProductName()}&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;memo化的：{memo_getProductName ()}&lt;/p&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setPrice(price+<span class="number">1</span>)}&gt;价钱+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">            &lt;button onClick={<span class="function">() =&gt;</span> setName(nameList[<span class="built_in">Math</span>.random() * nameList.length &lt;&lt; <span class="number">0</span>])}&gt;修改名字&lt;/button&gt;</span><br><span class="line">        &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">})</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Example</span><br></pre></td></tr></tbody></table></figure><p>同样两个问题</p><ol><li>点击价钱+1按钮会发生什么</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; getProductName触发</span><br><span class="line">&gt; price effect 触发</span><br></pre></td></tr></tbody></table></figure><ul><li>首先<code>DOM</code>改变，触发在<code>p</code>标签中的<code>getProductName</code>函数</li><li>然后调用<code>effect</code></li></ul><p>显然我们已经成功的控制了触发（修改了显示<code>price</code>的<code>dom</code>，但是没有触发<code>memo_getProductName</code>，没有输出’’name memo 触发’’），<br> 这也是官方为什么说不能在<code>useMemo</code>中操作<code>DOM</code>之类的副作用操作，<a href="https://links.jianshu.com/go?to=https://zh-hans.reactjs.org/docs/hooks-reference.html%23usememo">不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo</a>，你可以试一下，在<code>useMemo</code>中使用<code>setState</code>你会发现会产生死循环，并且会有警告，因为<code>useMemo</code>是在渲染中进行的，你在其中操作<code>DOM</code>后，又会导致<code>memo</code>触发</p><ol><li>点击修改名字按钮会发生什么</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; name memo 触发</span><br><span class="line">&gt; getProductName触发</span><br><span class="line">&gt; name effect 触发</span><br><span class="line">&gt; getProductName触发</span><br></pre></td></tr></tbody></table></figure><ul><li>首先<code>DOM</code>变化，触发<code>name</code>的<code>memo</code>，</li><li>然后触发<code>p</code>标签内的<code>getProductName</code>函数</li><li><code>DOM</code>操作结束后触发<code>name</code>的<code>effect</code></li><li>在<code>name</code>的<code>effect</code>中触发<code>getProductName</code></li></ul><p>从这里也可以看出，<code>useMemo</code>是在**<code>DOM</code>更新前触**发的，<code>useEffect</code>是在<code>DOM</code><strong>更新后</strong>触发的就像官方所说的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>如何在React中封装一个组件</title>
    <link href="https://yjunuser.github.io/2021/05/15/%E5%A6%82%E4%BD%95%E5%9C%A8React%E4%B8%AD%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/"/>
    <id>https://yjunuser.github.io/2021/05/15/%E5%A6%82%E4%BD%95%E5%9C%A8React%E4%B8%AD%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6/</id>
    <published>2021-05-14T16:00:00.000Z</published>
    <updated>2021-06-21T14:13:35.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在React中封装一个组件"><a href="#在React中封装一个组件" class="headerlink" title="在React中封装一个组件"></a>在React中封装一个组件</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在学习<code>React</code>，看了许多教学视频，今天学到了一个封装组件较完善的方法，特此记录下来。</p><p>我们知道<code>select</code>标签经常有显示的问题，例如<code>id</code>和<code>name</code>对应不上，原因在于<code>value</code>属性的值：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Select</span><br><span class="line">          value={param.personId}</span><br><span class="line">          onChange={(value) =&gt;</span><br><span class="line">            setParam({</span><br><span class="line">              ...param,</span><br><span class="line">              personId: value,</span><br><span class="line">            })</span><br><span class="line">          }</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;Select.Option value={""}&gt;负责人&lt;/Select.Option&gt;</span><br><span class="line">          {users.map((user) =&gt; (</span><br><span class="line">            &lt;Select.Option key={user.id} value={String(user.id)}&gt;</span><br><span class="line">              {user.name}</span><br><span class="line">            &lt;/Select.Option&gt;</span><br><span class="line">          ))}</span><br><span class="line">        &lt;/Select&gt;</span><br></pre></td></tr></tbody></table></figure><p><code>Option</code>中的value值在传给<code>onChange</code>回调函数中时，如果是<code>number</code>类型，但<code>personId</code>定义的又是<code>string</code>类型的话，就不会按预期显示，而是直接用传入的值。</p><p>于是现在封装一个组件<code>id-select</code>，解决上述问题。</p><h2 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h2><p>在<code>components</code>文件夹下新建一个id-select.tsx文件，首先写好组件基本内容。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import { Select } from "antd";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export const IdSelect = () =&gt; {</span><br><span class="line">    return (</span><br><span class="line">        &lt;Select value={} onChange={}&gt;</span><br><span class="line">            &lt;Select.Option value={}&gt;{}&lt;/Select.Option&gt;</span><br><span class="line">        &lt;/Select&gt;</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们要封装一个<code>Select</code>组件，使得其</p><ul><li>value可以传入多种类型的值</li><li>onChange只会回调number | undefined类型</li><li>当 isNaN(Number(value))为true 代表选择默认类型</li><li>当选择默认类型，onChange回调undefined</li></ul><p>定义下组件所需的<code>props</code>类型:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IdSelectProps {</span><br><span class="line">  value: string | number | null | undefined;</span><br><span class="line">  onChange: (value?: number) =&gt; void;</span><br><span class="line">  defaultOptionName?: string;</span><br><span class="line">  options?: { name: string; id: number }[];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>定义一个辅助函数:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const toNumber = (value: unknown) =&gt; {</span><br><span class="line">  return isNaN(Number(value)) ? 0 : Number(value);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>完善组件:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export const IdSelect = (props: IdSelectProps) =&gt; {</span><br><span class="line">  const { value, onChange, defaultOptionName, options } = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Select</span><br><span class="line">      value={toNumber(value)}</span><br><span class="line">      onChange={(value) =&gt; onChange(toNumber(value) || undefined)}</span><br><span class="line">    &gt;</span><br><span class="line">      {defaultOptionName ? (</span><br><span class="line">        &lt;Select.Option value={0}&gt;{defaultOptionName}&lt;/Select.Option&gt;</span><br><span class="line">      ) : null}</span><br><span class="line">      {options?.map((option) =&gt; (</span><br><span class="line">        &lt;Select.Option value={option.id} key={option.id}&gt;</span><br><span class="line">          {option.name}</span><br><span class="line">        &lt;/Select.Option&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/Select&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>还有一个问题，如果我们需要用到<code>Select</code>本身的<code>props</code>呢，或者说我想改变<code>Select</code>本身的样式呢？</p><p>这就是一个<code>props</code>透传问题</p><p><code>React</code>中有专门的处理方法，将接口改为如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 继承Select组件本身的props</span><br><span class="line">type SelectProps = React.ComponentProps&lt;typeof Select&gt;;</span><br><span class="line"></span><br><span class="line">// 去掉我们接口中定义的，防止重名</span><br><span class="line">interface IdSelectProps</span><br><span class="line">  extends Omit&lt;</span><br><span class="line">    SelectProps,</span><br><span class="line">    "value" | "onChange" | "defaultOptionName" | "options"</span><br><span class="line">  &gt; {</span><br><span class="line">  value: string | number | null | undefined;</span><br><span class="line">  onChange: (value?: number) =&gt; void;</span><br><span class="line">  defaultOptionName?: string;</span><br><span class="line">  options?: { name: string; id: number }[];</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>然后传给里面的<code>Select</code>组件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export const IdSelect = (props: IdSelectProps) =&gt; {</span><br><span class="line">    // 用扩展操作符 ...rest取得props中剩余的属性</span><br><span class="line">  const { value, onChange, defaultOptionName, options, ...rest } = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Select</span><br><span class="line">      value={toNumber(value)}</span><br><span class="line">      onChange={(value) =&gt; onChange(toNumber(value) || undefined)}</span><br><span class="line">        // 传给Select</span><br><span class="line">      {...rest}</span><br><span class="line">    &gt;</span><br><span class="line">      {defaultOptionName ? (</span><br><span class="line">        &lt;Select.Option value={0}&gt;{defaultOptionName}&lt;/Select.Option&gt;</span><br><span class="line">      ) : null}</span><br><span class="line">      {options?.map((option) =&gt; (</span><br><span class="line">        &lt;Select.Option value={option.id} key={option.id}&gt;</span><br><span class="line">          {option.name}</span><br><span class="line">        &lt;/Select.Option&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/Select&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>完整代码:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import { Select } from "antd";</span><br><span class="line">import React from "react";</span><br><span class="line"></span><br><span class="line">type SelectProps = React.ComponentProps&lt;typeof Select&gt;;</span><br><span class="line"></span><br><span class="line">interface IdSelectProps</span><br><span class="line">  extends Omit&lt;</span><br><span class="line">    SelectProps,</span><br><span class="line">    "value" | "onChange" | "defaultOptionName" | "options"</span><br><span class="line">  &gt; {</span><br><span class="line">  value: string | number | null | undefined;</span><br><span class="line">  onChange: (value?: number) =&gt; void;</span><br><span class="line">  defaultOptionName?: string;</span><br><span class="line">  options?: { name: string; id: number }[];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * value 可以传入都多种类型的值</span><br><span class="line"> * onChange只会回调 number | undefined 类型</span><br><span class="line"> * 当 isNaN(Number(value))为true 代表选择默认类型</span><br><span class="line"> * 当选择默认类型，onChange回调undefined</span><br><span class="line"> */</span><br><span class="line">export const IdSelect = (props: IdSelectProps) =&gt; {</span><br><span class="line">  const { value, onChange, defaultOptionName, options, ...rest } = props;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Select</span><br><span class="line">      value={toNumber(value)}</span><br><span class="line">      onChange={(value) =&gt; onChange(toNumber(value) || undefined)}</span><br><span class="line">      {...rest}</span><br><span class="line">    &gt;</span><br><span class="line">      {defaultOptionName ? (</span><br><span class="line">        &lt;Select.Option value={0}&gt;{defaultOptionName}&lt;/Select.Option&gt;</span><br><span class="line">      ) : null}</span><br><span class="line">      {options?.map((option) =&gt; (</span><br><span class="line">        &lt;Select.Option value={option.id} key={option.id}&gt;</span><br><span class="line">          {option.name}</span><br><span class="line">        &lt;/Select.Option&gt;</span><br><span class="line">      ))}</span><br><span class="line">    &lt;/Select&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">const toNumber = (value: unknown) =&gt; {</span><br><span class="line">  return isNaN(Number(value)) ? 0 : Number(value);</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>一个简单的组件就封装好了</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import { useUser } from "screens/project-list/user";</span><br><span class="line">import { IdSelect } from "./id-select";</span><br><span class="line"></span><br><span class="line">export const UserSelect = (props: React.ComponentProps&lt;typeof IdSelect&gt;) =&gt; {</span><br><span class="line">  const { users } = useUser();</span><br><span class="line">  return &lt;IdSelect options={users || []} {...props}&gt;&lt;/IdSelect&gt;;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在React中封装一个组件&quot;&gt;&lt;a href=&quot;#在React中封装一个组件&quot; class=&quot;headerlink&quot; title=&quot;在React中封装一个组件&quot;&gt;&lt;/a&gt;在React中封装一个组件&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; cla</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react-router</title>
    <link href="https://yjunuser.github.io/2021/05/14/React%E8%B7%AF%E7%94%B1/"/>
    <id>https://yjunuser.github.io/2021/05/14/React%E8%B7%AF%E7%94%B1/</id>
    <published>2021-05-13T16:00:00.000Z</published>
    <updated>2021-05-14T07:32:49.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-router安装"><a href="#react-router安装" class="headerlink" title="react-router安装"></a>react-router安装</h2><p><code>yarn add react-router@6 react-router-dom@6</code></p><p><code>yarn add history</code></p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import { Route, Routes } from "react-router";</span><br><span class="line">import { BrowserRouter as Router } from "react-router-dom";</span><br><span class="line">import { ProjectScreen } from "screens/project";</span><br></pre></td></tr></tbody></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="example1"><a href="#example1" class="headerlink" title="example1"></a>example1</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Routes&gt;</span><br><span class="line">    &lt;Route</span><br><span class="line">      path={"/projects"}</span><br><span class="line">      element={&lt;ProjectListScreen&gt;&lt;/ProjectListScreen&gt;}</span><br><span class="line">    &gt;&lt;/Route&gt;</span><br><span class="line">    &lt;Route</span><br><span class="line">      path={"/projects/:projectsId/*"}</span><br><span class="line">      element={&lt;ProjectScreen&gt;&lt;/ProjectScreen&gt;}</span><br><span class="line">    &gt;&lt;/Route&gt;</span><br><span class="line">  &lt;/Routes&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></tbody></table></figure><p>在<code>ProjectListScreen</code>组件中:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import { Link } from "react-router-dom";</span><br><span class="line"></span><br><span class="line">   render: (value, project) =&gt; (</span><br><span class="line">            &lt;Link to={String(project.id)}&gt;{project.name}&lt;/Link&gt;</span><br><span class="line">          )</span><br><span class="line">// 注意，该组件以及在/projects路由下了，此时&lt;Link&gt;to跳转到的路由就是在/projects后面拼接，例如/projects/5</span><br></pre></td></tr></tbody></table></figure><h3 id="example2"><a href="#example2" class="headerlink" title="example2"></a>example2</h3><p>在<code>ProjectScreen</code>组件中:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from "react";</span><br><span class="line">import { Link } from "react-router-dom";</span><br><span class="line">import { Routes, Route } from "react-router";</span><br><span class="line">import { KanbanScreen } from "screens/kanban";</span><br><span class="line">import { EpicScreen } from "screens/epic";</span><br><span class="line"></span><br><span class="line">export const ProjectScreen = () =&gt; {</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;ProjectScreen&lt;/h1&gt;</span><br><span class="line">      // 注意，这里不是/kanban 如果是的话则代表直接跳到localhost/kanban</span><br><span class="line">      // 这里代表跳到 当前组件路由后面 localhost/projects/1/kanban</span><br><span class="line">      &lt;Link to={"kanban"}&gt;看板&lt;/Link&gt;</span><br><span class="line">      &lt;Link to={"epic"}&gt;epic&lt;/Link&gt;</span><br><span class="line">      &lt;Routes&gt;</span><br><span class="line">        &lt;Route path={"/kanban"} element={&lt;KanbanScreen&gt;&lt;/KanbanScreen&gt;}&gt;&lt;/Route&gt;</span><br><span class="line">        &lt;Route path={"/epic"} element={&lt;EpicScreen&gt;&lt;/EpicScreen&gt;}&gt;&lt;/Route&gt;</span><br><span class="line">          // 默认路由(上面两个匹配不到的话)</span><br><span class="line">         &lt;Navigate to={window.location.pathname + '/kanban'}&gt;&lt;/Navigate&gt;</span><br><span class="line">      &lt;/Routes&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="重置路由"><a href="#重置路由" class="headerlink" title="重置路由"></a>重置路由</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const resetRoute = () =&gt; (window.location.href = window.location.origin);</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react-router安装&quot;&gt;&lt;a href=&quot;#react-router安装&quot; class=&quot;headerlink&quot; title=&quot;react-router安装&quot;&gt;&lt;/a&gt;react-router安装&lt;/h2&gt;&lt;p&gt;&lt;code&gt;yarn add react-r</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript-as const应用</title>
    <link href="https://yjunuser.github.io/2021/05/14/TypeScript%E4%B9%8Bas%20const/"/>
    <id>https://yjunuser.github.io/2021/05/14/TypeScript%E4%B9%8Bas%20const/</id>
    <published>2021-05-13T16:00:00.000Z</published>
    <updated>2021-06-21T14:12:17.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="as-const"><a href="#as-const" class="headerlink" title="as const"></a>as const</h1><p>在项目中遇到了一个问题:</p><p><img src="images/artical-image/image-20210514184232090.png" alt="image-20210514184232090"></p><p>这个函数签名简直莫名奇妙</p><p>后来发现加上<code>as const</code></p><p><img src="images/artical-image/image-20210514184313551.png" alt="image-20210514184313551"></p><p>变得顺眼多了</p><p>那<code>as const</code>究竟是啥?</p><p>看一个例子:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a = ["jack", 1, { id: "5" }];</span><br></pre></td></tr></tbody></table></figure><p><img src="images/artical-image/image-20210514184447025.png" alt="image-20210514184447025"></p><p>a是一个元素为<code>string</code>或者<code>number</code>或者含有id对象的数组，这明显与我们的预期不符，因为我们想要一个元素为string | number | object的数组，主要原因是ts中的数组里面的类型必须一致，所以他会解析成上面那种情况。</p><p>如果我们加上<code>as const</code>呢?</p><p><img src="images/artical-image/image-20210514184705302.png" alt="image-20210514184705302"></p><p>a变成了一个数组，里面第一个元素是’jack’，第二个是1，第三个是对象</p><p><code>as const</code>主要用在数组中，在编写ts代码时，灵活运用<code>as const</code>能解决一些有趣的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;as-const&quot;&gt;&lt;a href=&quot;#as-const&quot; class=&quot;headerlink&quot; title=&quot;as const&quot;&gt;&lt;/a&gt;as const&lt;/h1&gt;&lt;p&gt;在项目中遇到了一个问题:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/artical-i</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="https://yjunuser.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Css in Js-emotion</title>
    <link href="https://yjunuser.github.io/2021/05/10/Css%20in%20Js-emotion/"/>
    <id>https://yjunuser.github.io/2021/05/10/Css%20in%20Js-emotion/</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2021-05-10T08:41:38.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="emotion的安装"><a href="#emotion的安装" class="headerlink" title="emotion的安装"></a>emotion的安装</h2><p><code>yarn add @emotion/react @emotion/styled</code></p><h2 id="emotion的基本使用"><a href="#emotion的基本使用" class="headerlink" title="emotion的基本使用"></a>emotion的基本使用</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import styled from "@emotion/styled"; // 引入emotion</span><br><span class="line">import logo from "assets/logo.svg"; // 引入图片</span><br><span class="line">import left from "assets/left.svg";</span><br><span class="line">import right from "assets/right.svg";</span><br><span class="line"></span><br><span class="line">export const UnauthenticatedApp = () =&gt; {</span><br><span class="line">  const [isRegister, setIsRegister] = useState(false);</span><br><span class="line">  return (</span><br><span class="line">    &lt;Container&gt;</span><br><span class="line">      &lt;Header&gt;&lt;/Header&gt;</span><br><span class="line">      &lt;ShadowCard&gt;</span><br><span class="line">        {isRegister ? (</span><br><span class="line">          &lt;RegisterScreen&gt;&lt;/RegisterScreen&gt;</span><br><span class="line">        ) : (</span><br><span class="line">          &lt;LoginScreen&gt;&lt;/LoginScreen&gt;</span><br><span class="line">        )}</span><br><span class="line">        &lt;Divider&gt;&lt;/Divider&gt;</span><br><span class="line">        &lt;a onClick={() =&gt; setIsRegister(!isRegister)}&gt;</span><br><span class="line">          切换到{isRegister ? "登录" : "注册"}</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">      &lt;/ShadowCard&gt;</span><br><span class="line">    &lt;/Container&gt;</span><br><span class="line">  );</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 每个style都是一个组件</span><br><span class="line">const Header = styled.header`</span><br><span class="line">  background: url(${logo}) no-repeat center;</span><br><span class="line">  padding: 5rem 0;</span><br><span class="line">  background-size: 8rem;</span><br><span class="line">  width: 100%;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const ShadowCard = styled(Card)`// 非html原生标签要用括号，比如组件库和React.component</span><br><span class="line">  width: 40rem;</span><br><span class="line">  min-height: 56rem;</span><br><span class="line">  padding: 3.2rem 4rem;</span><br><span class="line">  border-radius: 0.3rem;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  box-shadow: rgba(0, 0, 0, 0.1) 0 0 10px;</span><br><span class="line">  text-align: center;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 原生html</span><br><span class="line">const Container = styled.div`</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  justify-content: center;</span><br><span class="line">`;</span><br></pre></td></tr></tbody></table></figure><h2 id="emotion中使用grid和flex布局"><a href="#emotion中使用grid和flex布局" class="headerlink" title="emotion中使用grid和flex布局"></a>emotion中使用grid和flex布局</h2><p><code>grid</code>:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const Container = styled.div`</span><br><span class="line">  min-height: 100vh;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-rows: 6rem 1fr 6rem;</span><br><span class="line">  grid-template-columns: 20rem 1fr 20rem;</span><br><span class="line">  grid-template-areas: "header header header" "nav main aside" "footer footer footer"</span><br><span class="line"></span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 这里value没有引号</span><br><span class="line">const Header = styled.header`</span><br><span class="line">  grid-area: header; </span><br><span class="line">`;</span><br><span class="line">const Nav = styled.nav`</span><br><span class="line">  grid-area: nav;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Main = styled.main`</span><br><span class="line">  grid-area: main;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Aside = styled.aside`</span><br><span class="line">  grid-area: aside;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Footer = styled.footer`</span><br><span class="line">  grid-area: footer;</span><br><span class="line">`;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>flex</code>:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Header = styled.header`</span><br><span class="line">  grid-area: header;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-flow: row nowrap;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  align-items: center;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const HeaderLeft = styled.div`</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-flow: row nowrap;</span><br><span class="line">`;</span><br></pre></td></tr></tbody></table></figure><p><code>flex和grid使用场景?</code></p><ul><li>1维布局用flex，二维布局用grid。</li><li>从内容出发：先有一组内容（数量一般不固定），希望他们均匀分布在容器中，由内容的大小决定占据的空间–flex。</li><li>从布局触发：先规划网格（数量一般固定），然后再把元素往里填充。–grid</li></ul><h2 id="用emotion封装一个flex布局"><a href="#用emotion封装一个flex布局" class="headerlink" title="用emotion封装一个flex布局"></a>用emotion封装一个flex布局</h2><p><code>style.component</code>创建出来的是是一个<code>React.component</code>对象，那么当然可以接受参数（毕竟组件实质上也只是一个函数），将<code>style</code>写成一个组件的形式，听起来很厉害</p><p>在src下的componets文件里新建一个<code>lib.tsx</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">"@emotion/styled"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了一个flex布局，接受三个参数(between, gap, marginBottom)</span></span><br><span class="line"><span class="comment">// 参数的样子是不是很像接口?</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Row = styled.div&lt;{</span><br><span class="line">  between?: <span class="built_in">boolean</span>;</span><br><span class="line">  gap?: <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">  marginBottom?: <span class="built_in">number</span>;</span><br><span class="line">}&gt;<span class="string">`</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  flex-flow: row nowrap;</span></span><br><span class="line"><span class="string">  align-items: center;</span></span><br><span class="line"><span class="string">  justify-content: <span class="subst">${(props) =&gt; (props.between ? <span class="string">"space-between"</span> : <span class="literal">undefined</span>)}</span>;</span></span><br><span class="line"><span class="string">  margin-bottom: <span class="subst">${(props) =&gt; props.marginBottom + <span class="string">"rem"</span>}</span>;</span></span><br><span class="line"><span class="string">  &gt; * { // 这里代表所有子元素</span></span><br><span class="line"><span class="string">    margin-top: 0 !important;</span></span><br><span class="line"><span class="string">    margin-bottom: 0 !important;</span></span><br><span class="line"><span class="string">    margin-right: <span class="subst">${(props) =&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">      <span class="keyword">typeof</span> props.gap === <span class="string">"number"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        ? props.gap + <span class="string">"rem"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        : props.gap</span></span></span><br><span class="line"><span class="string"><span class="subst">        ? <span class="string">"2rem"</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        : <span class="literal">undefined</span>}</span>;</span></span><br><span class="line"><span class="string">  }</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在项目中引用并使用:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import { Row } from "components/lib";</span><br><span class="line"></span><br><span class="line">const Header = styled(Row)``;</span><br><span class="line"></span><br><span class="line">const HeaderLeft = styled(Row)``;</span><br><span class="line"></span><br><span class="line">     &lt;Header between={true}&gt; // 在这里传递参数，是不是很像组件!</span><br><span class="line">        &lt;HeaderLeft gap={true}&gt;</span><br><span class="line">          &lt;h3&gt;logo&lt;/h3&gt;</span><br><span class="line">          &lt;h3&gt;我的&lt;/h3&gt;</span><br><span class="line">          &lt;h3&gt;项目&lt;/h3&gt;</span><br><span class="line">        &lt;/HeaderLeft&gt;</span><br><span class="line">        &lt;HeaderRight&gt;</span><br><span class="line">          &lt;button onClick={() =&gt; logout()}&gt;登出&lt;/button&gt;</span><br><span class="line">        &lt;/HeaderRight&gt;</span><br><span class="line">      &lt;/Header&gt;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="emotion在行内样式中使用"><a href="#emotion在行内样式中使用" class="headerlink" title="emotion在行内样式中使用"></a>emotion在行内样式中使用</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** @jsxRuntime classic */</span><br><span class="line">/** @jsx jsx */</span><br><span class="line">// 第一行表示使用旧版传统模式手动导入运行时</span><br><span class="line">// 第二行表示指明下一行为运行时的导入</span><br><span class="line"></span><br><span class="line">&lt;Form css={{ marginBottom: "2rem" }} layout={"inline"}&gt;</span><br></pre></td></tr></tbody></table></figure><p>不是很推荐使用 css props ，可以选择使用外链 css 文件或 <code>@emotion/styled</code> 的 <em>styled-components</em> 方案，都是很不错的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;emotion的安装&quot;&gt;&lt;a href=&quot;#emotion的安装&quot; class=&quot;headerlink&quot; title=&quot;emotion的安装&quot;&gt;&lt;/a&gt;emotion的安装&lt;/h2&gt;&lt;p&gt;&lt;code&gt;yarn add @emotion/react @emotion</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="https://yjunuser.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>React中的图片</title>
    <link href="https://yjunuser.github.io/2021/05/10/React%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87/"/>
    <id>https://yjunuser.github.io/2021/05/10/React%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87/</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2021-05-10T09:03:14.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React中图片使用方法"><a href="#React中图片使用方法" class="headerlink" title="React中图片使用方法"></a>React中图片使用方法</h1><h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import softwareLogo from 'assets/software-logo.svg'</span><br><span class="line"></span><br><span class="line">&lt;img src={softwareLogo} alt="" /&gt;</span><br></pre></td></tr></tbody></table></figure><p>优点是使用方便，但不好规定样式和图片大小</p><h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import { ReactComponent as SoftwareLogo } from "assets/software-logo.svg";</span><br><span class="line">// 将图片作为一个组件引入</span><br><span class="line">&lt;SoftwareLogo width={'18rem'} color={'rgb(38, 132, 255)'}&gt;&lt;/SoftwareLogo&gt;</span><br></pre></td></tr></tbody></table></figure><p>轻易的就能改变样式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React中图片使用方法&quot;&gt;&lt;a href=&quot;#React中图片使用方法&quot; class=&quot;headerlink&quot; title=&quot;React中图片使用方法&quot;&gt;&lt;/a&gt;React中图片使用方法&lt;/h1&gt;&lt;h2 id=&quot;img&quot;&gt;&lt;a href=&quot;#img&quot; class</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="React" scheme="https://yjunuser.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript如何合理处理对象</title>
    <link href="https://yjunuser.github.io/2021/05/10/TypeScript%E8%BF%9B%E9%98%B6-%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1/"/>
    <id>https://yjunuser.github.io/2021/05/10/TypeScript%E8%BF%9B%E9%98%B6-%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2021-05-10T09:40:41.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TypeScript中的object出现的错误"><a href="#TypeScript中的object出现的错误" class="headerlink" title="TypeScript中的object出现的错误"></a>TypeScript中的object出现的错误</h2><p><code>object</code>是个很基础也很常见的引用类型，比如我用<code>typescript</code>定义一个<code>object</code>类型的变量</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">object</span>;</span><br></pre></td></tr></tbody></table></figure><p>乍一看没什么问题，但却_暗藏玄机_</p><p>比如我现在想定义一个函数，它能判断对象哪些属性是<code>number</code>类型，然后返回一个由这些属性组成的新的对象:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNumber = <span class="function">(<span class="params"><span class="built_in">object</span>: <span class="built_in">object</span></span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 在一个函数里，改变传入的对象本身是不好的</span></span><br><span class="line">    <span class="keyword">const</span> result = { ...object }</span><br><span class="line">    <span class="built_in">Object</span>.keys(result).forEach(<span class="function"><span class="params">key</span> =&gt;</span> {</span><br><span class="line">        <span class="keyword">const</span> value = result[key];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">'number'</span>) {</span><br><span class="line">            <span class="keyword">delete</span> result[key];</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样看上去没什么问题，但是编译器会报错：</p><p><img src="images/artical-image/image-20210510173337280.png" alt="image-20210510173337280"></p><p>上面提示不能用<code>key</code>作为<code>{}</code>类型的索引，但result为什么是<code>{}</code>类型呢？它为什么是个空对象呢?</p><p>这就是<code>object</code>类型的弊端，它覆盖的范围太广，几乎除了原始类型外的所有类型都是由它而衍生的，原型链的终点都有它</p><p>看下面一段代码就明白了：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">object</span>;</span><br><span class="line">a = {<span class="attr">name</span>: <span class="string">'jack'</span>}</span><br><span class="line">a = <span class="function">() =&gt;</span> {}</span><br><span class="line">a = []</span><br></pre></td></tr></tbody></table></figure><p>在这三种情况下，ts都没有报错</p><p>于是上面的问题就找到原因了，_js引擎_并不知道这个result具体是个字面量对象，还是函数或者说是索引类型，所以它非常人性化的给你返回了<code>{}</code>，而<code>key</code>当作<code>{}</code>的索引就报错了。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>通过 <strong>keyof</strong> 的方式可以获取ts 类型的属性key的值</p><p>适用与非<strong>函数</strong>场景</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = {</span><br><span class="line">    a: <span class="string">'1'</span>,</span><br><span class="line">    b: <span class="string">'2'</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 这里typeof foo =&gt; foo的类型 等同于 interface Foo { a: string; b: string; }// typeof foo === Foo，这里只所以用 typeof foo，因为这样方便，对于不想写interface的直接量对象很容易获取它的类型// keyof typeof foo这里只获取 Foo的类型的key值，注意这个keyof后面一定是 typescript的类型</span></span><br><span class="line"><span class="keyword">type</span> FooType = keyof <span class="keyword">typeof</span> foo; <span class="keyword">var</span> getPropertyValue = <span class="built_in">Object</span>.keys(foo).map(<span class="function"><span class="params">item</span> =&gt;</span> foo[item <span class="keyword">as</span> FooType])</span><br></pre></td></tr></tbody></table></figure><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>将参数类型改为_key-value_对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> isNumber = <span class="function">(<span class="params"><span class="built_in">object</span>: {[key: <span class="built_in">string</span>]: unknown}</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 在一个函数里，改变传入的对象本身是不好的</span></span><br><span class="line">  <span class="keyword">const</span> result = { ...object }</span><br><span class="line">  <span class="built_in">Object</span>.keys(result).forEach(<span class="function"><span class="params">key</span> =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> value = result[key];</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">'number'</span>) {</span><br><span class="line">          <span class="keyword">delete</span> result[key];</span><br><span class="line">      }</span><br><span class="line">  })</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TypeScript中的object出现的错误&quot;&gt;&lt;a href=&quot;#TypeScript中的object出现的错误&quot; class=&quot;headerlink&quot; title=&quot;TypeScript中的object出现的错误&quot;&gt;&lt;/a&gt;TypeScript中的objec</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="https://yjunuser.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript进阶之封装axios</title>
    <link href="https://yjunuser.github.io/2021/05/09/TypeScript%E8%BF%9B%E9%98%B6-%E5%B0%81%E8%A3%85axios/"/>
    <id>https://yjunuser.github.io/2021/05/09/TypeScript%E8%BF%9B%E9%98%B6-%E5%B0%81%E8%A3%85axios/</id>
    <published>2021-05-08T16:00:00.000Z</published>
    <updated>2021-05-09T03:00:53.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript对axios的封装"><a href="#TypeScript对axios的封装" class="headerlink" title="TypeScript对axios的封装"></a>TypeScript对axios的封装</h1><p>项目中用到了<code>typescript</code>和<code>axios</code>，对<code>axios</code>进行封装:</p><p><code>request.js</code>：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入axios模块 用{}引入的表示类型</span></span><br><span class="line"><span class="keyword">import</span> axios, {</span><br><span class="line">  AxiosInstance, <span class="comment">// axios实例</span></span><br><span class="line">  AxiosRequestConfig, <span class="comment">//axios请求config</span></span><br><span class="line">  AxiosPromise, <span class="comment">// axios返回的类型</span></span><br><span class="line">  AxiosResponse, <span class="comment">// axios返回的数据</span></span><br><span class="line">} <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line"><span class="keyword">const</span> apiBaseUrl = process.env.REACT_APP_API_URL;</span><br></pre></td></tr></tbody></table></figure><p>根据服务端返回的数据格式对返回数据进行约束:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ResponseData&lt;T = any&gt; {</span><br><span class="line">    data?: T,</span><br><span class="line">    code?: <span class="built_in">number</span>,</span><br><span class="line">    msg?: <span class="built_in">string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>创建<code>HttpRequest</code>类:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>{</span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> baseUrl: <span class="built_in">string</span> | <span class="literal">undefined</span> = apiBaseUrl,</span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> timeout: <span class="built_in">number</span> = <span class="number">5000</span></span></span><br><span class="line"><span class="params">  </span>) {</span><br><span class="line">    <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> request(options: AxiosRequestConfig): AxiosPromise {</span><br><span class="line">    <span class="keyword">const</span> instance: AxiosInstance = axios.create(); <span class="comment">// 创建实例</span></span><br><span class="line">    options = <span class="built_in">this</span>.mergeConfig(options); <span class="comment">// 合并基础路径和每个接口单独传入的配置，比如url、参数等</span></span><br><span class="line">    <span class="built_in">this</span>.interceptors(instance, options.url); <span class="comment">// 调用interceptors方法使拦截器生效</span></span><br><span class="line">    <span class="keyword">return</span> instance(options);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">interceptors</span>(<span class="params">instance: AxiosInstance, url?: <span class="built_in">string</span></span>)</span> {</span><br><span class="line">    <span class="comment">// 在这里添加请求和响应拦截</span></span><br><span class="line">    instance.interceptors.request.use(</span><br><span class="line">      (config: AxiosRequestConfig) =&gt; {</span><br><span class="line">        <span class="comment">// 接口请求的所有配置，都在这个config对象中，他的类型是AxiosRequestConfig，你可以看到他有哪些字段</span></span><br><span class="line">        <span class="comment">// 如果你要修改接口请求配置，需要修改 axios.defaults 上的字段值</span></span><br><span class="line">        <span class="keyword">let</span> token = auth.getToken();</span><br><span class="line">        <span class="keyword">if</span> (token) {</span><br><span class="line">          config.headers[<span class="string">"Authorization"</span>] = <span class="string">`Bearer <span class="subst">${token}</span>`</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">      },</span><br><span class="line">      (error) =&gt; {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">      }</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    instance.interceptors.response.use(</span><br><span class="line">      <span class="keyword">async</span> (res: AxiosResponse) =&gt; {</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> { data } = res; <span class="comment">// res的类型是AxiosResponse&lt;any&gt;，包含六个字段，其中data是服务端返回的数据</span></span><br><span class="line">        <span class="keyword">const</span> { code, msg } = data; <span class="comment">// 通常服务端会将响应状态码、提示信息、数据等放到返回的数据中</span></span><br><span class="line">        <span class="keyword">if</span> (code === <span class="number">401</span>) {</span><br><span class="line">          <span class="keyword">await</span> auth.logout();</span><br><span class="line">          <span class="built_in">window</span>.location.reload();</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.reject({ <span class="attr">message</span>: <span class="string">"请重新登录"</span> });</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">      (error) =&gt; {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">      }</span><br><span class="line">    );</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> mergeConfig(options: AxiosRequestConfig): AxiosRequestConfig {</span><br><span class="line">    <span class="comment">// 这个方法用于合并基础路径配置和接口单独配置</span></span><br><span class="line">    <span class="keyword">return</span> { ...options, <span class="attr">baseURL</span>: <span class="built_in">this</span>.baseUrl, <span class="attr">timeout</span>: <span class="built_in">this</span>.timeout };</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HttpRequest;</span><br></pre></td></tr></tbody></table></figure><p>在<code>api</code>目录下新建一个<code>index.ts</code>文件:</p><p><code>index.ts</code>:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HttpRequest <span class="keyword">from</span> <span class="string">'utils/request'</span>; <span class="comment">// 引入HttpRequest类</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'utils/request'</span> <span class="comment">// 导出request文件中的内容</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> HttpRequest() <span class="comment">// 导出HttpRequest实例</span></span><br></pre></td></tr></tbody></table></figure><p>然后就能在<code>api</code>目录中写请求接口了，例如<code>auth.ts</code>:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http, { ResponseData } <span class="keyword">from</span> <span class="string">"./index"</span>;</span><br><span class="line"><span class="keyword">import</span> { User } <span class="keyword">from</span> <span class="string">'utils/type'</span>;</span><br><span class="line"><span class="keyword">import</span> { AxiosPromise } <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求携带参数</span></span><br><span class="line"><span class="keyword">interface</span> LoginInformation {</span><br><span class="line">  username: <span class="built_in">string</span>;</span><br><span class="line">  password: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数据</span></span><br><span class="line"><span class="keyword">interface</span> Response <span class="keyword">extends</span> User {</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> userLogin = (</span><br><span class="line">  data: LoginInformation <span class="comment">// 这是请求数据</span></span><br><span class="line">): AxiosPromise&lt;ResponseData&lt;Response&gt;&gt;<span class="comment">// 这是返回数据</span></span><br><span class="line">    =&gt; {</span><br><span class="line">  <span class="keyword">return</span> http.request({</span><br><span class="line">    url: <span class="string">`/login`</span>,</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    headers: {</span><br><span class="line">      <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">    },</span><br><span class="line">    data: data,</span><br><span class="line">  });</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> userRegister = (</span><br><span class="line">  data: LoginInformation</span><br><span class="line">): AxiosPromise&lt;ResponseData&gt; =&gt; {</span><br><span class="line">  <span class="keyword">return</span> http.request({</span><br><span class="line">    url: <span class="string">`/register`</span>,</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    headers: {</span><br><span class="line">      <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">    },</span><br><span class="line">    data: data,</span><br><span class="line">  });</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>调用<code>api</code>:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> login = <span class="function">(<span class="params">data: { username: <span class="built_in">string</span>; password: <span class="built_in">string</span> | <span class="built_in">number</span>}</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> userLogin(data)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> data = res.data.user;</span><br><span class="line">      <span class="keyword">return</span> handleUserResponse(data);</span><br><span class="line">    })</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="built_in">Promise</span>.reject(error));</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>这样就能用<code>typescript</code>对请求的数据和返回的数据进行约束，同时对axios也进行了一次封装。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript对axios的封装&quot;&gt;&lt;a href=&quot;#TypeScript对axios的封装&quot; class=&quot;headerlink&quot; title=&quot;TypeScript对axios的封装&quot;&gt;&lt;/a&gt;TypeScript对axios的封装&lt;/h1&gt;&lt;p&gt;项目</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="https://yjunuser.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript进阶之utility types</title>
    <link href="https://yjunuser.github.io/2021/05/07/TypeScript%E8%BF%9B%E9%98%B6-utility%20types/"/>
    <id>https://yjunuser.github.io/2021/05/07/TypeScript%E8%BF%9B%E9%98%B6-utility%20types/</id>
    <published>2021-05-06T16:00:00.000Z</published>
    <updated>2021-05-24T03:20:42.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-utility-types"><a href="#TypeScript-utility-types" class="headerlink" title="TypeScript utility types"></a>TypeScript utility types</h1><p>下面列举了一些项目中常用的typescript工具</p><h2 id="1、Partial"><a href="#1、Partial" class="headerlink" title="1、Partial"></a>1、Partial</h2><p>构造一个所有属性都Type设置为optional的类型。该实用程序将返回一个表示给定类型的所有子集的类型，所以所有属性都会加上一个undefined</p><h3 id="example"><a href="#example" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Partial&lt;User&gt; = {<span class="attr">id</span>: <span class="string">'1'</span>}</span><br><span class="line"><span class="keyword">let</span> part: Partial&lt;User&gt; = {<span class="attr">id</span>: <span class="literal">undefined</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="2、Required"><a href="#2、Required" class="headerlink" title="2、Required"></a>2、Required</h2><p>构造一个类型，该类型由Typeset的所有属性设置为required</p><h3 id="example-1"><a href="#example-1" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Required&lt;User&gt; = {<span class="attr">id</span>: <span class="string">'1'</span>}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210507203315789.png" alt="image-20210507203315789"></p><h2 id="3、Readonly"><a href="#3、Readonly" class="headerlink" title="3、Readonly"></a>3、Readonly</h2><p>构造一个所有属性都Type设置为的类型readonly，这意味着无法重新分配所构造类型的属性。</p><h2 id="example-2"><a href="#example-2" class="headerlink" title="# example:"></a># example:</h2><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Readonly&lt;User&gt; = {<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">name</span>: <span class="string">'xiaoming'</span>, <span class="attr">token</span>: <span class="string">'abc'</span>}</span><br><span class="line">part.name = <span class="string">'xiaoli'</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210507203606006.png" alt="image-20210507203606006"></p><h2 id="4、Record-lt-Keys-Type-gt"><a href="#4、Record-lt-Keys-Type-gt" class="headerlink" title="4、Record<Keys,Type>"></a>4、Record&lt;Keys,Type&gt;</h2><p>构造一个对象类型，其属性键为Keys，属性值为Type。该实用程序可用于<strong>将一个类型的属性映射到另一个类型。</strong></p><h3 id="example-3"><a href="#example-3" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Record&lt;<span class="string">'keys'</span>, User&gt; = {<span class="attr">keys</span>: {<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">name</span>: <span class="string">'xiaoli'</span>, <span class="attr">token</span>: <span class="string">'a'</span>}}</span><br></pre></td></tr></tbody></table></figure><h2 id="5、Pick-lt-Type-Keys-gt"><a href="#5、Pick-lt-Type-Keys-gt" class="headerlink" title="5、Pick<Type, Keys>"></a>5、Pick&lt;Type, Keys&gt;</h2><p>通过Keys从中选择一组属性（字符串文字或字符串文字并集）来构造类型Type。</p><h3 id="example-4"><a href="#example-4" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Pick&lt;User, <span class="string">'id'</span> &amp; <span class="string">'token'</span>&gt; = {<span class="attr">id</span>: <span class="string">'1'</span>, <span class="attr">token</span>: <span class="string">'abc'</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="6、Omit-lt-Type-Keys-gt"><a href="#6、Omit-lt-Type-Keys-gt" class="headerlink" title="6、Omit<Type, Keys>"></a>6、Omit&lt;Type, Keys&gt;</h2><p>通过从中选择所有属性Type然后删除Keys（字符串文字或字符串文字的并集）来构造类型。</p><h3 id="example-5"><a href="#example-5" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> User {</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> part: Omit&lt;User, <span class="string">'id'</span>&gt; = {<span class="attr">name</span>: <span class="string">'xiaoming'</span>, <span class="attr">token</span>: <span class="string">'abc'</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="7、Parameters"><a href="#7、Parameters" class="headerlink" title="7、Parameters"></a>7、Parameters</h2><p>从函数类型的参数中使用的类型构造一个<strong>元组类型Type。</strong></p><h3 id="example-6"><a href="#example-6" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">str: <span class="built_in">string</span>, num: <span class="built_in">number</span></span>) =&gt;</span> {};</span><br><span class="line"><span class="keyword">let</span> params: Parameters&lt;<span class="keyword">typeof</span> fn&gt; = [<span class="string">"str"</span>, <span class="number">1</span>];</span><br></pre></td></tr></tbody></table></figure><h2 id="8、ReturnType"><a href="#8、ReturnType" class="headerlink" title="8、ReturnType"></a>8、ReturnType</h2><p>构造一个由函数的返回类型组成的<strong>类型Type。</strong></p><h3 id="example-7"><a href="#example-7" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">str: <span class="built_in">string</span>, num: <span class="built_in">number</span></span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">return</span> { str, num };</span><br><span class="line">};</span><br><span class="line"><span class="keyword">let</span> params: ReturnType&lt;<span class="keyword">typeof</span> fn&gt; = {<span class="attr">str</span>: <span class="string">'a'</span>, <span class="attr">num</span>: <span class="number">1</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="9-类型守卫"><a href="#9-类型守卫" class="headerlink" title="9.类型守卫"></a>9.类型守卫</h2><p>我们知道，<code>unknown</code>类型是不能直接访问属性的。</p><h3 id="example-8"><a href="#example-8" class="headerlink" title="example:"></a>example:</h3><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorBox</span>(<span class="params">{error}: {error: unknown}</span>) =&gt; </span>{</span><br><span class="line"><span class="keyword">if</span>(error.message) { <span class="comment">// 这里会报错， 因为不能访问unknown上的属性</span></span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这时候就可以用类型守卫来解决这个问题：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isError = (value: <span class="built_in">any</span>): value is Err =&gt; value?.message</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorBox</span>(<span class="params">{error}: {error: unknown}</span>) =&gt; </span>{</span><br><span class="line"><span class="keyword">if</span>(isError(error)) { <span class="comment">// 这里会报错， 因为不能访问unknown上的属性</span></span><br><span class="line"><span class="keyword">return</span> error</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript-utility-types&quot;&gt;&lt;a href=&quot;#TypeScript-utility-types&quot; class=&quot;headerlink&quot; title=&quot;TypeScript utility types&quot;&gt;&lt;/a&gt;TypeScript uti</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="https://yjunuser.github.io/tags/TypeScript/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaoyao日志</title>
  
  <subtitle>努力且幸运</subtitle>
  <link href="https://yjunuser.github.io/atom.xml" rel="self"/>
  
  <link href="https://yjunuser.github.io/"/>
  <updated>2021-04-27T01:33:14.610Z</updated>
  <id>https://yjunuser.github.io/</id>
  
  <author>
    <name>姚伯骏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue父组件传递props异步数据到子组件遇到的问题</title>
    <link href="https://yjunuser.github.io/2021/04/27/vue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92props%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
    <id>https://yjunuser.github.io/2021/04/27/vue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92props%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6/</id>
    <published>2021-04-26T16:00:00.000Z</published>
    <updated>2021-04-27T01:33:14.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue父组件传递props异步数据到子组件遇到的问题"><a href="#vue父组件传递props异步数据到子组件遇到的问题" class="headerlink" title="vue父组件传递props异步数据到子组件遇到的问题"></a>vue父组件传递props异步数据到子组件遇到的问题</h1><p>父组件<code>parent.vue</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// asyncData为异步获取的数据，想传递给子组件使用</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  父组件</span><br><span class="line">  &lt;child :child-data="asyncData"&gt;&lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import child from '../demo/children.vue'</span><br><span class="line"> export default {</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">   asyncData: ''</span><br><span class="line">  }),</span><br><span class="line">  components: {</span><br><span class="line">   child</span><br><span class="line">  },</span><br><span class="line">  created () {</span><br><span class="line">  },</span><br><span class="line">  mounted () {</span><br><span class="line">   // setTimeout模拟异步数据</span><br><span class="line">   setTimeout(() =&gt; {</span><br><span class="line">    this.asyncData = ' async data'</span><br><span class="line">    console.log('parent 组件结束')</span><br><span class="line">   }, 2000)</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h2><p>子组件<code>child.vue</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件{{childData}}</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childData'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">   console.log("子组件created-----   "+this.childData) // 空值</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>在这种情况下，子组件中<code>html</code>中的<code>{{childData}}</code>值会随着父组件传过来的值而改变，这是<strong>数据的响应式变化</strong>（数据的改变会引起界面变化)，但子组件<code>created</code>函数中是<strong>拿不到父组件异步传过来的数据</strong>的，这是生命周期问题。</p><h2 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h2><p>子组件<code>child.vue</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件&lt;!--这里很常见的一个问题，就是childData可以获取且没有报错，但是childData.items[0]不行，往往有个疑问为什么前面获取到值，后面获取不到呢？--&gt;</span><br><span class="line">  &lt;p&gt;{{childData.items[0]}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childData'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">   console.log(this.childData) // 空值</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><code>created</code>里面的仍然是空值， 子组件的<code>html</code>中的<code>{{childObject.items[0]}}</code>的值虽然会随着父组件的值而改变，但是过程中会报错。</p><p>是因为：<strong>首先传过来的是空，然后再异步刷新值</strong>，也就是开始时候<code>childObject.items[0]</code>等同于<code>''.item[0]</code>这样的操作，<br> 所以就会报下面的错：</p><p><img src="../images/artical-image/9441048-d1a7779ec4be1599" alt="img"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p>使用<code>v-if</code>可以解决报错问题和<code>created</code>为空问题</p><p>父组件<code>parent</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  父组件</span><br><span class="line">  &lt;child :child-object="asyncObject"  v-if="flag"&gt;&lt;/child&gt;</span><br><span class="line">  &lt;!--没拿到数据前，不渲染子组件，这样子组件created生命周期就能拿到数据了--&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from '../demo1/children.vue'</span><br><span class="line"> export default {</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">   asyncObject: '',</span><br><span class="line">   flag:false</span><br><span class="line">  }),</span><br><span class="line">  components: {</span><br><span class="line">   child</span><br><span class="line">  },</span><br><span class="line">  created () {</span><br><span class="line">  },</span><br><span class="line">  mounted () {</span><br><span class="line">   // setTimeout模拟异步数据</span><br><span class="line">   setTimeout(() =&gt; {</span><br><span class="line">    this.asyncObject = {'items': [1, 2, 3]}</span><br><span class="line">    this.flag= true</span><br><span class="line">    console.log('parent 结束')</span><br><span class="line">   }, 2000)</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>子页面 children</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件</span><br><span class="line">  &lt;p&gt;{{childObject.items[0]}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childObject'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">    console.log("子组件create-----"+JSON.stringify(this.childObject)) //能拿到了</span><br><span class="line">  },</span><br><span class="line">  methods: {</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p><img src="../images/artical-image/9441048-47f9515b58d48759" alt="img"></p></li><li><p>子组件使用<code>watch</code>来监听父组件改变的<code>prop</code>，使用<code>methods</code>来代替<code>created</code></p><p>子组件 children</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  &lt;p&gt;{{test}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: ['childObject'],</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">       test: ''</span><br><span class="line">  }),</span><br><span class="line">   watch: {</span><br><span class="line">     'childObject.items': function (new, old) { // 直接监听childObject.item属性</span><br><span class="line">      this.test = new[0]</span><br><span class="line">      this.updata()</span><br><span class="line">     }</span><br><span class="line">    },</span><br><span class="line">  methods: {</span><br><span class="line">     updata () { // 既然created只会执行一次，但是又想监听改变的值做其他事情的话，只能搬到这里咯</span><br><span class="line">      console.log(this.test)// 1</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>子组件<code>watch computed data</code> 相结合(麻烦，不推荐)</p><p>子组件children</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">   &lt;p&gt;{{test}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">    props: ['childObject'],</span><br><span class="line">    data: () =&gt; ({</span><br><span class="line">     test: ''</span><br><span class="line">    }),</span><br><span class="line">    watch: {</span><br><span class="line">     'childObject.items': function (n, o) {</span><br><span class="line">      this._test = n[0]</span><br><span class="line">     }</span><br><span class="line">    },</span><br><span class="line"> computed: {</span><br><span class="line">    _test: {</span><br><span class="line">     set (value) {</span><br><span class="line">      this.update()</span><br><span class="line">      this.test = value</span><br><span class="line">     },</span><br><span class="line">     get () {</span><br><span class="line">      return this.test</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   },</span><br><span class="line">  methods: {</span><br><span class="line">   update () {</span><br><span class="line">      console.log(this.childObject) // {items: [1,2,3]}</span><br><span class="line">     }</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li><li><p>使用<code>prop default</code>来解决<code>{{childObject.items[0]}}</code></p><p>父组件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  父组件</span><br><span class="line">  &lt;child :child-object="asyncObject"&gt;&lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import child from  '../demo4/children.vue'</span><br><span class="line"> export default {</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">   asyncObject: undefined // 这里使用null反而报0的错</span><br><span class="line">  }),</span><br><span class="line">  components: {</span><br><span class="line">   child</span><br><span class="line">  },</span><br><span class="line">  created () {</span><br><span class="line">  },</span><br><span class="line">  mounted () {</span><br><span class="line">   // setTimeout模拟异步数据</span><br><span class="line">   setTimeout(() =&gt; {</span><br><span class="line">    this.asyncObject = {'items': [1, 2, 3]}</span><br><span class="line">    console.log('parent finish')</span><br><span class="line">   }, 2000)</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>子组件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">  子组件&lt;!--1--&gt;</span><br><span class="line">  &lt;p&gt;{{childObject.items[0]}}&lt;/p&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default {</span><br><span class="line">  props: {</span><br><span class="line">   childObject: {</span><br><span class="line">    type: Object,</span><br><span class="line">    default () {</span><br><span class="line">     return {</span><br><span class="line">      items: ''</span><br><span class="line">     }</span><br><span class="line">    }</span><br><span class="line">   }</span><br><span class="line">  },</span><br><span class="line">  data: () =&gt; ({</span><br><span class="line">  }),</span><br><span class="line">  created () {</span><br><span class="line">   console.log(this.childObject) // {item: ''}</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue父组件传递props异步数据到子组件遇到的问题&quot;&gt;&lt;a href=&quot;#vue父组件传递props异步数据到子组件遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;vue父组件传递props异步数据到子组件遇到的问题&quot;&gt;&lt;/a&gt;vue父组件传递</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://yjunuser.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript安装和使用</title>
    <link href="https://yjunuser.github.io/2021/04/26/TypeScript%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://yjunuser.github.io/2021/04/26/TypeScript%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2021-04-26T08:36:43.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript安装和使用"><a href="#TypeScript安装和使用" class="headerlink" title="TypeScript安装和使用"></a>TypeScript安装和使用</h1><p><code>npm install typescript -g</code> 全局安装</p><p>使用有两种方式:</p><ul><li>tsc直接编译一个<code>.ts</code>文件，生产<code>.js</code>文件</li><li>在项目中编译，通过<code>npm run tsc</code>实现对整个项目编译</li></ul><p>在ts-practice文件夹下新建一个src目录，src目录下新建一个index.ts文件</p><p>index.ts里写入如下内容:</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="built_in">enum</span> TokenType {</span><br><span class="line">    ACCESS = <span class="string">'accessToken'</span>,</span><br><span class="line">    REFRESH = <span class="string">'refreshToken'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用<code>npm init</code>初始化项目，生成了<code>package.json</code>文件，在<code>package.json</code>文件的scripts标签里写入：</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": {</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">    "tsc": "tsc"</span><br><span class="line">  }，</span><br><span class="line">"main": "src/index.ts"</span><br></pre></td></tr></tbody></table></figure><p>然后，用<code>tsc --init</code>命令进行初始化</p><p>这时候目录下多了一个<code>tsconfig.js</code>文件，它<strong>指定了用来编译这个项目的根文件和编译选项</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: {</span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="comment">// "incremental": true,                         /* Enable incremental compilation */</span></span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span>,                                <span class="comment">/* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'. */</span></span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,                           <span class="comment">/* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */</span></span><br><span class="line">    <span class="comment">// "lib": [],                                   /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="comment">// "allowJs": true,                             /* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="comment">// "checkJs": true,                             /* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// "jsx": "preserve",                           /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */</span></span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>,                         <span class="comment">/* Generates corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "declarationMap": true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */</span></span><br><span class="line">    <span class="comment">// "sourceMap": true,                           /* Generates corresponding '.map' file. */</span></span><br><span class="line">    <span class="comment">// "outFile": "./",                             /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./lib"</span>,                              <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"./src"</span>,                             <span class="comment">/* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// "composite": true,                           /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// "tsBuildInfoFile": "./",                     /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="comment">// "removeComments": true,                      /* Do not emit comments to output. */</span></span><br><span class="line">    <span class="comment">// "noEmit": true,                              /* Do not emit outputs. */</span></span><br><span class="line">    <span class="comment">// "importHelpers": true,                       /* Import emit helpers from 'tslib'. */</span></span><br><span class="line">    <span class="comment">// "downlevelIteration": true,                  /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */</span></span><br><span class="line">    <span class="comment">// "isolatedModules": true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,                                 <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="comment">// "noImplicitAny": true,                       /* Raise error on expressions and declarations with an implied 'any' type. */</span></span><br><span class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">false</span>,                    <span class="comment">/* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// "strictFunctionTypes": true,                 /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// "strictBindCallApply": true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */</span></span><br><span class="line">    <span class="comment">// "strictPropertyInitialization": true,        /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="attr">"noImplicitThis"</span>: <span class="literal">true</span>,                      <span class="comment">/* Raise error on 'this' expressions with an implied 'any' type. */</span></span><br><span class="line">    <span class="comment">// "alwaysStrict": true,                        /* Parse in strict mode and emit "use strict" for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// "noUnusedLocals": true,                      /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// "noUnusedParameters": true,                  /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// "noImplicitReturns": true,                   /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// "noFallthroughCasesInSwitch": true,          /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line">    <span class="comment">// "noUncheckedIndexedAccess": true,            /* Include 'undefined' in index signature results */</span></span><br><span class="line">    <span class="comment">// "noPropertyAccessFromIndexSignature": true,  /* Require undeclared properties from index signatures to use element accesses. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// "moduleResolution": "node",                  /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// "baseUrl": "./",                             /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// "paths": {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */</span></span><br><span class="line">    <span class="comment">// "rootDirs": [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// "typeRoots": [],                             /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// "types": [],                                 /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// "allowSyntheticDefaultImports": true,        /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,                        <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */</span></span><br><span class="line">    <span class="comment">// "preserveSymlinks": true,                    /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// "allowUmdGlobalAccess": true,                /* Allow accessing UMD globals from modules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// "sourceRoot": "",                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// "mapRoot": "",                               /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// "inlineSourceMap": true,                     /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// "inlineSources": true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// "experimentalDecorators": true,              /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// "emitDecoratorMetadata": true,               /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="attr">"skipLibCheck"</span>: <span class="literal">true</span>,                           <span class="comment">/* Skip type checking of declaration files. */</span></span><br><span class="line">    <span class="attr">"forceConsistentCasingInFileNames"</span>: <span class="literal">true</span>        <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  },</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>, <span class="string">"lib"</span>, <span class="string">"**/*.test.ts"</span>],</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src"</span>]</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>执行<code>npm install</code>下载项目所需的依赖，<code>node_modules</code>是项目的所有依赖包，<code>package-lock.json</code>文件将项目依赖包的版本锁定，避免<strong>依赖包大升级造成的不兼容问题</strong>。</p><p>在根目录执行<code>npm run tes</code></p><p><img src="E:\blog\hexo-blog\source\images\artical-image\image-20210426163128179.png" alt="image-20210426163128179"></p><p>得到编译后结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript安装和使用&quot;&gt;&lt;a href=&quot;#TypeScript安装和使用&quot; class=&quot;headerlink&quot; title=&quot;TypeScript安装和使用&quot;&gt;&lt;/a&gt;TypeScript安装和使用&lt;/h1&gt;&lt;p&gt;&lt;code&gt;npm install </summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="https://yjunuser.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript基础类型</title>
    <link href="https://yjunuser.github.io/2021/04/26/TypeScript%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    <id>https://yjunuser.github.io/2021/04/26/TypeScript%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2021-05-02T06:33:39.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-基础类型"><a href="#TypeScript-基础类型" class="headerlink" title="TypeScript 基础类型"></a>TypeScript 基础类型</h1><p>TypeScript 中的类型有</p><blockquote><p>TypeScript中的基础类型都是小写，大写开头的表示的是javascript的构造函数</p></blockquote><ul><li>原始类型<ul><li>boolean</li><li>number</li><li>string</li><li>bigint</li><li>null</li><li>undefined</li><li>symbol</li><li>void</li></ul></li><li>元组 tuple</li><li>枚举 enum</li><li>任意 any</li><li>unknown</li><li>never</li><li>数组 Array</li><li>对象 object</li></ul><h2 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h2><p>当一个函数没有返回值时，可以声明为void</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>(<span class="params"></span>): <span class="title">void</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还可以声明一个<code>void</code>类型的变量，但只能赋值为<code>undefined</code>或者<code>null</code></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nothing: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><h2 id="null-类型和-undefined-类型"><a href="#null-类型和-undefined-类型" class="headerlink" title="null 类型和 undefined 类型"></a>null 类型和 undefined 类型</h2><p><code>undefined</code> 和 <code>null</code> 是<strong>所有类型的子类型</strong>。</p><p>一般项目是默认开启 <code>--strictNullChecks</code> 检测的，如果你将 <code>tsconfig.json</code> 中 <code>strictNullChecks</code> 选项设置为 <code>false</code>，下面这种操作不会报错，不过尽量不要这么做：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>数组类型有两种表示方法，第一种在元素类型后接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> names: <span class="built_in">string</span>[] = [<span class="string">'Sherlock'</span>, <span class="string">'Watson'</span>, <span class="string">'Mrs. Hudson'</span>]</span><br></pre></td></tr></tbody></table></figure><p>另一种方式是使用数组泛型（<em>泛型后续会单独介绍</em>），<code>Array&lt;元素类型&gt;</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'Sherlock'</span>, <span class="string">'Watson'</span>, <span class="string">'Mrs. Hudson'</span>]</span><br></pre></td></tr></tbody></table></figure><p>混合各种元素类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br></pre></td></tr></tbody></table></figure><p>推荐使用第一种数组类型的表示方法，书写比较简洁直观。</p><h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>有时候接收来自用户的输入，我们是不能确定其变量类型的。这种情况下，我们不希望类型检查器对这些值进行检查，而是直接让它们通过编译阶段的检查，此时可以使用 <code>any</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input: <span class="built_in">any</span> = <span class="string">'nothing'</span></span><br><span class="line"></span><br><span class="line">input = <span class="number">0</span>                   <span class="comment">// ok</span></span><br><span class="line">input = <span class="literal">true</span>                <span class="comment">// ok</span></span><br><span class="line">input = []                  <span class="comment">// ok</span></span><br><span class="line">input = <span class="literal">null</span>                <span class="comment">// ok</span></span><br><span class="line">input = <span class="built_in">Symbol</span>(<span class="string">'any'</span>)       <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure><p>如果一个数据是 any 类型，那么可以访问它的任意属性，即使这个属性不存在：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anything: <span class="built_in">any</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">anything.eat()              <span class="comment">// ok</span></span><br><span class="line">anything.name               <span class="comment">// ok</span></span><br><span class="line">anything[<span class="number">0</span>]                 <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">new</span> anything()              <span class="comment">// ok</span></span><br><span class="line">anything()                  <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure><p>从上面的例子中可以看到，any 类型几乎可以做任何操作，这样很容易编写类型正确但是执行异常的代码。我们使用 TypeScript 就是为了代码的健壮性，所以要<strong>尽量减少 any 的使用</strong>。</p><blockquote><p>any类型很像在javascript直接定义一个变量</p></blockquote><h2 id="容易混淆的点"><a href="#容易混淆的点" class="headerlink" title="容易混淆的点"></a>容易混淆的点</h2><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">Number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">'10'</span>) <span class="comment">// a === 10 为 false</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">number</span> = <span class="built_in">Number</span>(<span class="string">'10'</span>) <span class="comment">// b === 10 为 true</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，通过 <code>new Number('10')</code> 得到的是<strong>一个构造函数，本质是一个对象</strong>。</p><p>第 2 行，<code>Number('10')</code> 与 <code>10</code> 都是声明一个数字 10 的方法，本质就是一个数字。</p><p>第 4 - 5 行，<code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。<code>a</code> 是一个对象，它的 <code>__proto__</code> 属性指向该对象的构造函数的原型对象 <code>Number</code>，所以为 <code>true</code>。<code>b</code> 是一个数字，所以为 <code>false</code>。</p><p><code>__proto__</code> 是非标准属性，你也可以使用 <strong><code>Object.getPrototypeOf()</code></strong> 方法来访问一个对象的原型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__ === <span class="built_in">Object</span>.getPrototypeOf(a) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h2 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h2><p><code>bigint</code> 是一种基本数据类型（primitive data type）。</p><p>JavaScript 中可以用 <code>Number</code> 表示的最大整数为 <code>2^53 - 1</code>，可以写为 <code>Number.MAX_SAFE_INTEGER</code>。如果超过了这个界限，可以用 <code>BigInt</code>来表示，它可以表示任意大的整数。</p><p>在一个整数字面量后加 <code>n</code> 的方式定义一个 <code>BigInt</code>，如：<code>10n</code> 或者调用函数 <code>BigInt()</code>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theBiggestInt: bigint = <span class="number">9007199254740991n</span></span><br><span class="line"><span class="keyword">const</span> alsoHuge: bigint = <span class="built_in">BigInt</span>(<span class="number">9007199254740991</span>)</span><br><span class="line"><span class="keyword">const</span> hugeString: bigint = <span class="built_in">BigInt</span>(<span class="string">"9007199254740991"</span>)</span><br><span class="line"></span><br><span class="line">theBiggestInt === alsoHuge <span class="comment">// true</span></span><br><span class="line">theBiggestInt === hugeString <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><code>BigInt</code> 与 <code>Number</code> 的不同点：</p><ul><li><code>BigInt</code> 不能用于 <code>Math</code> 对象中的方法。</li><li><code>BigInt</code> 不能和任何 <code>Number</code> 实例混合运算，两者必须转换成同一种类型。</li><li><code>BigInt</code> 变量在转换为 <code>Number</code> 变量时可能会丢失精度。</li></ul><p><code>Number</code> 和 <code>BigInt</code> 可以进行比较：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0n</span> === <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1n</span> &lt; <span class="number">2</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">1</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">2</span>   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">2</span>  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt;= <span class="number">2</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>条件判断：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0n</span>) {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'条件成立!'</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'条件不成立!'</span>); <span class="comment">// 输出结果</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> || <span class="number">10n</span>    <span class="comment">// 10n</span></span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> &amp;&amp; <span class="number">10n</span>    <span class="comment">// 0n</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0n</span>)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">10n</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="number">10n</span>         <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!<span class="number">0n</span>          <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p><code>symbol</code> 是一种基本数据类型。</p><p><code>Symbol()</code> 函数会返回 <code>symbol</code> 类型的值。每个从 <code>Symbol()</code> 返回的 <code>symbol</code> 值都是<strong>唯一</strong>的。</p><p>使用 Symbol() 创建新的 symbol 类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym1: symbol = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> sym2: symbol = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">const</span> sym3: symbol = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line">代码块<span class="number">123</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码创建了三个新的 symbol 类型，但要注意每个从 Symbol() 返回的值都是唯一的：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sym2 === sym3) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 每个 <code>Symbol()</code> 方法返回的值都是唯一的，所以，sym2 和 sym3 不相等。</p><p>Symbol() 作为构造函数是不完整的：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="keyword">new</span> <span class="built_in">Symbol</span>() <span class="comment">// TypeError</span></span><br></pre></td></tr></tbody></table></figure><p>这种语法会报错，是因为从 ECMAScript 6 开始<strong>围绕原始数据类型创建一个显式包装器对象已不再被支持</strong>，但因历史遗留原因， <code>new Boolean()</code>、<code>new String()</code> 以及 <code>new Number()</code> 仍可被创建：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>()   <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">const</span> bigint = <span class="keyword">new</span> <span class="built_in">BigInt</span>()   <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>()   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>() <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> = <span class="keyword">new</span> <span class="built_in">String</span>()   <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><h4 id="symbol使用场景"><a href="#symbol使用场景" class="headerlink" title="symbol使用场景"></a>symbol使用场景</h4><ul><li>当一个对象有较多属性时（<em>往往分布在不同文件中由模块组合而成</em>），很容易将某个属性名覆盖掉，使用 <code>Symbol</code> 值可以避免这一现象，比如 <code>vue-router</code> 中的 <code>name</code> 属性。</li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js 文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> aRouter = {</span><br><span class="line">  path: <span class="string">'/index'</span>,</span><br><span class="line">  name: <span class="built_in">Symbol</span>(<span class="string">'index'</span>),</span><br><span class="line">  component: Index</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bRouter = {</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="built_in">Symbol</span>(<span class="string">'index'</span>), <span class="comment">// 不重复</span></span><br><span class="line">  component: Home</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes.js 文件</span></span><br><span class="line"><span class="keyword">import</span> { aRouter } <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> { bRouter } <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  aRouter,</span><br><span class="line">  bRouter</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 两个不同文件使用了同样的 <code>Symbol('index')</code> 作为属性 name 的值，因 symbol 类型的唯一性，就避免了<strong>重复定义</strong>。</p><ul><li>模拟类的<strong>私有方法</strong></li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permission: symbol = <span class="built_in">Symbol</span>(<span class="string">'permission'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auth</span> </span>{</span><br><span class="line">  [permission]() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种情况<strong>通过类的实例是</strong>无法取到该方法，模拟类的私有方法。</p><p>但是，TypeScript 是可以使用 <code>private</code> 关键字的，所以这种方法可以在 JavaScript 中使用。</p><ul><li>判断是否可以用 <code>for...of</code> 迭代</li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> iterable) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n <span class="keyword">of</span> iterable) {</span><br><span class="line">      <span class="built_in">console</span>.log(n)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个知识点后续会在 <code>迭代器</code> 那一节会着重介绍，这里可以先知晓：</p><p>   <code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。<br>   <code>for...of</code> 只能迭代可枚举属性。</p><ul><li>Symbol.prototype.description</li></ul><p><code>Symbol([description])</code> 中可选的字符串即为这个 Symbol 的描述，如果想要获取这个描述：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">'imooc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sym);               <span class="comment">// Symbol(imooc)</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.toString());    <span class="comment">// Symbol(imooc)</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.description);   <span class="comment">// imooc</span></span><br></pre></td></tr></tbody></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>通过元组可以存储不同类型的元素，而非像数组那样只能存储相同元素类型（any[] 除外）。</p><p>声明一个由 <code>string</code> 和 <code>number</code> 构成的元组：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]   <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list1: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="number">1887</span>, <span class="string">'Sherlock'</span>]  <span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 元组中规定的元素类型<strong>顺序必须是完全对照的</strong>，而且<strong>不能多、不能少</strong>（数量也必须一样，数组有了长度）<code>list1</code> 中定义的第一个元素为 <code>string</code>类型，不能赋值为 <code>number</code>类型的数据。</p><p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">0</span>].substr(<span class="number">1</span>)  <span class="comment">// ok</span></span><br><span class="line">list[<span class="number">1</span>].substr(<span class="number">1</span>)  <span class="comment">// Property 'substr' does not exist on type 'number'.</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 3 行，<code>list[0]</code> 是一个字符串类型，拥有 substr() 方法。</p><p>第 4 行，<code>list[1]</code> 是一个数字类型，没有 substr() 方法，所以报错。</p><p>要注意元组的越界问题，虽然<strong>可以越界添加元素</strong>（<em>不建议</em>），但是<strong>不可越界访问</strong>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br><span class="line">list.push(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(list)      <span class="comment">// ok [ 'Sherlock', 1887, 'hello world' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(list[<span class="number">2</span>])   <span class="comment">// Tuple type '[string, number]' of length '2' has no element at index '2'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，向一个声明了<strong>只有两个元素的元组</strong>继续添加元素，这种操作虽然可行，但是严重不建议！</p><p>第 5 行，该元组只有两个元素，不可越界访问第三个元素。</p><p>元组类型允许在元素类型后缀一个 <code>?</code> 来说明元素是可选的：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">number</span>, <span class="built_in">string</span>?, <span class="built_in">boolean</span>?]</span><br><span class="line">list = [<span class="number">10</span>, <span class="string">'Sherlock'</span>, <span class="literal">true</span>]</span><br><span class="line">list = [<span class="number">10</span>, <span class="string">'Sherlock'</span>]</span><br><span class="line">list = [<span class="number">10</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>可选元素必须在必选元素的后面，也就是如果一个元素后缀了 <code>?</code>号，其后的所有元素都要后缀 <code>?</code>号</strong>。</p><p>元组可以作为参数传递给函数，函数的 Rest 形参可以定义为元组类型（动态长度）：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">rest</span>(<span class="params">...args: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>]</span>): <span class="title">void</span></span></span><br></pre></td></tr></tbody></table></figure><p>等价于：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">rest</span>(<span class="params">arg1: <span class="built_in">number</span>, arg2: <span class="built_in">string</span>, arg3: <span class="built_in">boolean</span></span>): <span class="title">void</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>TIPS：</strong> 在声明文件（.d.ts）中，关键字 declare 表示声明作用。声明文件用于编写第三方类库，通过配置 <code>tsconfig.json</code> 文件中的 <code>declaration 为 true</code>，在编译时可自行生成。</p></blockquote><p>还可以这样：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">number</span>, ...string[]] = [<span class="number">10</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list1: [<span class="built_in">string</span>, ...number[]] = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> Rest 元素指定了元组类型是无限扩展的，可能有零个或多个具有数组元素类型的额外元素。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>需要定义一组相同主题的常量数据时，应该立即想到枚举类型。在学习过程中，需要注意枚举类型的<strong>正向映射和反向映射</strong></p><p>使用枚举我们可以定义一些<strong>带名字的常量</strong>。TypeScript 支持<strong>数字</strong>的和基于<strong>字符串</strong>的枚举。</p><p>枚举类型弥补了 JavaScript 的设计不足，很多语言都拥有枚举类型。</p><p>当我们需要一组相同主题下的数据时，枚举类型就很有用了。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction { Up, Down, Left, Right }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Months { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Size { big = <span class="string">'大'</span>, medium = <span class="string">'中'</span>, small = <span class="string">'小'</span> }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Agency { province = <span class="number">1</span>, city = <span class="number">2</span>, district = <span class="number">3</span> }</span><br></pre></td></tr></tbody></table></figure><p>声明一个枚举类型，如果没有赋值，它们的值默认为<strong>数字类型</strong>且从 0 开始累加：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Months.Jan === <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">Months.Feb === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">Months.Mar === <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line">Months.Apr === <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>现实中月份是从 1 月开始的，那么只需要这样：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第一个数字赋值，往后依次累加</span></span><br><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Months.Jan === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">Months.Feb === <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line">Months.Mar === <span class="number">3</span> <span class="comment">// true</span></span><br><span class="line">Months.Apr === <span class="number">4</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>枚举类型的值为<strong>字符串类型</strong>：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> TokenType {</span><br><span class="line">  ACCESS = <span class="string">'accessToken'</span>,</span><br><span class="line">  REFRESH = <span class="string">'refreshToken'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种不同的取值写法</span></span><br><span class="line"><span class="built_in">console</span>.log(TokenType.ACCESS === <span class="string">'accessToken'</span>)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(TokenType[<span class="string">'REFRESH'</span>] === <span class="string">'refreshToken'</span>)   <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 枚举的取值，有 <code>TokenType.ACCESS</code> 和 <code>TokenType['ACCESS']</code> 这两种不同的写法，效果是相同的。</p><p><strong>数字类型和字符串类型可以混合使用，但是不建议：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> BooleanLikeHeterogeneousEnum {</span><br><span class="line">    No = <span class="number">0</span>,</span><br><span class="line">    Yes = <span class="string">"YES"</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>枚举类型的值可以是一个简单的<strong>计算表达式</strong>：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Calculate {</span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">  expired = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>,</span><br><span class="line">  length = <span class="string">'imooc'</span>.length,</span><br><span class="line">  plus = <span class="string">'hello '</span> + <span class="string">'world'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.expired)   <span class="comment">// 86400</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.length)    <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.plus)      <span class="comment">// hello world</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Tips:</strong></p><ul><li>计算结果必须为常量。</li><li>计算项必须放在最后。</li></ul><p>所谓的反向映射就是指枚举的取值，不但可以正向的 <code>Months.Jan</code> 这样取值，也可以反向的 <code>Months[1]</code> 这样取值。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Months.Mar === <span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么反过来能取到 Months[3] 的值吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(Months[<span class="number">3</span>])  <span class="comment">// 'Mar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以</span></span><br><span class="line"><span class="built_in">console</span>.log(Months.Mar === <span class="number">3</span>)     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Months[<span class="number">3</span>] === <span class="string">'Mar'</span>)  <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Tips:</strong></p><ol><li>字符串枚举成员不会生成反向映射。</li><li>枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。</li></ol><p>在枚举上使用 <code>const</code> 修饰符：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> month = Months.Mar</span><br></pre></td></tr></tbody></table></figure><p>查看一下编译后的内容：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> month = <span class="number">3</span> <span class="comment">/* Mar */</span></span><br><span class="line">代码块<span class="number">12</span></span><br></pre></td></tr></tbody></table></figure><p>发现枚举类型应该编译出的对象没有了，只剩下 <code>month</code> 常量。这就是使用 <code>const</code> 关键字声明枚举的作用。因为变量 <code>month</code> 已经使用过枚举类型，在编译阶段 TypeScript 就将枚举类型抹去，这也是<strong>性能提升</strong>的一种方案。</p><p>分开声明名称相同的枚举类型，会<strong>自动合并</strong>：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  May = <span class="number">5</span>,</span><br><span class="line">  Jun</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Months.Apr) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(Months.Jun) <span class="comment">// 6</span></span><br></pre></td></tr></tbody></table></figure><h1 id="TypeScript-Never-与-Unknown"><a href="#TypeScript-Never-与-Unknown" class="headerlink" title="TypeScript Never 与 Unknown"></a>TypeScript Never 与 Unknown</h1><p>本节介绍 never 和 unknown 类型，其中 unknown 类型作为 any 类型对应的安全类型使用起来更加安全，如果有<strong>any 类型的使用需求</strong>，应尽量使用 **unknown 类型来替代 **any 类型。</p><p><code>never</code> 类型表示那些永不存在的值的类型。</p><p><code>unknown</code> 类型是 <code>any</code> 类型对应的安全类型。</p><h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p>一个抛出异常的函数表达式，其函数返回值类型为 never：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message:<span class="built_in">string</span></span>): <span class="title">never</span> </span>{</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同样的，不会有返回值的函数表达式，其函数返回值类型也为 never:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断的返回值类型为 never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>): <span class="title">never</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不能取得值的地方：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo {</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'foo'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bar {</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'bar'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> All = Foo | Bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleValue</span>(<span class="params">val: All</span>) </span>{</span><br><span class="line">  <span class="keyword">switch</span> (val.type) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'foo'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'bar'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 此处不能取值</span></span><br><span class="line">      <span class="keyword">const</span> exhaustiveCheck: <span class="built_in">never</span> = val</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Unknown"><a href="#Unknown" class="headerlink" title="Unknown"></a>Unknown</h2><p>我们知道 any 无需事先执行任何类型的检查：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="number">10</span>               <span class="comment">// OK</span></span><br><span class="line">value = <span class="string">"Hello World"</span>    <span class="comment">// OK</span></span><br><span class="line">value = []               <span class="comment">// OK</span></span><br><span class="line">value = {}               <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Math</span>.random      <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">null</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">undefined</span>        <span class="comment">// OK</span></span><br><span class="line">value = <span class="keyword">new</span> <span class="built_in">TypeError</span>()  <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)   <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">value.foo.bar            <span class="comment">// OK</span></span><br><span class="line">value.trim()             <span class="comment">// OK</span></span><br><span class="line">value()                  <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">new</span> value()              <span class="comment">// OK</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]              <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><p>在许多情况下，这太宽松了。 <code>unknown</code> 类型呢？</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="number">10</span>               <span class="comment">// OK</span></span><br><span class="line">value = <span class="string">"Hello World"</span>    <span class="comment">// OK</span></span><br><span class="line">value = []               <span class="comment">// OK</span></span><br><span class="line">value = {}               <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Math</span>.random      <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">null</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">undefined</span>        <span class="comment">// OK</span></span><br><span class="line">value = <span class="keyword">new</span> <span class="built_in">TypeError</span>()  <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)   <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><p>所有对该 <code>value</code> 变量的分配都被认为是类型正确的。</p><p>但是，如果尝试：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value1: unknown = value   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> value2: <span class="built_in">any</span> = value       <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value3: <span class="built_in">boolean</span> = value   <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value4: <span class="built_in">number</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value5: <span class="built_in">string</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value6: <span class="built_in">object</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value7: <span class="built_in">any</span>[] = value     <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，该 unknown 类型<strong>只能分配给 any 类型和 unknown 类型</strong>本身。</p><p>现在继续尝试：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line">value.foo.bar  <span class="comment">// Error</span></span><br><span class="line">value.trim()   <span class="comment">// Error</span></span><br><span class="line">value()        <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">new</span> value()    <span class="comment">// Error</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]    <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure><p><strong><code>unknown</code> 类型在被确定为某个类型之前，不能被进行诸如函数执行、实例化等操作，一定程度上对类型进行了保护。</strong></p><blockquote><p>在那些将取得任意值，但不知道具体类型的地方使用 <code>unknown</code>，而非 <code>any</code>。</p></blockquote><h1 id="TypeScript-接口-Interface"><a href="#TypeScript-接口-Interface" class="headerlink" title="TypeScript 接口(Interface)"></a>TypeScript 接口(Interface)</h1><blockquote><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。——官方定义</p></blockquote><p>接口是对 JavaScript 本身的随意性进行约束，通过定义一个接口，<strong>约定了变量、类、函数等</strong>应该按照什么样的格式进行声明，实现多人合作的一致性。TypeScript 编译器依赖接口用于类型检查，最终编译为 JavaScript 后，接口将会被移除。</p><p><strong>接口主要是对对象、函数、类的类型做一些定义</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line"><span class="keyword">interface</span> DemoInterface {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在声明一个<strong>对象</strong>、<strong>函数</strong>或者<strong>类</strong>时，先定义接口，确保其数据结构的一致性。</p><p>在多人协作时，定义接口尤为重要。</p><h2 id="接口的好处"><a href="#接口的好处" class="headerlink" title="接口的好处"></a>接口的好处</h2><p>过去我们写 JavaScript 定义一个函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClothesInfo</span>(<span class="params">clothes</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(clothes.price)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClothes = {</span><br><span class="line">  color: <span class="string">'black'</span>, </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line">getClothesInfo(myClothes)</span><br></pre></td></tr></tbody></table></figure><p>之前我们写 JavaScript 这样是很正常的，但同时你可能会遇到下面这些问题:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getClothesInfo() <span class="comment">// Uncaught TypeError: Cannot read property 'price' of undefined</span></span><br><span class="line">getClothesInfo({ <span class="attr">color</span>: <span class="string">'black'</span> }) <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>相信原因你也知道，JavaScript 是 <code>弱类型</code> 语言，并不会对传入的参数进行任何检测，错误在运行时才被发现。那么通过定义 <code>接口</code>，在编译阶段甚至开发阶段就避免掉这类错误，接口<strong>将检查类型是否和某种结构做匹配</strong>。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>下面通过接口的方式重写之前的例子：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClothesInfo</span>(<span class="params">clothes: Clothes</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(clothes.price)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  color: <span class="string">'black'</span>, </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getClothesInfo(myClothes)</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 代码中，定义了一个接口 <code>Clothes</code>，在传入的变量 <code>clothes</code> 中，它的类型为 <code>Clothes</code>。这样，就约束了这个传入对象的 <code>外形</code> 与接口定义一致。只要传入的对象满足上面的类型约束，那么它就是被允许的。</p><p><strong>Tips：</strong></p><ol><li>定义接口要 <code>首字母大写</code>。</li><li>只需要关注值的 <code>外形</code>，并不像其他语言一样，定义接口是为了实现。</li><li>如果没有特殊声明，定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致。</li></ol><h2 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h2><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口中的属性不全是必需的。可选属性的含义是该属性在被变量定义时可以不存在。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以不定义属性 color</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p><p>这时，<strong>仍不允许添加未定义的属性</strong>，如果引用了不存在的属性时 TS 将直接捕获错误。</p><h3 id="只读属性-和const对应，一个是属性一个是变量"><a href="#只读属性-和const对应，一个是属性一个是变量" class="headerlink" title="只读属性(和const对应，一个是属性一个是变量)"></a>只读属性(和const对应，一个是属性一个是变量)</h3><p>一些对象属性<strong>只能在对象刚刚创建的时候修改其值</strong>。你可以在属性名前用 <code>readonly</code> 来指定只读属性，比如价格是不能被修改的:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的时候给 price 赋值</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可修改</span></span><br><span class="line">myClothes.price = <span class="number">100</span></span><br><span class="line"><span class="comment">// error TS2540: Cannot assign to 'price' because it is a constant or a read-only property</span></span><br></pre></td></tr></tbody></table></figure><p>TypeScript 可以通过 <code>ReadonlyArray&lt;T&gt;</code> 设置数组为只读，那么它的所有<strong>写方法</strong>都会失效。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">6</span>; <span class="comment">// Index signature in type 'readonly number[]' only permits reading</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 代码中的泛型语法在之后会有专门的小节介绍。</p><h4 id="readonlyvsconst"><a href="#readonlyvsconst" class="headerlink" title="readonlyvsconst`"></a>readonly<code>vs</code>const`</h4><p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为<strong>变量使用还是做为一个属性</strong>。做为 <code>变量</code> 使用的话用 const，若做为 <code>属性</code> 则使用 readonly。</p><h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>有时候我们希望接口允许有任意的属性，语法是用 <code>[]</code> 将属性包裹起来：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> price: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意属性 activity</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span>,</span><br><span class="line">  activity: <span class="string">'coupon'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 这里的接口 <code>Clothes</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> <code>size</code> 和 <code>price</code>，那么就无所谓它们的类型是什么。</p><ul><li>项目案例：使用 axios 库发起 HTTP 传输的时候，可以写入一个自定义的属性，就是因为源码中定义了一个任意属性：</li></ul><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$axios({</span><br><span class="line">  method: <span class="string">'put'</span>,</span><br><span class="line">  url: <span class="string">'/cms/user'</span>,</span><br><span class="line">  data: {</span><br><span class="line">    nickname: <span class="built_in">this</span>.nickname,</span><br><span class="line">  },</span><br><span class="line">  showBackend: <span class="literal">true</span>,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>除了描述带有属性的普通对象外，接口也可以描述<strong>函数类型。</strong></p><p>为了使接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个<strong>只有 <code>参数列表</code> 和 <code>返回值类型</code> 的函数定义</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> source.search(subString) &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于函数类型的类型检查来说，<strong>函数的参数名不需要与接口里定义的名字相匹配</strong>。你可以改变函数的参数名，<strong>只要保证函数参数的位置不变。函数的参数会被逐个进行检查：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"><span class="comment">// source =&gt; src, subString =&gt; sub</span></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> src.search(sub) &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>如果接口中的函数类型带有函数名，下面两种书写方式是等价的：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Calculate {</span><br><span class="line">  add(x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">  multiply: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h2><p>可索引类型接口读起来有些拗口，直接看例子：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常的js代码</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  brand: <span class="string">'imooc'</span>,</span><br><span class="line">  type: <span class="string">'education'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line">obj[<span class="string">'brand'</span>]</span><br></pre></td></tr></tbody></table></figure><p>再来看定义可索引类型接口：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ScenicInterface {</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: ScenicInterface = [<span class="string">'西湖'</span>, <span class="string">'华山'</span>, <span class="string">'故宫'</span>]</span><br><span class="line"><span class="keyword">let</span> favorite: <span class="built_in">string</span> = arr[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><p>示例中索引签名是 <code>number类型</code>，返回值是字符串类型。</p><p>另外还有一种索引签名是 <code>字符串类型</code>。我们可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。通过下面的例子理解这句话：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">interface</span> Foo {</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">interface</span> Bar {</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">string</span>; <span class="comment">// Error: y 属性必须为 number 类型， 代表用y去索引返回string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>语法错误是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p><h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><p>我们希望<strong>类的实现必须遵循接口定义</strong>，那么可以使用 <code>implements</code> 关键字来确保兼容性。</p><p>这种类型的接口在传统面向对象语言中最为常见，比如 java 中接口就是这种类类型的接口。<strong>这种接口与抽象类比较相似，但是接口只能含有抽象方法和成员属性，实现类中必须实现接口中所有的抽象方法和成员属性。</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AnimalInterface {</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">AnimalInterface</span> </span>{</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你也可以在接口中描述一个方法，在类里实现它:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AnimalInterface {</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  eat(m: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">AnimalInterface</span> </span>{</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params">m: <span class="built_in">number</span></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">${<span class="built_in">this</span>.name}</span>吃肉<span class="subst">${m}</span>分钟`</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><p>接口描述了类的公共部分，而不是公共和私有两部分。 它<strong>不会帮你检查类是否具有某些私有成员。</strong></p><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>和类一样，接口也可以通过关键字 <code>extents</code> 相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape {</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = {} <span class="keyword">as</span> Square;</span><br><span class="line"><span class="comment">// 继承了 Shape 的属性</span></span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke {</span><br><span class="line">  penWidth: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke {</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = {} <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><p>在前面已经介绍，接口可以<strong>描述函数、对象的方法或者对象的属性。</strong></p><p>有时希望一个对象同时具有上面提到多种类型，比如一个<strong>对象可以当做函数使用，同时又具有属性和方法。</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter {</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>{</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>{ } <span class="keyword">as</span> Counter;</span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ };</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，声明一个接口，<strong>如果只有 <code>(start: number): string</code> 一个成员，那么这个接口就是函数接口</strong>，同时还具有其他两个成员，可以用来描述对象的属性和方法，这样就构成了一个混合接口。</p><p>第 7 行，创建一个 <code>getCounter()</code> 函数，它的返回值是 Counter 类型的。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>{ } <span class="keyword">as</span> Counter;</span><br></pre></td></tr></tbody></table></figure><p>第 8 行，通过类型断言，将函数对象转换为 <code>Counter</code> 类型，转换后的对象不但实现了函数接口的描述，使之成为一个函数，还具有 interval 属性和 reset() 方法。断言成功的条件是，两个数据类型只要有一方可以赋值给另一方，这里函数类型数据不能赋值给接口类型的变量，因为它不具有 interval 属性和 reset() 方法。</p><p>类型断言在之后的小节也会单节介绍。</p><h1 id="TypeScript-类-Class"><a href="#TypeScript-类-Class" class="headerlink" title="TypeScript 类(Class)"></a>TypeScript 类(Class)</h1><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>TypeScript 可以使用四种访问修饰符 <code>public</code>、<code>protected</code>、<code>private</code> 和 <code>readonly</code>。</p><h3 id="4-1-public"><a href="#4-1-public" class="headerlink" title="4.1 public"></a>4.1 public</h3><p>TypeScript 中，类的成员全部默认为 <code>public</code>，当然你也可以显式的将一个成员标记为 <code>public</code>，标记为 <code>public</code> 后，在程序类的外部可以访问。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculate</span> </span>{</span><br><span class="line">  <span class="comment">// 类的属性</span></span><br><span class="line">  <span class="keyword">public</span> x: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">public</span> y: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> add () {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x + <span class="built_in">this</span>.y</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-2-protected"><a href="#4-2-protected" class="headerlink" title="4.2 protected"></a>4.2 protected</h3><p>当成员被定义为 <code>protected</code> 后，只能被<strong>类的内部以及类的子类访问</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>{</span><br><span class="line">  <span class="keyword">protected</span> baseUrl: <span class="built_in">string</span> = <span class="string">'http://api.com/'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {}</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="title">request</span>(<span class="params">method: <span class="built_in">string</span></span>)</span> {</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`<span class="subst">${<span class="built_in">this</span>.baseUrl}</span><span class="subst">${method}</span>`</span></span><br><span class="line">    <span class="comment">// TODO 封装基础的 http 请求</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(<span class="string">'address'</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，Base 类的属性 baseUrl 被定义为受保护的，那么第 7 行该属性在类中被访问是可以的。</p><p>第 14 行，因 Address 类是 Base 类的子类，在子类中允许访问父类中被定义为受保护类型的方法 request() 。</p><h3 id="4-3-private"><a href="#4-3-private" class="headerlink" title="4.3 private"></a>4.3 private</h3><p>当类的成员被定义为 <code>private</code> 后，只能被<strong>类的内部访问</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mom</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">labour</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'baby is coming'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Mom</span> </span>{</span><br><span class="line">  test () {</span><br><span class="line">    <span class="built_in">this</span>.labour() <span class="comment">// Error, Property 'labour' is private and only accessible within class 'Mom'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">代码块<span class="number">1234567891011</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 9 行，父类中的 labour() 方法被定义为私有方法，只能在父类中被使用，子类中调用报错。</p><h3 id="4-4-readonly"><a href="#4-4-readonly" class="headerlink" title="4.4 readonly"></a>4.4 readonly</h3><p>通过 <code>readonly</code> 关键字将属性设置为只读的。<strong>只读属性必须在声明时或构造函数里被初始化。</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span> </span>{</span><br><span class="line">  <span class="keyword">readonly</span> secret: <span class="built_in">string</span> = <span class="string">'xjx*xh3GzW#3'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">readonly</span> expired: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">expired: <span class="built_in">number</span></span>) {</span><br><span class="line">    <span class="built_in">this</span>.expired = expired</span><br><span class="line">  } </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> token = <span class="keyword">new</span> Token(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>)</span><br><span class="line">token.expired = <span class="number">60</span> * <span class="number">60</span> * <span class="number">2</span> <span class="comment">// Error, expired 是只读的</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>最后一行，因 Token 类的属性 expired 被设置为只读属性，不可被修改。</p><h2 id="5-静态方法"><a href="#5-静态方法" class="headerlink" title="5. 静态方法"></a>5. 静态方法</h2><p>通过 <code>static</code> 关键字来创建类的静态成员，这些属性存在于<strong>类本身上面而不是类的实例上</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> getInformation () {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'This guy is too lazy to write anything.'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">User.getInformation() <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User()</span><br><span class="line">user.getInformation() <span class="comment">// Error 实例中无此方法</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> getInformation() 方法被定义为静态方法，只存在于类本身上，类的实例无法访问。</p><p>静态方法调用同一个类中的其他静态方法，可使用 this 关键字。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethodCall</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'Static method has been called'</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">anotherStaticMethod</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.staticMethod() + <span class="string">' from another static method'</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 静态方法中的 <code>this</code> 指向类本身，而静态方法也存在于类本身，所以可以在静态方法中用 this 访问在同一类中的其他静态方法。</p><p>非静态方法中，不能直接使用 <code>this</code> 关键字来访问静态方法。而要用类本身或者构造函数的属性来调用该方法：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethodCall</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="comment">// 类本身调用</span></span><br><span class="line">      <span class="built_in">console</span>.log(StaticMethodCall.staticMethod())</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构造函数的属性调用</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.constructor.staticMethod())</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'static method has been called.'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 类指向其构造函数本身，在非静态方法中，<code>this.constructor === StaticMethodCall</code> 为 <code>true</code>， 也就是说这两种写法等价。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类作为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节。</p><p><code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line">    <span class="keyword">abstract</span> makeSound(): <span class="built_in">void</span>;</span><br><span class="line">    move(): <span class="built_in">void</span> {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'roaming the earch...'</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> Animal() <span class="comment">// Error, 无法创建抽象类实例</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>通常我们需要创建子类继承抽象类，将抽象类中的抽象方法一一实现，这样在大型项目中可以很好的约束子类的实现。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">makeSound</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'bark bark bark...'</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"></span><br><span class="line">dog.makeSound()  <span class="comment">// bark bark bark...</span></span><br><span class="line">dog.move()       <span class="comment">// roaming the earch...</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="把类当做接口使用"><a href="#把类当做接口使用" class="headerlink" title="把类当做接口使用"></a>把类当做接口使用</h2><p>类也可以作为接口来使用，这在项目中是很常见的。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> toppings: <span class="built_in">string</span>[]</span>)</span> {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PizzaMaker</span> </span>{</span><br><span class="line">  <span class="comment">// 把 Pizza 类当做接口</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params">event: Pizza</span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Pizza(event.name, event.toppings)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pizza = PizzaMaker.create({ </span><br><span class="line">  name: <span class="string">'Cheese and nut pizza'</span>, </span><br><span class="line">  toppings: [<span class="string">'pasta'</span>, <span class="string">'eggs'</span>, <span class="string">'milk'</span>, <span class="string">'cheese'</span>]</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>第 7 行，把 Pizza 类当做接口。</p><p>因为接口和类都定义了对象的结构，在某些情况下可以互换使用。如果你需要创建一个可以自定义参数的实例，同时也可以进行类型检查，把类当做接口使用不失为一个很好的方法。</p><p>这就是 TypeScript 的强大功能，而且非常灵活，<strong>拥有全面的面向对象设计和通用的类型检查</strong>。</p><h1 id="TypeScript函数"><a href="#TypeScript函数" class="headerlink" title="TypeScript函数"></a>TypeScript函数</h1><h2 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h2><p>在 TypeScript 中编写函数，需要给形参和返回值指定类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (x + y).toString()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>参数 x 和 y 都是 number 类型，两个参数相加后将其类型转换为 string， 所以整个函数的返回值为 string 类型。</p><p>上面的代码只是对 <code>=</code> 等号右侧的匿名函数进行了类型定义，等号左侧的 <code>add</code> 同样可以添加类型：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (x + y).toString()</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>可以看到，等号左侧的类型定义由两部分组成：参数类型和返回值类型，通过 <code>=&gt;</code> 符号来连接。</p><p>这里要注意：<strong>函数类型的 <code>=&gt;</code> 和 箭头函数的 <code>=&gt;</code> 是不同的含义</strong>。</p><p>通过箭头函数改写一下刚才写的函数:</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="function"><span class="params">string</span> =&gt;</span> (x + y).toString()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>等号左右两侧书写完整：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要参数位置及类型不变，变量名称可以自己定义，比如把两个参数定位为 a b</span></span><br><span class="line"><span class="keyword">const</span> add: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> = (x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="function"><span class="params">string</span> =&gt;</span> (x + y).toString()</span><br></pre></td></tr></tbody></table></figure><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="参数个数保持一致"><a href="#参数个数保持一致" class="headerlink" title="参数个数保持一致"></a>参数个数保持一致</h3><p>TypeScript 中每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器会检查用户是否为每个参数都传入了值。简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = (firstName: <span class="built_in">string</span>, <span class="attr">lastName</span>: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> <span class="string">`<span class="subst">${firstName}</span><span class="subst">${lastName}</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = fullName(<span class="string">'Sherlock'</span>, <span class="string">'Holmes'</span>)</span><br><span class="line"><span class="keyword">let</span> result2 = fullName(<span class="string">'Sherlock'</span>, <span class="string">'Holmes'</span>, <span class="string">'character'</span>) <span class="comment">// Error, Expected 2 arguments, but got 3</span></span><br><span class="line"><span class="keyword">let</span> result3 = fullName(<span class="string">'Sherlock'</span>)                        <span class="comment">// Error, Expected 2 arguments, but got 1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，一个需要传入 2 个字符串类型参数的函数类型定义。</p><p>第 4 行，<code>result2</code> 传入了 3 个参数，与声明的 2 个参数不符。</p><p>第 5 行，<code>result3</code> 只传入了 1 个参数，同样与声明的 2 个参数不符。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>在 JavaScript 中每个参数都是可选的，可传可不传。没传参的时候，它的值就是 undefined。 而在 TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能，<strong>可选参数必须跟在必须参数后面</strong>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = (firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span> <span class="string">`<span class="subst">${firstName}</span><span class="subst">${lastName}</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = fullName(<span class="string">'Sherlock'</span>, <span class="string">'Holmes'</span>)</span><br><span class="line"><span class="keyword">let</span> result2 = fullName(<span class="string">'Sherlock'</span>, <span class="string">'Holmes'</span>, <span class="string">'character'</span>) <span class="comment">// Error, Expected 1-2 arguments, but got 3</span></span><br><span class="line"><span class="keyword">let</span> result3 = fullName(<span class="string">'Sherlock'</span>)                        <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，firstName 是必须参数，lastName 是可选参数。</p><p>第 4 行，传入了 3 个参数，与声明的 2 个参数不符。</p><p>第 5 行，lastName 是可选参数，可以省略。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>参数可以取默认值，上面介绍的<strong>可选参数必须跟在必须参数后面</strong>，而<strong>带默认值的参数不需要放在必须参数的后面，可随意调整位置</strong>：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> token = (expired = <span class="number">60</span>*<span class="number">60</span>, <span class="attr">secret</span>: <span class="built_in">string</span>): <span class="function"><span class="params">void</span>  =&gt;</span> {}</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">const</span> token1 = (secret: <span class="built_in">string</span>, expired = <span class="number">60</span>*<span class="number">60</span> ): <span class="function"><span class="params">void</span> =&gt;</span> {}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，带默认值的参数 expired 在参数列表首位。</p><p>第 3 行，带默认值的参数 expired 在参数列表末位。</p><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>有的时候，函数的参数个数是不确定的，可能传入未知个数，这时没有关系，有一种方法可以解决这个问题。</p><p>通过 <code>rest 参数</code> (形式为 <code>...变量名</code>)来获取函数的剩余参数，这样就不需要使用 <code>arguments</code> 对象了。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">ok: <span class="built_in">boolean</span>, ...args: <span class="built_in">string</span>[]</span>): <span class="title">void</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (!ok) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(args.join(<span class="string">' '</span>));</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">assert(<span class="literal">false</span>, <span class="string">'上传文件过大'</span>, <span class="string">'只能上传jpg格式'</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，第二个参数传入剩余参数，且均为字符串类型。</p><p>第 7 行，调用函数 <code>assert()</code> 时，除了第一个函数传入一个布尔类型，接下来可以无限传入多个字符串类型的参数。</p><blockquote><p><strong>TIP：注意 <code>rest 参数</code> 只能是最后一个参数。</strong></p></blockquote><h3 id="this-参数"><a href="#this-参数" class="headerlink" title="this 参数"></a>this 参数</h3><p>JavaScript 里，this 的值在函数被调用的时候才会被指定，但是这个 this 到底指的是什么还是需要花点时间弄清楚。</p><p>默认情况下，<code>tsconfig.json</code> 中，编译选项 <code>compilerOptions</code> 的属性 <code>noImplicitThis</code> 为 <code>false</code>，我们在一个对象中使用的 this 时，它的类型是 any 类型。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> triangle = {</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="number">15</span>,</span><br><span class="line">  c: <span class="number">20</span>,</span><br><span class="line">  area: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="comment">// this 为 any 类型</span></span><br><span class="line">      <span class="keyword">const</span> p = (<span class="built_in">this</span>.a + <span class="built_in">this</span>.b + <span class="built_in">this</span>.c) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p * (p - <span class="built_in">this</span>.a) * (p - <span class="built_in">this</span>.b) *(p - <span class="built_in">this</span>.c))</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myArea = triangle.area()</span><br><span class="line"><span class="built_in">console</span>.log(myArea())</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>在实际工作中 any 类型是非常危险的，我们可以添加任意属性到 any 类型的参数上，比如将 <code>const p = (this.a + this.b + this.c) / 2</code> 这句改为 <code>const p = (this.d + this.d + this.d) / 2</code> 也不会报错，这很容易造成不必要的问题。</p><p>所以我们应该明确 this 的指向，下面介绍两种方法：</p><p>第一种，在 <code>tsconfig.json</code> 中，将编译选项 <code>compilerOptions</code> 的属性 <code>noImplicitThis</code> 设置为 <code>true</code>，TypeScript 编译器就会帮你进行正确的类型推断：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> triangle = {</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="number">15</span>,</span><br><span class="line">  c: <span class="number">20</span>,</span><br><span class="line">  area: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> p = (<span class="built_in">this</span>.a + <span class="built_in">this</span>.b + <span class="built_in">this</span>.c) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p * (p - <span class="built_in">this</span>.a) * (p - <span class="built_in">this</span>.b) *(p - <span class="built_in">this</span>.c))</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myArea = triangle.area()</span><br><span class="line"><span class="built_in">console</span>.log(myArea())</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>将 <code>noImplicitThis</code> 设置为 <code>true</code> 以后，把鼠标放在第 7 行的 <code>this</code> 上，可以看到：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this: {</span><br><span class="line">  a: number;</span><br><span class="line">  b: number;</span><br><span class="line">  c: number;</span><br><span class="line">  area: () =&gt; () =&gt; number;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这时，TypeScript 编译器就能准确的知道了 this 的类型，如果取不存在于 this 属性中的 <code>d</code>，将会报错 <code>Property 'd' does not exist on type '{ a: number; b: number; c: number; area: () =&gt; () =&gt; any; }'</code></p><p>除了这种方法，我们还可以通过 <code>this 参数</code> 这种形式来解决 this 为 any 类型这一问题。提供一个显式的 <code>this</code> 参数，它出现在参数列表的最前面：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span></span>) </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改造刚才的例子：</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Triangle {</span><br><span class="line">  a: <span class="built_in">number</span>;</span><br><span class="line">  b: <span class="built_in">number</span>;</span><br><span class="line">  c: <span class="built_in">number</span>;</span><br><span class="line">  area(<span class="built_in">this</span>: Triangle): <span class="function">() =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// area接受一个Triangle类型的this参数，返回一个函数，这个函数的返回类型是number</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> triangle: Triangle = {</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="number">15</span>,</span><br><span class="line">  c: <span class="number">20</span>,</span><br><span class="line">  area: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">this</span>: Triangle</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> p = (<span class="built_in">this</span>.a + <span class="built_in">this</span>.b + <span class="built_in">this</span>.c) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(p * (p - <span class="built_in">this</span>.a) * (p - <span class="built_in">this</span>.b) *(p - <span class="built_in">this</span>.c))</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myArea = triangle.area()</span><br><span class="line"><span class="built_in">console</span>.log(myArea())</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>我们声明了一个接口 <code>Triangle</code>，其中的函数类型显式的传入了 <code>this</code> 参数，这个参数的类型为 <code>Triangle</code> 类型（第 5 行）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area(this: Triangle): () =&gt; number;</span><br></pre></td></tr></tbody></table></figure><p>此时，在第 14 行，<code>this</code> 指向 <code>Triangle</code>，就可以进行正确的类型判断，如果取未定义参数，编译器将直接报错。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载是指函数根据传入不同的参数，返回不同类型的数据。</p><p>它的意义在于让你清晰的知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到相同类型的数据，那就不需要使用函数重载。</p><p>比如面试中常考的字符反转问题，这里就不考虑负数情况了，只是为了演示函数重载：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">target: string | number</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'string'</span>) {</span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'number'</span>) {</span><br><span class="line">    <span class="keyword">return</span> +[...target.toString()].reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">rse(<span class="string">'imooc'</span>))   <span class="comment">// coomi</span></span><br><span class="line"><span class="built_in">console</span>.log(reverse(<span class="number">23874800</span>))  <span class="comment">// 847832</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>编译器并不知道入参是什么类型的，返回值类型也不能确定。这时可以为同一个函数提供多个函数类型定义来进行函数重载。</p><p>(通过 <code>--downlevelIteration</code> 编译选项增加对生成器和迭代器协议的支持)</p><p>实例演示</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">target: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>{</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> target === <span class="string">'string'</span></span>) </span>{</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">target</span>.<span class="title">split</span>(<span class="params"><span class="string">''</span></span>).<span class="title">reverse</span>(<span class="params"></span>).<span class="title">join</span>(<span class="params"><span class="string">''</span></span>)</span></span><br><span class="line"><span class="function">  }</span></span><br><span class="line"><span class="function">  <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> target === <span class="string">'number'</span></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> +[...target.toString()].reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(reverse(<span class="string">'imooc'</span>))   <span class="comment">// coomi</span></span><br><span class="line"><span class="built_in">console</span>.log(reverse(<span class="number">23874800</span>))  <span class="comment">// 847832</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>因为这个反转函数在传入字符串类型的时候返回字符串类型，传入数字类型的时候返回数字类型，所以在前两行进行了两次函数类型定义。在函数执行时，根据传入的参数类型不同，进行不同的计算。</p><p>为了让编译器能够选择正确的检查类型，它会从重载列表的第一个开始匹配。因此，在定义重载时，一定要<strong>把最精确的定义放在最前面</strong>。</p><h2 id="使用函数时的注意事项"><a href="#使用函数时的注意事项" class="headerlink" title="使用函数时的注意事项"></a>使用函数时的注意事项</h2><ol><li>如果一个函数没有使用 <code>return</code> 语句，则它默认返回 <code>undefined</code>。</li><li>调用函数时，传递给函数的值被称为函数的 <code>实参</code>（值传递），对应位置的函数参数被称为 <code>形参</code>。</li><li>在函数执行时， <code>this</code> 关键字并不会指向正在运行的函数本身，而是 <code>指向调用函数的对象</code>。</li><li><code>arguments</code> 对象是所有（非箭头）函数中都可用的 <code>局部变量</code>。你可以使用 arguments 对象在函数中引用函数的参数。</li></ol><h1 id="TypeScript-字面量类型"><a href="#TypeScript-字面量类型" class="headerlink" title="TypeScript 字面量类型"></a>TypeScript 字面量类型</h1><p>通俗的讲，字面量也可以叫直接量，就是你看见什么，它就是什么。</p><p>我们之前介绍字符串类型，其实是一个集合类型，所有的字符串集合在一起构成了 string 类型。而字符串字面量类型就直接多了，你定义为 <code>'imooc'</code>，那这个变量的类型就是 <code>'imooc'</code> 类型。</p><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型允许你指定字符串必须的固定值。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protagonist: <span class="string">'Sherlock'</span></span><br><span class="line"></span><br><span class="line">protagonist = <span class="string">'Sherlock'</span></span><br><span class="line">protagonist = <span class="string">'Watson'</span> <span class="comment">// Error, Type '"Watson"' is not assignable to type '"Sherlock"'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 变量 <code>protagonist</code> 被声明为 <code>'Sherlock'</code> 字面量类型，就只能赋值为 <code>'Sherlock'</code>。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">'ease-in'</span> | <span class="string">'ease-out'</span> | <span class="string">'ease-in-out'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UIElement</span> </span>{</span><br><span class="line">  <span class="function"><span class="title">animate</span>(<span class="params">dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing</span>)</span> {</span><br><span class="line">      <span class="keyword">if</span> (easing === <span class="string">'ease-in'</span>) {}</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">'ease-out'</span>) {}</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">'ease-in-out'</span>) {}</span><br><span class="line">      <span class="keyword">else</span> {</span><br><span class="line">          <span class="comment">// Error, 不应该传递 null 或 undefined</span></span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement()</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'ease-in'</span>)</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'uneasy'</span>) <span class="comment">// Error, 'uneasy' 不被允许</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，通过类型别名，声明了类型 <code>Easing</code> 为 <code>'ease-in' | 'ease-out' | 'ease-in-out'</code><br>这样三个字符串字面量构成的联合类型。</p><p>第 4 行，你<strong>只能</strong>从三种允许的字符中选择<strong>其一</strong>来做为参数传递，传入其它值则会产生错误。</p><p>字符串字面量类型还可以用于区分函数重载：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="string">'img'</span></span>): <span class="title">HTMLImageElement</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="string">'input'</span></span>): <span class="title">HTMLInputElement</span></span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="built_in">string</span></span>): <span class="title">Element</span> </span>{}</span></span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>如果参数 tagName 为 <code>'img'</code> 类型，返回值类型为 <code>HTMLImageElement</code>; 如果参数 tagName 为 <code>'input'</code> 类型，返回值类型为 <code>HTMLInputElement</code>。</p><h2 id="布尔字面量类型"><a href="#布尔字面量类型" class="headerlink" title="布尔字面量类型"></a>布尔字面量类型</h2><p>声明布尔字面量类型，注意这里是 <code>:</code> 不是 <code>=</code>。 <code>=</code> 等号是变量赋值，<code>:</code> 表示声明的类型。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> success: <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> fail: <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> value: <span class="literal">true</span> | <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure><p>接口的返回值，会有正确返回和异常两种情况，这两种情况要有不同的数据返回格式：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result = { <span class="attr">success</span>: <span class="literal">true</span>, <span class="attr">code</span>: <span class="built_in">number</span>, <span class="attr">object</span>: <span class="built_in">object</span> } | { <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">code</span>: <span class="built_in">number</span>, <span class="attr">errMsg</span>: <span class="built_in">string</span> }</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res: Result = { <span class="attr">success</span>: <span class="literal">false</span>, <span class="attr">code</span>: <span class="number">90001</span>, <span class="attr">errMsg</span>: <span class="string">'该二维码已使用'</span> }</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!res.success) {</span><br><span class="line">  res.errMsg <span class="comment">// OK</span></span><br><span class="line">  res.object <span class="comment">// Error, Property 'object' does not exist on type '{ success: false; code: number; errMsg: string; }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>类型别名 Result 是一个由两个对象组成的联合类型，都有一个共同的 success 属性，这个属性的类型就是布尔字面量类型。因为涉及很多后续才会介绍的知识点，这里看不懂没关系，只需要大概了解这是布尔字面量类型的一种应用即可。</p><h2 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h2><p>TypeScript 还具有数字字面量类型。</p><p>比如骰子只有六种点数：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> die: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span></span><br><span class="line"></span><br><span class="line">die = <span class="number">9</span> <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure><h1 id="TypeScript-类型推断"><a href="#TypeScript-类型推断" class="headerlink" title="TypeScript 类型推断"></a>TypeScript 类型推断</h1><p>TypeScript 类型检查机制包含三个部分：</p><ul><li>类型推断</li><li>类型保护</li><li>类型兼容性</li></ul><p>类型推断的含义是不需要指定变量类型或函数的返回值类型，TypeScript 可以根据一些简单的规则推断其的类型。</p><h2 id="基础类型推断"><a href="#基础类型推断" class="headerlink" title="基础类型推断"></a>基础类型推断</h2><p>基础的类型推断发生在 <strong>初始化变量，设置默认参数和决定返回值时。</strong></p><p><strong>初始化变量例子：</strong></p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>             <span class="comment">// let x: number</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">'hello world'</span> <span class="comment">// let y: string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> z                 <span class="comment">// let z: any</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>变量 <code>x</code> 的类型被推断为数字，变量 <code>y</code> 的类型被推断为字符串。如果定义时没有赋值，将被推断为 any 类型。</p><p>设置默认参数和决定返回值时的例子：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值推断为 number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a:<span class="built_in">number</span>, b:<span class="number">10</span></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="string">'hello world'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">15</span> <span class="comment">// Error，Type '15' is not assignable to type 'string'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 1 行，参数 b 有默认值 10，被推断为 number 类型。</p><p>第 2 行，两个 number 类型相加，函数 <code>add()</code> 返回值被推断为 number 类型。</p><p>最后一行，<code>obj</code> 的类型被推断为 <code>{a: number, b: string}</code>，所以属性 b 不能被赋值为数字。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = {</span><br><span class="line">  protagonist: <span class="string">'Sherlock'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> { protagonist } = obj</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 通过解构赋值也可以完成正确的类型推断：<code>let protagonist: string</code>。</p><h2 id="最佳通用类型推断"><a href="#最佳通用类型推断" class="headerlink" title="最佳通用类型推断"></a>最佳通用类型推断</h2><p>当需要从多个元素类型推断出一个类型时，TypeScript 会尽可能推断出一个兼容所有类型的通用类型。</p><p>比如声明一个数组：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">1</span>, <span class="string">'imooc'</span>, <span class="literal">null</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 为了推断 <code>x</code> 的类型，必须考虑所有的元素类型。这里有三种元素类型 number、string 和 null，此时数组被推断为 <code>let x: (string | number | null)[]</code> 联合类型。</p><blockquote><p><strong>Tip：</strong> 是否兼容 null 类型可以通过 tsconfig.json 文件中属性 <code>strictNullChecks</code> 的值设置为 true 或 false 来决定。</p></blockquote><h2 id="4-上下文类型推断"><a href="#4-上下文类型推断" class="headerlink" title="4. 上下文类型推断"></a>4. 上下文类型推断</h2><p><strong>前面两种都是根据从右向左流动进行类型推断，上下文类型推断则是从左向右的类型推断。</strong></p><p>例如定义一个 <code>Animal</code> 的类作为接口使用：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> species: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">public</span> weight: <span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> simba: Animal = {</span><br><span class="line">  species: <span class="string">'lion'</span>,</span><br><span class="line">  speak: <span class="literal">true</span>  <span class="comment">// Error, 'speak' does not exist in type 'Animal'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 第 6 行，将 <code>Animal 类型</code>显示的赋值给 <code>变量 simba</code>，<code>Animal 类型</code> 没有 <code>speak 属性</code>，所以不可赋值。</p><h1 id="TypeScript-类型断言"><a href="#TypeScript-类型断言" class="headerlink" title="TypeScript 类型断言"></a>TypeScript 类型断言</h1><p>本节介绍类型断言，有使用关键字 <code>as</code> 和标签 <code>&lt;&gt;</code> 两种方式，因后者会与<code>JSX</code> 语法冲突，建议统一使用 <code>as</code> 来进行类型断言。</p><p>TypeScript 允许你覆盖它的推断，毕竟作为开发者你比编译器更了解你写的代码。</p><p>类型断言主要用于当 TypeScript 推断出来类型并不满足你的需求，你需要手动指定一个类型。</p><h2 id="关键字-as"><a href="#关键字-as" class="headerlink" title="关键字 as"></a>关键字 as</h2><p>当你把 JavaScript 代码迁移到 TypeScript 时，一个常见的问题：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = {}</span><br><span class="line"></span><br><span class="line">user.nickname = <span class="string">'Evan'</span>  <span class="comment">// Error, Property 'nickname' does not exist on type '{}'</span></span><br><span class="line">user.admin = <span class="literal">true</span>       <span class="comment">// Error, Property 'admin' does not exist on type '{}'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 编译器推断 <code>const user: {}</code>，这是一个没有属性的对象，所以你不能对其添加属性。</p><p>此时可以使用类型断言（<em>as关键字</em>）覆盖其类型推断：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User {</span><br><span class="line">  nickname: <span class="built_in">string</span>,</span><br><span class="line">  admin: <span class="built_in">boolean</span>,</span><br><span class="line">  groups: <span class="built_in">number</span>[]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = {} <span class="keyword">as</span> User</span><br><span class="line"></span><br><span class="line">user.nickname = <span class="string">'Evan'</span> </span><br><span class="line">user.admin = <span class="literal">true</span>       </span><br><span class="line">user.groups = [<span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 7 行，这里通过 <code>as</code> 关键字进行类型断言，将变量 <code>user</code> 的类型覆盖为 <code>User</code> 类型。<strong>但是请注意，类型断言不要滥用，除非你完全明白你在干什么。</strong></p><h2 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言 !"></a>非空断言 !</h2><p>如果编译器不能够去除 null 或 undefined，可以使用非空断言 <code>!</code> 手动去除。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> name!.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet; <span class="comment">// name 被断言为非空</span></span><br><span class="line">  }</span><br><span class="line">  name = name || <span class="string">"Bob"</span></span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">"great"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，<code>postfix()</code> 是一个嵌套函数，因为编译器无法去除嵌套函数的 null (除非是立即调用的函数表达式)，所以 TypeScript 推断第 3 行的 <code>name</code> 可能为空。</p><p>第 5 行，而 <code>name = name || "Bob"</code> 这行代码已经明确了 <code>name</code> 不为空，所以可以直接给 name 断言为非空（第 3 行）。</p><h2 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h2><p>双重断言极少有应用场景，只需要知道有这种操作即可：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User {</span><br><span class="line">  nickname: <span class="built_in">string</span>,</span><br><span class="line">  admin: <span class="built_in">boolean</span>,</span><br><span class="line">  group: <span class="built_in">number</span>[]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="string">'Evan'</span> <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> User</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong> 最后一行，使用 as 关键字进行了两次断言，最终变量 user 被强制转化为 User 类型。</p><h1 id="TypeScript-类型保护"><a href="#TypeScript-类型保护" class="headerlink" title="TypeScript 类型保护"></a>TypeScript 类型保护</h1><p>类型保护是指缩小类型的范围，在一定的块级作用域内由编译器推导其类型，提示并规避不合法的操作。</p><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>通过 <code>typeof</code> 运算符判断变量类型，下面看一个之前介绍函数重载时的例子：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">target: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'string'</span>) {</span><br><span class="line">    target.toFixed(<span class="number">2</span>) <span class="comment">// Error，在这个代码块中，target 是 string 类型，没有 toFixed 方法</span></span><br><span class="line">    <span class="keyword">return</span> target.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'number'</span>) {</span><br><span class="line">    target.toFixed(<span class="number">2</span>) <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">return</span> +[...target.toString()].reverse().join(<span class="string">''</span>)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  target.forEach(<span class="function"><span class="params">element</span> =&gt;</span> {}) <span class="comment">// Error，在这个代码块中，target 是 string 或 number 类型，没有 forEach 方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 2 行，通过 typeof 关键字，将这个代码块中变量 target 的类型限定为 string 类型。</p><p>第 6 行，通过 typeof 关键字，将这个代码块中变量 target 的类型限定为 number 类型。</p><p>第 11 行，因没有限定，在这个代码块中，变量 target 是 string 或 number 类型，没有 forEach 方法，所以报错。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof 与 typeof 类似，区别在于 typeof 判断基础类型，instanceof 判断是否为某个对象的实例：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> nickname: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">public</span> group: <span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> count: <span class="built_in">number</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">public</span> keyword: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeGuard</span>(<span class="params">arg: User | Log</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> User) {</span><br><span class="line">    arg.count = <span class="number">15</span> <span class="comment">// Error, User 类型无此属性</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Log) {</span><br><span class="line">    arg.count = <span class="number">15</span> <span class="comment">// OK</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 12 行，通过 instanceof 关键字，将这个代码块中变量 arg 的类型限定为 User 类型。</p><p>第 16 行，通过 instanceof 关键字，将这个代码块中变量 arg 的类型限定为 Log 类型。</p><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p><code>in</code> 操作符用于确定属性是否存在于某个对象上，这也是一种缩小范围的类型保护。</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> nickname: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">public</span> groups!: <span class="built_in">number</span>[]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> count: <span class="built_in">number</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">public</span> keyword: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeGuard</span>(<span class="params">arg: User | Log</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'nickname'</span> <span class="keyword">in</span> arg) {</span><br><span class="line">    <span class="comment">// (parameter) arg: User，编辑器将推断在当前块作用域 arg 为 User 类型</span></span><br><span class="line">    arg.nickname = <span class="string">'imooc'</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'count'</span> <span class="keyword">in</span> arg) {</span><br><span class="line">    <span class="comment">// (parameter) arg: Log，编辑器将推断在当前块作用域 arg 为 Log 类型</span></span><br><span class="line">    arg.count = <span class="number">15</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 12 行，通过 in 关键字，将这个代码块中变量 arg 的类型限定为 User 类型。</p><p>第 17 行，通过 in 关键字，将这个代码块中变量 arg 的类型限定为 Log 类型。</p><h2 id="字面量类型保护"><a href="#字面量类型保护" class="headerlink" title="字面量类型保护"></a>字面量类型保护</h2><p>用字面量类型那一节的例子改造一下来介绍字面量类型保护：</p><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Success = {</span><br><span class="line">  success: <span class="literal">true</span>,</span><br><span class="line">  code: <span class="built_in">number</span>,</span><br><span class="line">  <span class="built_in">object</span>: <span class="built_in">object</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fail = {</span><br><span class="line">  success: <span class="literal">false</span>,</span><br><span class="line">  code: <span class="built_in">number</span>,</span><br><span class="line">  errMsg: <span class="built_in">string</span>,</span><br><span class="line">  request: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg: Success | Fail</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (arg.success === <span class="literal">true</span>) {</span><br><span class="line">    <span class="built_in">console</span>.log(arg.object) <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.errMsg) <span class="comment">// Error, Property 'errMsg' does not exist on type 'Success'</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(arg.errMsg) <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.object) <span class="comment">// Error, Property 'object' does not exist on type 'Fail'</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>代码解释：</strong></p><p>第 15 行，通过布尔字面量，将这个代码块中变量 arg 的类型限定为 Success 类型。</p><p>第 18 行，通过布尔字面量，将这个代码块中变量 arg 的类型限定为 Fail 类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TypeScript-基础类型&quot;&gt;&lt;a href=&quot;#TypeScript-基础类型&quot; class=&quot;headerlink&quot; title=&quot;TypeScript 基础类型&quot;&gt;&lt;/a&gt;TypeScript 基础类型&lt;/h1&gt;&lt;p&gt;TypeScript 中的类型有&lt;/</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="TypeScript" scheme="https://yjunuser.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://yjunuser.github.io/2021/04/24/helloworld/"/>
    <id>https://yjunuser.github.io/2021/04/24/helloworld/</id>
    <published>2021-04-24T04:32:07.695Z</published>
    <updated>2021-04-24T11:12:25.294Z</updated>
    
    <content type="html"><![CDATA[<h1>欢迎来到我的博客</h1><h2>aaa</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;欢迎来到我的博客&lt;/h1&gt;
&lt;h2&gt;aaa&lt;/h2&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CSS linear-gradient函数</title>
    <link href="https://yjunuser.github.io/2021/04/24/linear-gradient/"/>
    <id>https://yjunuser.github.io/2021/04/24/linear-gradient/</id>
    <published>2021-04-23T16:00:00.000Z</published>
    <updated>2021-04-24T11:12:15.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-linear-gradient的介绍和在实际项目中的使用"><a href="#CSS-linear-gradient的介绍和在实际项目中的使用" class="headerlink" title="CSS: linear-gradient的介绍和在实际项目中的使用"></a>CSS: linear-gradient的介绍和在实际项目中的使用</h1><p>linear-gradient函数是CSS3中的一些新特性,最近在学习CSS揭秘这本书中一开始就接触到了这个属性,以前接触的实在不多,CSS揭秘上对这两个属性的运用又让我大开眼界,于是写篇文章好好学习一下</p><h2 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h2><p>CSS <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()"><code>linear-gradient&nbsp;</code></a>函数用于创建一个表示两种或多种颜色线性见表的图片</p><p><code>linear-gradient</code>函数接收三个值: </p><p><code>&lt;side-or-corner&gt;</code></p><p>​    描述渐变线的起始点位置。它包含<strong>to</strong>和两个关键词：第一个指出水平位置<strong>left or right</strong>，第二个指出垂直位置<strong>top or bottom</strong>。关键词的先后顺序无影响，且都是可选的。</p><p>​    to top, to bottom, to left 和 to right这些值会被转换成角度<strong>0度、180度、270度和90度</strong>。其余值会被转换为一个以向顶部中央方向为起点顺时针旋转的角度。渐变线的结束点与其起点中心对称。</p><p><code>&lt;angle&gt;</code></p><p>​    用角度值指定渐变的方向（或角度）。角度顺时针增加。 </p><p><code>&lt;linear-color-stop&gt;</code></p><p>​    由一个color值组成，并且跟随着一个可选的<strong>终点位置</strong>（可以是一个<strong>百分比值</strong>或者是沿着渐变轴的<strong>length</strong>。CSS渐变的颜色渲染采取了与<strong>SVG相同</strong>的规则。</p><p><code>&lt;color-hint&gt;</code></p><p>​    颜色中转点是一个插值提示，它定义了在相邻颜色之间渐变如何进行。长度定义了在两种颜色之间的哪个点停止渐变颜色应该达到颜色过渡的中点。如果省略，颜色转换的中点是两个颜色停止之间的中点。 </p><p>听起来很复杂，看几个例子就明白了</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red, yellow, blue);</span><br><span class="line">    <span class="comment">/*等价于*/</span></span><br><span class="line">    <span class="comment">/*background: linear-gradient(180deg, red, yellow, blue)*/</span></span><br><span class="line">    <span class="comment">/*background: linear-gradient(to bottom, red, yellow, blue)*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424133125189.png" alt="image-20210424133125189"></p><p>可以看到，实现了从<code>red -&gt; yellow -&gt; blue</code>的线性渐变，且渐变角度从上到下，也就是从<strong>180deg到0deg</strong>，即默认情况下，第一个参数等于<strong>180deg</strong></p><p>现在改变一下角度试试:</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">0deg</span>, red, yellow, blue);</span><br><span class="line">    <span class="comment">/*等价于*/</span></span><br><span class="line">    <span class="comment">/*background: linear-gradient(to top, red, yellow, blue)*/</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424133512095.png" alt="image-20210424133512095"></p><p>可以看到，图片完完全全的倒立过来了</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, red, yellow, blue)</span><br><span class="line">    /*等价于*/</span><br><span class="line">    /*background: <span class="built_in">linear-gradient</span>(to right top, red, yellow, blue)*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424133802029.png" alt="image-20210424133802029"></p><p>由此可以看出，<code>linear-gradient</code>中图片角度的规律</p><p><img src="/images/artical-image/image-20210424134420095.png" alt="image-20210424134420095"></p><p>除此之外，颜色的每个值都可以设置终止位置</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red <span class="number">0%</span>, orange <span class="number">25%</span>, yellow <span class="number">50%</span>, green <span class="number">75%</span>, blue <span class="number">100%</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424135509560.png" alt="image-20210424135509560"></p><p>当然也可以使用<code>px</code></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> {</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red <span class="number">50px</span>, orange <span class="number">100px</span>, yellow <span class="number">150px</span>, green <span class="number">180px</span>, blue)</span><br><span class="line">   /*最后一个默认为终点位置*/</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424135947658.png" alt="image-20210424135947658"></p><blockquote><p>需要注意的是，当你生命了<code>linear-gradient</code>中的颜色属性后，再添加<code>background-color</code>或者向<code>background</code>中添加颜色是无效的，因为linear-gradient的颜色把原来的背景颜色全部覆盖了，但把<code>color</code>值设为<code>tranparent</code>能显示回原来的颜色，也就是你用<code>background-color</code>设置的颜色</p></blockquote><p>那我们怎样在项目中去<strong>合理</strong>的应用这个属性呢?</p><p>举个简单的例子，当我们创建一个按钮</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#446d88</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#58a</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> gray;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -<span class="number">0.05em</span> <span class="number">0.05em</span> <span class="number">#335166</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424141714525.png" alt="image-20210424141714525"></p><p>现在给这个按钮添加换一个渐变背景</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#446d88</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">#77a0bb</span>, <span class="number">#58a</span>);</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> gray;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -<span class="number">0.05em</span> <span class="number">0.05em</span> <span class="number">#335166</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424141930939.png" alt="image-20210424141930939"></p><p>到这里，一个简单的有<strong>质感</strong>的按钮就完成了</p><p>但到这里仍存在一些问题，按钮是在项目中经常重复用到的部分，假如现在我们要创建一个红色按钮或者黄色按钮，该怎么办呢?</p><p>我们可能需要覆盖四条属性，<code>border-color</code>，<code>text-shadow</code>，<code>box-shadow</code>，<code>background</code>，因为颜色变了后这些属性都要跟着改变，而且，确定一个颜色的<strong>渐变</strong>效果需要知道这个颜色的<strong>亮色</strong>和<strong>暗色</strong>版本(例如上面的按钮就需要知道<code>#58a</code>和<code>#77a0bb</code>)，并且如果按钮放在一个<strong>非纯白色背景</strong>上呢，例如放到<code>gray</code>背景里</p><p><img src="/images/artical-image/image-20210424143615958.png" alt="image-20210424143615958"></p><p>此时<code>box-shadow: gray</code>属性明显就不能体现出来该有的效果</p><p>那有没有方法能一次性解决上面的问题又更加简洁呢，<code>linear-gradient</code>可以派上用场了，用<code>linear-gradient</code>设置一个<strong>半透明的白色</strong>作为主色调就能解决这个难题</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>);</span><br><span class="line">        <span class="attribute">background</span>:   <span class="number">#58a</span> <span class="built_in">linear-gradient</span>(<span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">100%</span>, .<span class="number">5</span>), transparent);;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -.<span class="number">05em</span> .<span class="number">05em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424151914438.png" alt="image-20210424151914438"></p><p>现在，我们只需要改变<code>background-color</code>就能得到不同颜色的<strong>渐变按钮</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span> {</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0.8em</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">1</span>);</span><br><span class="line">        <span class="attribute">background</span>:   <span class="number">#58a</span> <span class="built_in">linear-gradient</span>(<span class="built_in">hsla</span>(<span class="number">0</span>, <span class="number">0%</span>, <span class="number">100%</span>, .<span class="number">5</span>), transparent);;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0.05em</span> <span class="number">0.25em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">text-shadow</span>: <span class="number">0</span> -.<span class="number">05em</span> .<span class="number">05em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span><span class="selector-class">.cancel</span> {</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/artical-image/image-20210424160249913.png" alt="image-20210424160249913"></p><p>这就是<code>linear-gradient</code>在实际项目中的一个小应用，也是我读<a href="https://www.ituring.com.cn/book/1695">Css揭秘</a>这本书学到的一个有用的知识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS-linear-gradient的介绍和在实际项目中的使用&quot;&gt;&lt;a href=&quot;#CSS-linear-gradient的介绍和在实际项目中的使用&quot; class=&quot;headerlink&quot; title=&quot;CSS: linear-gradient的介绍和在实际项</summary>
      
    
    
    
    <category term="Web前端" scheme="https://yjunuser.github.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="CSS" scheme="https://yjunuser.github.io/tags/CSS/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>TypeScript基础类型</title><meta name="description" content="程序员 码农 热爱前端"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="TypeScript 基础类型TypeScript 中的类型有

TypeScript中的基础类型都是小写，大写开头的表示的是javascript的构造函数


原始类型
boolean
number
string
bigint
null
undefined
symbol
void


元组 tuple
枚举 enum
任意 any
unknown
never
数组 Array
对象 object

void 类型当一个函数没有返回值时，可以声明为void
123function doNothing(): void {    let a = 10}

还可以声明一个void类型的变量，但只能赋值为undefined或者null
1let nothing: void = undefined

null 类型和.."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="xiaoyao日志" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">姚伯骏's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">TypeScript基础类型</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-text">TypeScript 基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#void-%E7%B1%BB%E5%9E%8B"><span class="toc-text">void 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null-%E7%B1%BB%E5%9E%8B%E5%92%8C-undefined-%E7%B1%BB%E5%9E%8B"><span class="toc-text">null 类型和 undefined 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">数组类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#any-%E7%B1%BB%E5%9E%8B"><span class="toc-text">any 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E7%82%B9"><span class="toc-text">容易混淆的点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bigint"><span class="toc-text">bigint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#symbol"><span class="toc-text">symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#symbol%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">symbol使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-text">元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-Never-%E4%B8%8E-Unknown"><span class="toc-text">TypeScript Never 与 Unknown</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Never"><span class="toc-text">Never</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unknown"><span class="toc-text">Unknown</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E6%8E%A5%E5%8F%A3-Interface"><span class="toc-text">TypeScript 接口(Interface)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">接口的好处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">举例说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">接口的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7-%E5%92%8Cconst%E5%AF%B9%E5%BA%94%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%98%AF%E5%B1%9E%E6%80%A7%E4%B8%80%E4%B8%AA%E6%98%AF%E5%8F%98%E9%87%8F"><span class="toc-text">只读属性(和const对应，一个是属性一个是变量)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#readonlyvsconst"><span class="toc-text">readonlyvsconst&#96;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">任意属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">6. 可索引类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-text">类类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-text">8. 继承接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">9. 混合类型</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/TypeScript"><i class="tag post-item-tag">TypeScript</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">TypeScript基础类型</h1><time class="has-text-grey" datetime="2021-04-25T16:00:00.000Z">2021-04-26</time><article class="mt-2 post-content"><h1 id="TypeScript-基础类型"><a href="#TypeScript-基础类型" class="headerlink" title="TypeScript 基础类型"></a>TypeScript 基础类型</h1><p>TypeScript 中的类型有</p>
<blockquote>
<p>TypeScript中的基础类型都是小写，大写开头的表示的是javascript的构造函数</p>
</blockquote>
<ul>
<li>原始类型<ul>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>bigint</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
<li>void</li>
</ul>
</li>
<li>元组 tuple</li>
<li>枚举 enum</li>
<li>任意 any</li>
<li>unknown</li>
<li>never</li>
<li>数组 Array</li>
<li>对象 object</li>
</ul>
<h2 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h2><p>当一个函数没有返回值时，可以声明为void</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>(<span class="params"></span>): <span class="title">void</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还可以声明一个<code>void</code>类型的变量，但只能赋值为<code>undefined</code>或者<code>null</code></p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nothing: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="null-类型和-undefined-类型"><a href="#null-类型和-undefined-类型" class="headerlink" title="null 类型和 undefined 类型"></a>null 类型和 undefined 类型</h2><p><code>undefined</code> 和 <code>null</code> 是<strong>所有类型的子类型</strong>。</p>
<p>一般项目是默认开启 <code>--strictNullChecks</code> 检测的，如果你将 <code>tsconfig.json</code> 中 <code>strictNullChecks</code> 选项设置为 <code>false</code>，下面这种操作不会报错，不过尽量不要这么做：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="literal">undefined</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>数组类型有两种表示方法，第一种在元素类型后接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> names: <span class="built_in">string</span>[] = [<span class="string">'Sherlock'</span>, <span class="string">'Watson'</span>, <span class="string">'Mrs. Hudson'</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>另一种方式是使用数组泛型（<em>泛型后续会单独介绍</em>），<code>Array&lt;元素类型&gt;</code>：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> names: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'Sherlock'</span>, <span class="string">'Watson'</span>, <span class="string">'Mrs. Hudson'</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>混合各种元素类型：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>推荐使用第一种数组类型的表示方法，书写比较简洁直观。</p>
<h2 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h2><p>有时候接收来自用户的输入，我们是不能确定其变量类型的。这种情况下，我们不希望类型检查器对这些值进行检查，而是直接让它们通过编译阶段的检查，此时可以使用 <code>any</code>：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input: <span class="built_in">any</span> = <span class="string">'nothing'</span></span><br><span class="line"></span><br><span class="line">input = <span class="number">0</span>                   <span class="comment">// ok</span></span><br><span class="line">input = <span class="literal">true</span>                <span class="comment">// ok</span></span><br><span class="line">input = []                  <span class="comment">// ok</span></span><br><span class="line">input = <span class="literal">null</span>                <span class="comment">// ok</span></span><br><span class="line">input = <span class="built_in">Symbol</span>(<span class="string">'any'</span>)       <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果一个数据是 any 类型，那么可以访问它的任意属性，即使这个属性不存在：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anything: <span class="built_in">any</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">anything.eat()              <span class="comment">// ok</span></span><br><span class="line">anything.name               <span class="comment">// ok</span></span><br><span class="line">anything[<span class="number">0</span>]                 <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">new</span> anything()              <span class="comment">// ok</span></span><br><span class="line">anything()                  <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure>

<p>从上面的例子中可以看到，any 类型几乎可以做任何操作，这样很容易编写类型正确但是执行异常的代码。我们使用 TypeScript 就是为了代码的健壮性，所以要<strong>尽量减少 any 的使用</strong>。</p>
<blockquote>
<p>any类型很像在javascript直接定义一个变量</p>
</blockquote>
<h2 id="容易混淆的点"><a href="#容易混淆的点" class="headerlink" title="容易混淆的点"></a>容易混淆的点</h2><figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">Number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">'10'</span>) <span class="comment">// a === 10 为 false</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">number</span> = <span class="built_in">Number</span>(<span class="string">'10'</span>) <span class="comment">// b === 10 为 true</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong></p>
<p>第 1 行，通过 <code>new Number('10')</code> 得到的是<strong>一个构造函数，本质是一个对象</strong>。</p>
<p>第 2 行，<code>Number('10')</code> 与 <code>10</code> 都是声明一个数字 10 的方法，本质就是一个数字。</p>
<p>第 4 - 5 行，<code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。<code>a</code> 是一个对象，它的 <code>__proto__</code> 属性指向该对象的构造函数的原型对象 <code>Number</code>，所以为 <code>true</code>。<code>b</code> 是一个数字，所以为 <code>false</code>。</p>
<p><code>__proto__</code> 是非标准属性，你也可以使用 <strong><code>Object.getPrototypeOf()</code></strong> 方法来访问一个对象的原型：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__ === <span class="built_in">Object</span>.getPrototypeOf(a) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h2><p><code>bigint</code> 是一种基本数据类型（primitive data type）。</p>
<p>JavaScript 中可以用 <code>Number</code> 表示的最大整数为 <code>2^53 - 1</code>，可以写为 <code>Number.MAX_SAFE_INTEGER</code>。如果超过了这个界限，可以用 <code>BigInt</code>来表示，它可以表示任意大的整数。</p>
<p>在一个整数字面量后加 <code>n</code> 的方式定义一个 <code>BigInt</code>，如：<code>10n</code> 或者调用函数 <code>BigInt()</code>：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> theBiggestInt: bigint = <span class="number">9007199254740991n</span></span><br><span class="line"><span class="keyword">const</span> alsoHuge: bigint = <span class="built_in">BigInt</span>(<span class="number">9007199254740991</span>)</span><br><span class="line"><span class="keyword">const</span> hugeString: bigint = <span class="built_in">BigInt</span>(<span class="string">"9007199254740991"</span>)</span><br><span class="line"></span><br><span class="line">theBiggestInt === alsoHuge <span class="comment">// true</span></span><br><span class="line">theBiggestInt === hugeString <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>BigInt</code> 与 <code>Number</code> 的不同点：</p>
<ul>
<li><code>BigInt</code> 不能用于 <code>Math</code> 对象中的方法。</li>
<li><code>BigInt</code> 不能和任何 <code>Number</code> 实例混合运算，两者必须转换成同一种类型。</li>
<li><code>BigInt</code> 变量在转换为 <code>Number</code> 变量时可能会丢失精度。</li>
</ul>
<p><code>Number</code> 和 <code>BigInt</code> 可以进行比较：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0n</span> === <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1n</span> &lt; <span class="number">2</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">1</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">2</span>   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt; <span class="number">2</span>  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">2n</span> &gt;= <span class="number">2</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p>条件判断：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0n</span>) {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'条件成立!'</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'条件不成立!'</span>); <span class="comment">// 输出结果</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> || <span class="number">10n</span>    <span class="comment">// 10n</span></span><br><span class="line"></span><br><span class="line"><span class="number">0n</span> &amp;&amp; <span class="number">10n</span>    <span class="comment">// 0n</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0n</span>)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">10n</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="number">10n</span>         <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!<span class="number">0n</span>          <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p><code>symbol</code> 是一种基本数据类型。</p>
<p><code>Symbol()</code> 函数会返回 <code>symbol</code> 类型的值。每个从 <code>Symbol()</code> 返回的 <code>symbol</code> 值都是<strong>唯一</strong>的。</p>
<p>使用 Symbol() 创建新的 symbol 类型：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym1: symbol = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> sym2: symbol = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="keyword">const</span> sym3: symbol = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line">代码块<span class="number">123</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码创建了三个新的 symbol 类型，但要注意每个从 Symbol() 返回的值都是唯一的：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sym2 === sym3) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 每个 <code>Symbol()</code> 方法返回的值都是唯一的，所以，sym2 和 sym3 不相等。</p>
<p>Symbol() 作为构造函数是不完整的：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="keyword">new</span> <span class="built_in">Symbol</span>() <span class="comment">// TypeError</span></span><br></pre></td></tr></tbody></table></figure>

<p>这种语法会报错，是因为从 ECMAScript 6 开始<strong>围绕原始数据类型创建一个显式包装器对象已不再被支持</strong>，但因历史遗留原因， <code>new Boolean()</code>、<code>new String()</code> 以及 <code>new Number()</code> 仍可被创建：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>()   <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">const</span> bigint = <span class="keyword">new</span> <span class="built_in">BigInt</span>()   <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>()   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>() <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> = <span class="keyword">new</span> <span class="built_in">String</span>()   <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="symbol使用场景"><a href="#symbol使用场景" class="headerlink" title="symbol使用场景"></a>symbol使用场景</h4><ul>
<li>当一个对象有较多属性时（<em>往往分布在不同文件中由模块组合而成</em>），很容易将某个属性名覆盖掉，使用 <code>Symbol</code> 值可以避免这一现象，比如 <code>vue-router</code> 中的 <code>name</code> 属性。</li>
</ul>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js 文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> aRouter = {</span><br><span class="line">  path: <span class="string">'/index'</span>,</span><br><span class="line">  name: <span class="built_in">Symbol</span>(<span class="string">'index'</span>),</span><br><span class="line">  component: Index</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bRouter = {</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="built_in">Symbol</span>(<span class="string">'index'</span>), <span class="comment">// 不重复</span></span><br><span class="line">  component: Home</span><br><span class="line">},</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes.js 文件</span></span><br><span class="line"><span class="keyword">import</span> { aRouter } <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> { bRouter } <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  aRouter,</span><br><span class="line">  bRouter</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 两个不同文件使用了同样的 <code>Symbol('index')</code> 作为属性 name 的值，因 symbol 类型的唯一性，就避免了<strong>重复定义</strong>。</p>
<ul>
<li>模拟类的<strong>私有方法</strong></li>
</ul>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> permission: symbol = <span class="built_in">Symbol</span>(<span class="string">'permission'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auth</span> </span>{</span><br><span class="line">  [permission]() {</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种情况<strong>通过类的实例是</strong>无法取到该方法，模拟类的私有方法。</p>
<p>但是，TypeScript 是可以使用 <code>private</code> 关键字的，所以这种方法可以在 JavaScript 中使用。</p>
<ul>
<li>判断是否可以用 <code>for...of</code> 迭代</li>
</ul>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> iterable) {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n <span class="keyword">of</span> iterable) {</span><br><span class="line">      <span class="built_in">console</span>.log(n)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个知识点后续会在 <code>迭代器</code> 那一节会着重介绍，这里可以先知晓：</p>
<p>   <code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。<br>   <code>for...of</code> 只能迭代可枚举属性。</p>
<ul>
<li>Symbol.prototype.description</li>
</ul>
<p><code>Symbol([description])</code> 中可选的字符串即为这个 Symbol 的描述，如果想要获取这个描述：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym: symbol = <span class="built_in">Symbol</span>(<span class="string">'imooc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sym);               <span class="comment">// Symbol(imooc)</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.toString());    <span class="comment">// Symbol(imooc)</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.description);   <span class="comment">// imooc</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>通过元组可以存储不同类型的元素，而非像数组那样只能存储相同元素类型（any[] 除外）。</p>
<p>声明一个由 <code>string</code> 和 <code>number</code> 构成的元组：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]   <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list1: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="number">1887</span>, <span class="string">'Sherlock'</span>]  <span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 元组中规定的元素类型<strong>顺序必须是完全对照的</strong>，而且<strong>不能多、不能少</strong>（数量也必须一样，数组有了长度）<code>list1</code> 中定义的第一个元素为 <code>string</code>类型，不能赋值为 <code>number</code>类型的数据。</p>
<p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">0</span>].substr(<span class="number">1</span>)  <span class="comment">// ok</span></span><br><span class="line">list[<span class="number">1</span>].substr(<span class="number">1</span>)  <span class="comment">// Property 'substr' does not exist on type 'number'.</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong></p>
<p>第 3 行，<code>list[0]</code> 是一个字符串类型，拥有 substr() 方法。</p>
<p>第 4 行，<code>list[1]</code> 是一个数字类型，没有 substr() 方法，所以报错。</p>
<p>要注意元组的越界问题，虽然<strong>可以越界添加元素</strong>（<em>不建议</em>），但是<strong>不可越界访问</strong>：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'Sherlock'</span>, <span class="number">1887</span>]</span><br><span class="line">list.push(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(list)      <span class="comment">// ok [ 'Sherlock', 1887, 'hello world' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(list[<span class="number">2</span>])   <span class="comment">// Tuple type '[string, number]' of length '2' has no element at index '2'</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong></p>
<p>第 2 行，向一个声明了<strong>只有两个元素的元组</strong>继续添加元素，这种操作虽然可行，但是严重不建议！</p>
<p>第 5 行，该元组只有两个元素，不可越界访问第三个元素。</p>
<p>元组类型允许在元素类型后缀一个 <code>?</code> 来说明元素是可选的：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">number</span>, <span class="built_in">string</span>?, <span class="built_in">boolean</span>?]</span><br><span class="line">list = [<span class="number">10</span>, <span class="string">'Sherlock'</span>, <span class="literal">true</span>]</span><br><span class="line">list = [<span class="number">10</span>, <span class="string">'Sherlock'</span>]</span><br><span class="line">list = [<span class="number">10</span>]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>可选元素必须在必选元素的后面，也就是如果一个元素后缀了 <code>?</code>号，其后的所有元素都要后缀 <code>?</code>号</strong>。</p>
<p>元组可以作为参数传递给函数，函数的 Rest 形参可以定义为元组类型（动态长度）：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">rest</span>(<span class="params">...args: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>]</span>): <span class="title">void</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>等价于：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">rest</span>(<span class="params">arg1: <span class="built_in">number</span>, arg2: <span class="built_in">string</span>, arg3: <span class="built_in">boolean</span></span>): <span class="title">void</span></span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p><strong>TIPS：</strong> 在声明文件（.d.ts）中，关键字 declare 表示声明作用。声明文件用于编写第三方类库，通过配置 <code>tsconfig.json</code> 文件中的 <code>declaration 为 true</code>，在编译时可自行生成。</p>
</blockquote>
<p>还可以这样：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list: [<span class="built_in">number</span>, ...string[]] = [<span class="number">10</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list1: [<span class="built_in">string</span>, ...number[]] = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> Rest 元素指定了元组类型是无限扩展的，可能有零个或多个具有数组元素类型的额外元素。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>需要定义一组相同主题的常量数据时，应该立即想到枚举类型。在学习过程中，需要注意枚举类型的<strong>正向映射和反向映射</strong></p>
<p>使用枚举我们可以定义一些<strong>带名字的常量</strong>。TypeScript 支持<strong>数字</strong>的和基于<strong>字符串</strong>的枚举。</p>
<p>枚举类型弥补了 JavaScript 的设计不足，很多语言都拥有枚举类型。</p>
<p>当我们需要一组相同主题下的数据时，枚举类型就很有用了。</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction { Up, Down, Left, Right }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Months { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Size { big = <span class="string">'大'</span>, medium = <span class="string">'中'</span>, small = <span class="string">'小'</span> }</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Agency { province = <span class="number">1</span>, city = <span class="number">2</span>, district = <span class="number">3</span> }</span><br></pre></td></tr></tbody></table></figure>

<p>声明一个枚举类型，如果没有赋值，它们的值默认为<strong>数字类型</strong>且从 0 开始累加：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Months.Jan === <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">Months.Feb === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">Months.Mar === <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line">Months.Apr === <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p>现实中月份是从 1 月开始的，那么只需要这样：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第一个数字赋值，往后依次累加</span></span><br><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Months.Jan === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">Months.Feb === <span class="number">2</span> <span class="comment">// true</span></span><br><span class="line">Months.Mar === <span class="number">3</span> <span class="comment">// true</span></span><br><span class="line">Months.Apr === <span class="number">4</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p>枚举类型的值为<strong>字符串类型</strong>：</p>
<p>实例演示</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> TokenType {</span><br><span class="line">  ACCESS = <span class="string">'accessToken'</span>,</span><br><span class="line">  REFRESH = <span class="string">'refreshToken'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种不同的取值写法</span></span><br><span class="line"><span class="built_in">console</span>.log(TokenType.ACCESS === <span class="string">'accessToken'</span>)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(TokenType[<span class="string">'REFRESH'</span>] === <span class="string">'refreshToken'</span>)   <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 枚举的取值，有 <code>TokenType.ACCESS</code> 和 <code>TokenType['ACCESS']</code> 这两种不同的写法，效果是相同的。</p>
<p><strong>数字类型和字符串类型可以混合使用，但是不建议：</strong></p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> BooleanLikeHeterogeneousEnum {</span><br><span class="line">    No = <span class="number">0</span>,</span><br><span class="line">    Yes = <span class="string">"YES"</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>枚举类型的值可以是一个简单的<strong>计算表达式</strong>：</p>
<p>实例演示</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Calculate {</span><br><span class="line">  a,</span><br><span class="line">  b,</span><br><span class="line">  expired = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>,</span><br><span class="line">  length = <span class="string">'imooc'</span>.length,</span><br><span class="line">  plus = <span class="string">'hello '</span> + <span class="string">'world'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.expired)   <span class="comment">// 86400</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.length)    <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(Calculate.plus)      <span class="comment">// hello world</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>Tips:</strong></p>
<ul>
<li>计算结果必须为常量。</li>
<li>计算项必须放在最后。</li>
</ul>
<p>所谓的反向映射就是指枚举的取值，不但可以正向的 <code>Months.Jan</code> 这样取值，也可以反向的 <code>Months[1]</code> 这样取值。</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Months.Mar === <span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那么反过来能取到 Months[3] 的值吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(Months[<span class="number">3</span>])  <span class="comment">// 'Mar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以</span></span><br><span class="line"><span class="built_in">console</span>.log(Months.Mar === <span class="number">3</span>)     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Months[<span class="number">3</span>] === <span class="string">'Mar'</span>)  <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>Tips:</strong></p>
<ol>
<li>字符串枚举成员不会生成反向映射。</li>
<li>枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。</li>
</ol>
<p>在枚举上使用 <code>const</code> 修饰符：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> month = Months.Mar</span><br></pre></td></tr></tbody></table></figure>

<p>查看一下编译后的内容：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> month = <span class="number">3</span> <span class="comment">/* Mar */</span></span><br><span class="line">代码块<span class="number">12</span></span><br></pre></td></tr></tbody></table></figure>

<p>发现枚举类型应该编译出的对象没有了，只剩下 <code>month</code> 常量。这就是使用 <code>const</code> 关键字声明枚举的作用。因为变量 <code>month</code> 已经使用过枚举类型，在编译阶段 TypeScript 就将枚举类型抹去，这也是<strong>性能提升</strong>的一种方案。</p>
<p>分开声明名称相同的枚举类型，会<strong>自动合并</strong>：</p>
<p>实例演示</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  Jan = <span class="number">1</span>,</span><br><span class="line">  Feb,</span><br><span class="line">  Mar,</span><br><span class="line">  Apr</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">enum</span> Months {</span><br><span class="line">  May = <span class="number">5</span>,</span><br><span class="line">  Jun</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Months.Apr) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(Months.Jun) <span class="comment">// 6</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="TypeScript-Never-与-Unknown"><a href="#TypeScript-Never-与-Unknown" class="headerlink" title="TypeScript Never 与 Unknown"></a>TypeScript Never 与 Unknown</h1><p>本节介绍 never 和 unknown 类型，其中 unknown 类型作为 any 类型对应的安全类型使用起来更加安全，如果有<strong>any 类型的使用需求</strong>，应尽量使用 **unknown 类型来替代 **any 类型。</p>
<p><code>never</code> 类型表示那些永不存在的值的类型。</p>
<p><code>unknown</code> 类型是 <code>any</code> 类型对应的安全类型。</p>
<h2 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h2><p>一个抛出异常的函数表达式，其函数返回值类型为 never：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message:<span class="built_in">string</span></span>): <span class="title">never</span> </span>{</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>同样的，不会有返回值的函数表达式，其函数返回值类型也为 never:</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断的返回值类型为 never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>): <span class="title">never</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不能取得值的地方：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo {</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'foo'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bar {</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'bar'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> All = Foo | Bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleValue</span>(<span class="params">val: All</span>) </span>{</span><br><span class="line">  <span class="keyword">switch</span> (val.type) {</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'foo'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'bar'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 此处不能取值</span></span><br><span class="line">      <span class="keyword">const</span> exhaustiveCheck: <span class="built_in">never</span> = val</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Unknown"><a href="#Unknown" class="headerlink" title="Unknown"></a>Unknown</h2><p>我们知道 any 无需事先执行任何类型的检查：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="number">10</span>               <span class="comment">// OK</span></span><br><span class="line">value = <span class="string">"Hello World"</span>    <span class="comment">// OK</span></span><br><span class="line">value = []               <span class="comment">// OK</span></span><br><span class="line">value = {}               <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Math</span>.random      <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">null</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">undefined</span>        <span class="comment">// OK</span></span><br><span class="line">value = <span class="keyword">new</span> <span class="built_in">TypeError</span>()  <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)   <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">value.foo.bar            <span class="comment">// OK</span></span><br><span class="line">value.trim()             <span class="comment">// OK</span></span><br><span class="line">value()                  <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">new</span> value()              <span class="comment">// OK</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]              <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure>

<p>在许多情况下，这太宽松了。 <code>unknown</code> 类型呢？</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line">value = <span class="literal">true</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="number">10</span>               <span class="comment">// OK</span></span><br><span class="line">value = <span class="string">"Hello World"</span>    <span class="comment">// OK</span></span><br><span class="line">value = []               <span class="comment">// OK</span></span><br><span class="line">value = {}               <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Math</span>.random      <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">null</span>             <span class="comment">// OK</span></span><br><span class="line">value = <span class="literal">undefined</span>        <span class="comment">// OK</span></span><br><span class="line">value = <span class="keyword">new</span> <span class="built_in">TypeError</span>()  <span class="comment">// OK</span></span><br><span class="line">value = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)   <span class="comment">// OK</span></span><br></pre></td></tr></tbody></table></figure>

<p>所有对该 <code>value</code> 变量的分配都被认为是类型正确的。</p>
<p>但是，如果尝试：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value1: unknown = value   <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> value2: <span class="built_in">any</span> = value       <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value3: <span class="built_in">boolean</span> = value   <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value4: <span class="built_in">number</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value5: <span class="built_in">string</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value6: <span class="built_in">object</span> = value    <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value7: <span class="built_in">any</span>[] = value     <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，该 unknown 类型<strong>只能分配给 any 类型和 unknown 类型</strong>本身。</p>
<p>现在继续尝试：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line"></span><br><span class="line">value.foo.bar  <span class="comment">// Error</span></span><br><span class="line">value.trim()   <span class="comment">// Error</span></span><br><span class="line">value()        <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">new</span> value()    <span class="comment">// Error</span></span><br><span class="line">value[<span class="number">0</span>][<span class="number">1</span>]    <span class="comment">// Error</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong><code>unknown</code> 类型在被确定为某个类型之前，不能被进行诸如函数执行、实例化等操作，一定程度上对类型进行了保护。</strong></p>
<blockquote>
<p>在那些将取得任意值，但不知道具体类型的地方使用 <code>unknown</code>，而非 <code>any</code>。</p>
</blockquote>
<h1 id="TypeScript-接口-Interface"><a href="#TypeScript-接口-Interface" class="headerlink" title="TypeScript 接口(Interface)"></a>TypeScript 接口(Interface)</h1><blockquote>
<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。——官方定义</p>
</blockquote>
<p>接口是对 JavaScript 本身的随意性进行约束，通过定义一个接口，<strong>约定了变量、类、函数等</strong>应该按照什么样的格式进行声明，实现多人合作的一致性。TypeScript 编译器依赖接口用于类型检查，最终编译为 JavaScript 后，接口将会被移除。</p>
<p><strong>接口主要是对对象、函数、类的类型做一些定义</strong></p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line"><span class="keyword">interface</span> DemoInterface {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在声明一个<strong>对象</strong>、<strong>函数</strong>或者<strong>类</strong>时，先定义接口，确保其数据结构的一致性。</p>
<p>在多人协作时，定义接口尤为重要。</p>
<h2 id="接口的好处"><a href="#接口的好处" class="headerlink" title="接口的好处"></a>接口的好处</h2><p>过去我们写 JavaScript 定义一个函数：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClothesInfo</span>(<span class="params">clothes</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(clothes.price)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClothes = {</span><br><span class="line">  color: <span class="string">'black'</span>, </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line">getClothesInfo(myClothes)</span><br></pre></td></tr></tbody></table></figure>

<p>之前我们写 JavaScript 这样是很正常的，但同时你可能会遇到下面这些问题:</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getClothesInfo() <span class="comment">// Uncaught TypeError: Cannot read property 'price' of undefined</span></span><br><span class="line">getClothesInfo({ <span class="attr">color</span>: <span class="string">'black'</span> }) <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure>

<p>相信原因你也知道，JavaScript 是 <code>弱类型</code> 语言，并不会对传入的参数进行任何检测，错误在运行时才被发现。那么通过定义 <code>接口</code>，在编译阶段甚至开发阶段就避免掉这类错误，接口<strong>将检查类型是否和某种结构做匹配</strong>。</p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>下面通过接口的方式重写之前的例子：</p>
<p>实例演示</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClothesInfo</span>(<span class="params">clothes: Clothes</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(clothes.price)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  color: <span class="string">'black'</span>, </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getClothesInfo(myClothes)</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 代码中，定义了一个接口 <code>Clothes</code>，在传入的变量 <code>clothes</code> 中，它的类型为 <code>Clothes</code>。这样，就约束了这个传入对象的 <code>外形</code> 与接口定义一致。只要传入的对象满足上面的类型约束，那么它就是被允许的。</p>
<p><strong>Tips：</strong></p>
<ol>
<li>定义接口要 <code>首字母大写</code>。</li>
<li>只需要关注值的 <code>外形</code>，并不像其他语言一样，定义接口是为了实现。</li>
<li>如果没有特殊声明，定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致。</li>
</ol>
<h2 id="接口的属性"><a href="#接口的属性" class="headerlink" title="接口的属性"></a>接口的属性</h2><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口中的属性不全是必需的。可选属性的含义是该属性在被变量定义时可以不存在。</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以不定义属性 color</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <code>?</code> 符号。</p>
<p>这时，<strong>仍不允许添加未定义的属性</strong>，如果引用了不存在的属性时 TS 将直接捕获错误。</p>
<h3 id="只读属性-和const对应，一个是属性一个是变量"><a href="#只读属性-和const对应，一个是属性一个是变量" class="headerlink" title="只读属性(和const对应，一个是属性一个是变量)"></a>只读属性(和const对应，一个是属性一个是变量)</h3><p>一些对象属性<strong>只能在对象刚刚创建的时候修改其值</strong>。你可以在属性名前用 <code>readonly</code> 来指定只读属性，比如价格是不能被修改的:</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> price: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的时候给 price 赋值</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可修改</span></span><br><span class="line">myClothes.price = <span class="number">100</span></span><br><span class="line"><span class="comment">// error TS2540: Cannot assign to 'price' because it is a constant or a read-only property</span></span><br></pre></td></tr></tbody></table></figure>

<p>TypeScript 可以通过 <code>ReadonlyArray&lt;T&gt;</code> 设置数组为只读，那么它的所有<strong>写方法</strong>都会失效。</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">6</span>; <span class="comment">// Index signature in type 'readonly number[]' only permits reading</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 代码中的泛型语法在之后会有专门的小节介绍。</p>
<h4 id="readonlyvsconst"><a href="#readonlyvsconst" class="headerlink" title="readonlyvsconst`"></a>readonly<code>vs</code>const`</h4><p>最简单判断该用 <code>readonly</code> 还是 <code>const</code> 的方法是看要把它做为<strong>变量使用还是做为一个属性</strong>。做为 <code>变量</code> 使用的话用 const，若做为 <code>属性</code> 则使用 readonly。</p>
<h3 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h3><p>有时候我们希望接口允许有任意的属性，语法是用 <code>[]</code> 将属性包裹起来：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">interface</span> Clothes {</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  size: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> price: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意属性 activity</span></span><br><span class="line"><span class="keyword">let</span> myClothes: Clothes = { </span><br><span class="line">  size: <span class="string">'XL'</span>, </span><br><span class="line">  price: <span class="number">98</span>,</span><br><span class="line">  activity: <span class="string">'coupon'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 这里的接口 <code>Clothes</code> 可以有任意数量的属性，并且只要它们不是 <code>color</code> <code>size</code> 和 <code>price</code>，那么就无所谓它们的类型是什么。</p>
<ul>
<li>项目案例：使用 axios 库发起 HTTP 传输的时候，可以写入一个自定义的属性，就是因为源码中定义了一个任意属性：</li>
</ul>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$axios({</span><br><span class="line">  method: <span class="string">'put'</span>,</span><br><span class="line">  url: <span class="string">'/cms/user'</span>,</span><br><span class="line">  data: {</span><br><span class="line">    nickname: <span class="built_in">this</span>.nickname,</span><br><span class="line">  },</span><br><span class="line">  showBackend: <span class="literal">true</span>,</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>除了描述带有属性的普通对象外，接口也可以描述<strong>函数类型。</strong></p>
<p>为了使接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个<strong>只有 <code>参数列表</code> 和 <code>返回值类型</code> 的函数定义</strong>。</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> source.search(subString) &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>对于函数类型的类型检查来说，<strong>函数的参数名不需要与接口里定义的名字相匹配</strong>。你可以改变函数的参数名，<strong>只要保证函数参数的位置不变。函数的参数会被逐个进行检查：</strong></p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line"><span class="comment">// source =&gt; src, subString =&gt; sub</span></span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="title">boolean</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> src.search(sub) &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量。</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc {</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">src, sub</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> result = src.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>如果接口中的函数类型带有函数名，下面两种书写方式是等价的：</strong></p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Calculate {</span><br><span class="line">  add(x: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">  multiply: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="6-可索引类型"><a href="#6-可索引类型" class="headerlink" title="6. 可索引类型"></a>6. 可索引类型</h2><p>可索引类型接口读起来有些拗口，直接看例子：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常的js代码</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  brand: <span class="string">'imooc'</span>,</span><br><span class="line">  type: <span class="string">'education'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>]</span><br><span class="line">obj[<span class="string">'brand'</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>再来看定义可索引类型接口：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ScenicInterface {</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: ScenicInterface = [<span class="string">'西湖'</span>, <span class="string">'华山'</span>, <span class="string">'故宫'</span>]</span><br><span class="line"><span class="keyword">let</span> favorite: <span class="built_in">string</span> = arr[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>示例中索引签名是 <code>number类型</code>，返回值是字符串类型。</p>
<p>另外还有一种索引签名是 <code>字符串类型</code>。我们可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。通过下面的例子理解这句话：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">interface</span> Foo {</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">interface</span> Bar {</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">string</span>; <span class="comment">// Error: y 属性必须为 number 类型， 代表用y去索引返回string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong></p>
<p>语法错误是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><p>我们希望<strong>类的实现必须遵循接口定义</strong>，那么可以使用 <code>implements</code> 关键字来确保兼容性。</p>
<p>这种类型的接口在传统面向对象语言中最为常见，比如 java 中接口就是这种类类型的接口。<strong>这种接口与抽象类比较相似，但是接口只能含有抽象方法和成员属性，实现类中必须实现接口中所有的抽象方法和成员属性。</strong></p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AnimalInterface {</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">AnimalInterface</span> </span>{</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你也可以在接口中描述一个方法，在类里实现它:</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> AnimalInterface {</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  eat(m: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="title">implements</span> <span class="title">AnimalInterface</span> </span>{</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>{</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">eat</span>(<span class="params">m: <span class="built_in">number</span></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">${<span class="built_in">this</span>.name}</span>吃肉<span class="subst">${m}</span>分钟`</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure>

<p>接口描述了类的公共部分，而不是公共和私有两部分。 它<strong>不会帮你检查类是否具有某些私有成员。</strong></p>
<h2 id="8-继承接口"><a href="#8-继承接口" class="headerlink" title="8. 继承接口"></a>8. 继承接口</h2><p>和类一样，接口也可以通过关键字 <code>extents</code> 相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape {</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = {} <span class="keyword">as</span> Square;</span><br><span class="line"><span class="comment">// 继承了 Shape 的属性</span></span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape {</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke {</span><br><span class="line">  penWidth: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke {</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = {} <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">"blue"</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure>



<h2 id="9-混合类型"><a href="#9-混合类型" class="headerlink" title="9. 混合类型"></a>9. 混合类型</h2><p>在前面已经介绍，接口可以<strong>描述函数、对象的方法或者对象的属性。</strong></p>
<p>有时希望一个对象同时具有上面提到多种类型，比如一个<strong>对象可以当做函数使用，同时又具有属性和方法。</strong></p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter {</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  interval: <span class="built_in">number</span>;</span><br><span class="line">  reset(): <span class="built_in">void</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>{</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>{ } <span class="keyword">as</span> Counter;</span><br><span class="line">  counter.interval = <span class="number">123</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ };</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">5.0</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong></p>
<p>第 1 行，声明一个接口，<strong>如果只有 <code>(start: number): string</code> 一个成员，那么这个接口就是函数接口</strong>，同时还具有其他两个成员，可以用来描述对象的属性和方法，这样就构成了一个混合接口。</p>
<p>第 7 行，创建一个 <code>getCounter()</code> 函数，它的返回值是 Counter 类型的。</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>{ } <span class="keyword">as</span> Counter;</span><br></pre></td></tr></tbody></table></figure>

<p>第 8 行，通过类型断言，将函数对象转换为 <code>Counter</code> 类型，转换后的对象不但实现了函数接口的描述，使之成为一个函数，还具有 interval 属性和 reset() 方法。断言成功的条件是，两个数据类型只要有一方可以赋值给另一方，这里函数类型数据不能赋值给接口类型的变量，因为它不具有 interval 属性和 reset() 方法。</p>
<p>类型断言在之后的小节也会单节介绍。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/04/26/TypeScript%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/" title="TypeScript安装和使用"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: TypeScript安装和使用</span></a><a class="button is-default" href="/2021/04/24/helloworld/" title=""><span class="has-text-weight-semibold">Next: </span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/haojen"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> 姚伯骏 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>
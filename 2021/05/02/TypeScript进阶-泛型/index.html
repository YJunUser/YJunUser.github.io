<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>TypeScript进阶之泛型</title><meta name="description" content="程序员 码农 热爱前端"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="TypeScript 泛型通俗来讲：泛型是指在定义函数、接口或者类时，未指定其参数类型，只有在运行时传入才能确定。那么此时的参数类型就是一个变量，通常用大写字母 T 来表示，当然你也可以使用其他字符，如：U、K等。
语法：在函数名、接口名或者类名添加后缀 &amp;lt;T&amp;gt;：
123function generic&amp;lt;T&amp;gt;() {}interface Generic&amp;lt;T&amp;gt; {}class Generic&amp;lt;T&amp;gt; {}

初识泛型之所以使用泛型，是因为它帮助我们为不同类型的输入，复用相同的代码。
比如写一个最简单的函数，这个函数会返回任何传入它的值。如果传入的是 number 类型：
123function identity(arg: number): number {    .."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="xiaoyao日志" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">姚伯骏's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">TypeScript进阶之泛型</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript-%E6%B3%9B%E5%9E%8B"><span class="toc-text">TypeScript 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E6%B3%9B%E5%9E%8B"><span class="toc-text">初识泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-text">多个类型参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B"><span class="toc-text">泛型参数默认类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">泛型类型与泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%B1%BB%E5%9E%8B%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-text">多重类型泛型约束</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/TypeScript"><i class="tag post-item-tag">TypeScript</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">TypeScript进阶之泛型</h1><time class="has-text-grey" datetime="2021-05-01T16:00:00.000Z">2021-05-02</time><article class="mt-2 post-content"><h2 id="TypeScript-泛型"><a href="#TypeScript-泛型" class="headerlink" title="TypeScript 泛型"></a>TypeScript 泛型</h2><p><strong>通俗来讲</strong>：泛型是指在定义函数、接口或者类时，未指定其参数类型，只有在运行时传入才能确定。那么此时的参数类型就是一个变量，通常用大写字母 <code>T</code> 来表示，当然你也可以使用其他字符，如：<code>U</code>、<code>K</code>等。</p>
<p><strong>语法</strong>：在函数名、接口名或者类名添加后缀 <code>&lt;T&gt;</code>：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generic</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) </span>{}</span><br><span class="line"><span class="keyword">interface</span> Generic&lt;T&gt; {}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>{}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="初识泛型"><a href="#初识泛型" class="headerlink" title="初识泛型"></a>初识泛型</h3><p><strong>之所以使用泛型，是因为它帮助我们为不同类型的输入，复用相同的代码。</strong></p>
<p>比如写一个最简单的函数，这个函数会返回任何传入它的值。如果传入的是 number 类型：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果传入的是 string 类型：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">string</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过泛型，可以把两个函数统一起来：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>需要注意的是，泛型函数的返回值类型是根据你的业务需求决定，并非一定要返回泛型类型 T：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(arg)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 入参的类型是未知的，但是通过 String 转换，返回字符串类型。</p>
<h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><p>泛型函数可以定义多个类型参数：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> second) {</span><br><span class="line">    (first <span class="keyword">as</span> T &amp; U)[key] = second[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> first <span class="keyword">as</span> T &amp; U</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 这个函数用来合并两个对象，具体实现暂且不去管它，这里只需要关注泛型多个类型参数的使用方式，**其语法为通过逗号分隔 <code>&lt;T, U, K&gt;</code>**。</p>
<h3 id="泛型参数默认类型"><a href="#泛型参数默认类型" class="headerlink" title="泛型参数默认类型"></a>泛型参数默认类型</h3><p>函数参数可以定义默认值，泛型参数同样可以定义默认类型：</p>
<p>实例演示</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>&lt;<span class="title">T</span> = <span class="title">number</span>&gt;(<span class="params">arr:T[]</span>): <span class="title">T</span></span>{</span><br><span class="line">  <span class="keyword">let</span> min = arr[<span class="number">0</span>]</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">value</span>)=&gt;</span>{</span><br><span class="line">     <span class="keyword">if</span>(value &lt; min) {</span><br><span class="line">         min = value</span><br><span class="line">     }</span><br><span class="line">  })</span><br><span class="line">   <span class="keyword">return</span> min</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(min([<span class="number">20</span>, <span class="number">6</span>, <span class="number">8n</span>])) <span class="comment">// 6</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>解释：</strong> 同样的不用去关注这个最小数函数的具体实现，要知道**默认参数语法为 <code>&lt;T = 默认类型&gt;</code>**。</p>
<h3 id="泛型类型与泛型接口"><a href="#泛型类型与泛型接口" class="headerlink" title="泛型类型与泛型接口"></a>泛型类型与泛型接口</h3><p>先来回顾下之前章节介绍的函数类型：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> (x + y).toString()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>等号左侧的 <code>(x: number, y: number) =&gt; string</code> 为函数类型。</p>
<p>再看下泛型类型：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity</span><br></pre></td></tr></tbody></table></figure>

<p>同样的等号左侧的 <code>&lt;T&gt;(arg: T) =&gt; T</code> 即为泛型类型，它还有另一种<em>带有调用签名的对象字面量</em>书写方式：<code>{ &lt;T&gt;(arg: T): T }</code>:</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: { &lt;T&gt;(arg: T): T } = identity</span><br></pre></td></tr></tbody></table></figure>

<p>这就引导我们去写第一个泛型接口了。把上面例子里的对象字面量拿出来作为一个接口：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn {</span><br><span class="line">  &lt;T&gt;(arg: T): T</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn = identity</span><br></pre></td></tr></tbody></table></figure>

<p>进一步，把泛型参数当作整个接口的一个参数，我们可以把泛型参数提前到接口名上。这样我们就能清楚的知道使用的具体是哪个泛型类型：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; {</span><br><span class="line">  (arg: T): T</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity</span><br></pre></td></tr></tbody></table></figure>

<p>注意，在使用泛型接口时，需要传入一个类型参数来指定泛型类型。示例中传入了 number 类型，这就锁定了之后代码里使用的类型。</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>始终要记得，<strong>使用泛型是因为可以复用不同类型的代码</strong>。下面用一个最小堆算法举例说明泛型类的使用：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span> </span>{</span><br><span class="line">  <span class="keyword">public</span> list: <span class="built_in">number</span>[] = []</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">num: <span class="built_in">number</span></span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.list.push(num)</span><br><span class="line">  }</span><br><span class="line">  min(): <span class="built_in">number</span> {</span><br><span class="line">    <span class="keyword">let</span> minNum = <span class="built_in">this</span>.list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.list.length; i++) {</span><br><span class="line">      <span class="keyword">if</span> (minNum &gt; <span class="built_in">this</span>.list[i]) {</span><br><span class="line">        minNum = <span class="built_in">this</span>.list[i]</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minNum</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 示例中我们实现了一个查找 number 类型的最小堆类，但我们的最小堆还需要支持字符串类型，此时就需要泛型的帮助了：</p>
<p>实例演示</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名后加上 &lt;T&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">  <span class="keyword">public</span> list: T[] = []</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">num: T</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.list.push(num)</span><br><span class="line">  }</span><br><span class="line">  min(): T {</span><br><span class="line">    <span class="keyword">let</span> minNum = <span class="built_in">this</span>.list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.list.length; i++) {</span><br><span class="line">      <span class="keyword">if</span> (minNum &gt; <span class="built_in">this</span>.list[i]) {</span><br><span class="line">        minNum = <span class="built_in">this</span>.list[i]</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> minNum</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> MinClass&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">m.add(<span class="string">'hello'</span>)</span><br><span class="line">m.add(<span class="string">'world'</span>)</span><br><span class="line">m.add(<span class="string">'generic'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(m.min()) <span class="comment">// generic</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong></p>
<p>第 2 行，在声明 <code>类 MinClass</code> 的后面后加上了 <code>&lt;T&gt;</code>，这样就声明了泛型参数 T，作为一个变量可以是字符串类型，也可以是数字类型。</p>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p><strong>语法：通过 <code>extends</code> 关键字来实现泛型约束。</strong></p>
<p>如果我们很明确传入的泛型参数是什么类型，或者明确想要操作的某类型的值具有什么属性，那么就需要对泛型进行约束。通过两个例子来说明：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User {</span><br><span class="line">  username: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">User</span>&gt;(<span class="params">user: T</span>): <span class="title">string</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'imooc '</span> + user.username</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong> 示例中，第 5 行，我们约束了入参 user 必须包含 username 属性，否则在编译阶段就会报错。</p>
<p>下面再看另外一个例子：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Args = <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Args</span>&gt; </span>{}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MinClass&lt;<span class="built_in">boolean</span>&gt;() <span class="comment">// Error, 必须是 number | string 类型</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong></p>
<p>第 3 行，约束了泛型参数 T 继承自类型 Args，而类型 Args 是一个由 number 和 string 组成的联合类型。</p>
<p>第 5 行，泛型参数只能是 number 和 string 中的一种，传入 boolean 类型是错误的。</p>
<h3 id="多重类型泛型约束"><a href="#多重类型泛型约束" class="headerlink" title="多重类型泛型约束"></a>多重类型泛型约束</h3><p>通过 <code>&lt;T extends Interface1 &amp; Interface2&gt;</code> 这种语法来实现多重类型的泛型约束：</p>
<figure class="highlight ts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Sentence {</span><br><span class="line">  title: <span class="built_in">string</span>,</span><br><span class="line">  content: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Music {</span><br><span class="line">  url: <span class="built_in">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Sentence</span> &amp; <span class="title">Music</span>&gt; </span>{</span><br><span class="line">  <span class="keyword">private</span> prop: T</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">arg: T</span>)</span> {</span><br><span class="line">    <span class="built_in">this</span>.prop = arg</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">info</span>(<span class="params"></span>)</span> {</span><br><span class="line">    <span class="keyword">return</span> {</span><br><span class="line">      url: <span class="built_in">this</span>.prop.url,</span><br><span class="line">      title: <span class="built_in">this</span>.prop.title,</span><br><span class="line">      content: <span class="built_in">this</span>.prop.content</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码解释：</strong></p>
<p>第 10 行，约束了泛型参数 <code>T</code> 需继承自交叉类型（后续有单节介绍） <code>Sentence &amp; Music</code>，这样就能访问两个接口类型的参数。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/05/07/TypeScript%E8%BF%9B%E9%98%B6-utility%20types/" title="TypeScript进阶之utility types"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: TypeScript进阶之utility types</span></a><a class="button is-default" href="/2021/04/27/vue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92props%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6/" title="vue父组件传递props异步数据到子组件遇到的问题"><span class="has-text-weight-semibold">Next: vue父组件传递props异步数据到子组件遇到的问题</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/haojen"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> 姚伯骏 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>